#!/usr/bin/env bash
# save-changesnew functions to move options further up the script             02/25/2026
. /usr/local/save-changesnew/mergemodulesfunctions
dycmb() {
TFLD=""
#for x in $IFOLDERS; do [[ -e "$ch/$x" ]] && TFLD="$TFLD $x" ; done
# IFOLDERS="$TFLD"
TFLD="$( for x in $IFOLDERS; do [[ -e "$ch/$x" ]] && printf '%s\n' "$x" ; done)"
IFOLDERS="$TFLD"
# deduplicate
#TFLD=""
#for x in $IFOLDERS; do [[ " $FOLDERS " != *" $x "* ]] && TFLD="$TFLD $x" ; done
#if [[ -n "$TFLD" ]]; then FOLDERS="$TFLD" ; FOLDERS="$FOLDERS $IFOLDERS" ; fi
FOLDERS="$(for f in $FOLDERS $IFOLDERS; do echo "$f"; done | awk '!seen[$0]++')"
IFOLDERS="$FOLDERS"
}
#Generate exclude directories changes-commit
exldir() {
:> $1
grep ^!/ $CHNEXIT_CONF | fixdir > $EXCL
if [ -s "$EXCL" ]; then
	fixsqh < $EXCL > $EXCLUDED  # remove any leading / and leading ^
	sed -i 's|^|/|' $EXCLUDED  # adds / for $EXCLUDE to match dir exclusions 
	while IFS= read -r line; do [[ -z "$line" ]] && continue ; if [[ ! " $EXCLUDE " == *" $line "* ]]; then EXCLUDE="$EXCLUDE $line" ; fi ; done < $EXCLUDED
	unset IFS
fi
:> $EXCLUDED
# from VARS EXCLUDE 
#     if doesnt start with / it is a pattern, make it a pattern.
#     otherwise remove leading /    its a dir
for fld in $EXCLUDE; do if [[ $fld != /* ]]; then fld="*${fld}*"; else fld="${fld#/}" ; fi ; printf "%s\n" $fld ; done >> $EXCLUDED
# $trsyncexl is excld.ini
# What is only in EXCLUDED. append to EXFILES 
grep -Fvxf $trsyncexl $EXCLUDED > $UPDATE; test -s $UPDATE && cat $UPDATE >> $1 && rm $UPDATE
}
dlog() {
if [ "$d2drive" == "true" ]; then
    for fld in $FOLDERS; do
        fp="$dirSRC/$fld"
        if [ -d "$fp" ]; then
            find "$fp" -type f -printf '%P\n' | sed "s|^|/$fld/|" >> "${target}${rlt}${MODULENM}.bak.log"
        fi
    done
    for fld in $EXCLUDE; do
        fp="$dirSRC/$fld"
		if [[ "${fp:0:1}" == "/" ]]; then
			e=$(sed 's/[\/&\\]/\\&/g' <<< "$fp")
			p="^"
		else
			e="$fp" ; p=""
		fi
		sed -i "/$p$e/d" "${target}${rlt}${MODULENM}.bak.log"
	done
else
    find "$dirSRC" -type f -printf '%P\n' >> "${target}${rlt}${MODULENM}.bak.log"
fi
echo >> "${target}${rlt}${MODULENM}.bak.log"
}
glog() {
local k
local p
if [ -f ${target}${rlt}${MODULENM}.bak.log ]; then
	b=$( sed -nE 's/.*original count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n1)
	c=$( sed -nE 's/.*total count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n1)
	k=$( sed -nE 's/.*original size\(source\)=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n1)
fi
: "${b:-0}"
: "${c:-0}"
c=$(( c + b ))
: "${k:=Unkown}"
#if [ "$k" == "Unkown" ]; then
#    p=$( sed -nE 's/.*new size\(source\)=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log)
#fi
#: "${p:=Unkown}"
#if [ "$p" == "Unkown" ]; then
# do we go back and check the actual changes for size??
p=$osize
if [ "$1" == "true" ]; then > "${target}${rlt}${MODULENM}.bak.log" ; fi
dlog
echo "original size(source)=$k" >> "${target}${rlt}${MODULENM}.bak.log"
echo "new size(source)=$p" >> "${target}${rlt}${MODULENM}.bak.log"
if (( c != 0 )); then
    echo "original count=$c" >> "${target}${rlt}${MODULENM}.bak.log"
fi
echo  "END ORIGINAL FILES $(date +"%m-%d-%y_%R")" >> "${target}${rlt}${MODULENM}.bak.log"
nLOG="true"
}
autosave() { in=$( sed -n "104p" $chc | grep -o "Remount aufs with 'udba=none'") ; if [ "$autobackup" == "true" ] ; then val="$0 6 \"$USR\" \"yes\" \"$target\"" ; r=$( realpath "$0") ; [[ -n "$in" ]] && { ! grep -q "$r" "$chc" && sed -i "104i $val" $chc ; } || { p=$( grep -Fn "$r" $chc | cut -d: -f1) &&  [[ -z "$p" ]] && sed -i "104c $val" $chc ; } ; [[ ! -x $chc ]] && chmod +x $chc ; else [[ -z "$in" ]] && sed -i '104d' $chc ; fi ; }  #[[ -x $chc ]] && chmod -x $chc
#else No need to autoupdate as target rarely changes
#    lnc=$(grep "$0" $chc | awk -F'"' '{print $6}')
#    if [ "$lnc" != "$target" ]; then
#        sed -i "${p}c $0 6 \"$USR\" \"yes\" \"$target\"" $chc
#    fi
brnd() { BRAND=`date +"MDY_%m-%d-%y-TIME_%R"|tr ':' '_'` ; echo $BRAND >> $1 ; }
errmsg() { mount -o remount,udba=none / ; if [ "$1" != "false" ]; then test -d "$1" && rm -rf "${1:?}" ; test -d "$tmp" && rm -rf "${tmp:?}"; fi ; red "Error transfering files in key section of script. ${2}" >&2 ; cyan "Everything preserved.  Check the script" ; exit 1 ; }
errblk() { [[ "$trlt" -ne 0 ]] && errmsg "$mtmp" "$2" ; }
# Find out the files that have changed with dry run
createlog() {
rsync -an --out-format="%n" "$1/" "$2" --exclude '.wh.*' --exclude-from=$EXFILES > $3 # what changed  # | sed "s|^$1/||"  if using %f remove prefix **
rsync -anv "$1/" "$2" --exclude '.wh.*' --exclude-from=$EXFILES > $4 # rsync log
}
# Labelling before making .xzm from $ch
labelmk() {
brnd $1
if [ "$mdlLOGPRF" == "full" ]; then
    { echo ; cat $1; } >> $LOGDIR/$LOGFILE
elif [ "$mdlLOGPRF" == "incr" ]; then
    cp $1 $LOGDIR/$LOGFILE    
fi
}
# Make a new .xzm take into account previous changes so we have a small .xzm if still in session. for _uid_. if we are at the module archLMT merge first
newuid() {
local c=0 ; local t=0 ; local r=0
local u=0 ; local rlt=0
local keep=$tmp/outfile  # perishable
local remove=$tmp/deletre  # ..
local aend astart firstsv lswitch tfile
local mt h
local is_merge="true"
candidates=() ; mdlnames=()

output=""
# starting in $target$em saved to $pst
# Apply write forward merging (guardian) to save writes. More can go wrong implemented guardian for logic
h=$(find $target$em -type f -name '*_uid_*.xzm' ! -name '*_uid_L*' -print0 | xargs -0 -r ls -t | head -n 1)  # newest.  ls -tr oldest
if [[ -f /dev/shm/xsc && -n "$h" && -f "$h" ]]; then
	if [[ "$mdlMRGPRF" = "forward" ]]; then
		u=$(find . -maxdepth 1 -type f -name '*_uid_*.xzm' ! -name '*_uid_L*' | wc -l)
	fi
	if (( u > mdllmt)); then
		echo "Hit module merge limit merging on write forward"
		resolve_conflict "_uid_" "*.xzm" ".xzm" ".bak" $is_moved $oMF
        lswitch="true"
		is_available "*_uid_*.xzm" $target$em "/tmp" $is_moved $lswitch
		ret=$?
		if [ "$ret" -ne 0 ]; then
			goahead="false"
			if [ "$ret" -eq 1 ]; then
				end=$(date +%s.%N)
				while true; do
                    echo "pwd is ${PWD}"
					read -p "Not enough space in /tmp. just save changes to a new module?  (y/n): " yn
					case $yn in
						[Yy]* ) 
							if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then astart=$(date +%s.%N); fi
							if ! createxzm; then
								echo "Changes not saved. Either a file changed while saving or something went wrong."
							else
								aend=$(date +%s.%N)
								if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then el=$(awk -v end="$end" -v start="$start" -v aend="$aend" -v astart="$astart" 'BEGIN {print (end - start) + (aend - astart)}') ; printf "Saving took %.3f seconds.\n" "$el" ; fi
								test -e "${target}${em}/${rname}" && cyan "Your changes have been saved. in ${target}${em}/" && cyan $rname
							fi
							break
							;;
						[Nn]* ) 
							echo "Exiting."
                            break
							;;
						* ) 
							echo "Please answer y or n."
							;;
					esac
				done
			else
				echo "Unable to continue not enough space on drive for final mdl."
			fi
		fi
		# merge the modules then save and set shim
		if [[ "$goahead" = "true" ]]; then
			green "Merging changes modules..." ; sleep 3
			dirtybit="true"
			if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then astart=$(date +%s.%N); fi
			# cds to $mtmp then changes\$ch
			unpack $mtmp $SFILES $oMF $elog $is_routine $is_merge
			aend=$(date +%s.%N)
			if [ "$ANALYTICS" == "true" ]; then [[ "$ANALYTICSECT" = "true" ]] && elapse=$(awk "BEGIN {print $aend - $astart}") && cyan "Modules merged. Applying changes" ; fi
			# in changes
			cp $EXFILES $SFILES  # mksquash exclude version
			mv $QEXCL $EXFILES # reset exclusions for rsync
			# mv $SFILES $QEXCL  # uncomment to apply the exclusions again on ln184 in package_xzm
			procxzm "true"  # apply .wh. deletions ,copy to $mtmp
			# still in changes  
			cd $target$em
			package_xzm $mtmp $keepMRGED $elog $is_routine $is_merge $output
			is_rollback $mtmp "_uid_" $ROLLBCK $ROLLSUMRY $archLMT $is_routine
			echo "${target}${em}/${rname}" > /dev/shm/xsc
		fi
    # normal saving
	else
		if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then astart=$(date +%s.%N); fi
		cd $mtmp || exit
		tfile=$( cat /dev/shm/xsc)
		if [ ! -f $tfile ]; then  # use the first since boot failing that use h (newest) from above
			echo "Couldnt find last save point looking for next closest"
			goahead="false"			
			firstsv=""
			#cdiff=""
			srt_time_epoch=$(date -d "$(uptime -s)" +%s)
			while IFS= read -r -d '' file; do
				(( t++ ))
				if (( c == 0 )); then
					mt=$(stat -c %Y "$file")
					if (( mt > srt_time_epoch )); then
						firstsv=$file
						c=$t
					fi
				fi
			done < <( find "$target$em" -type f -name '*_uid_*.xzm' ! -name '*_uid_L*' -print0)
			unset IFS
			if [ -n "$firstsv" ]; then h=$firstsv ; fi
			if [ -f "$h" ]; then
				[[ $t -eq $c ]] && echo "Merging single module"
				goahead="true"
				tfile=$h
				echo "$tfile" > /dev/shm/xsc
			fi
		fi
		# extract all modules to tmpfs to build what files we have since boot
		if [[ "$goahead" = "true" ]]; then
			for mods in "${target}${em}/"*_uid_*.xzm; do 
				[[ "$mods" == *_uid_L* || ! -f "$mods" ]] && continue
			    if (( r == 0 )); then
			        if [ "$mods" == "$tfile" ]; then
			            r=1
			        fi
			    fi
			    if (( r )); then
					startmnt $is_merge
					mount -o loop $mods $dest
					rsync -a "$dest/" "$tmp" --exclude '.wh.*'
					rlt=$?
					if [ "$rlt" -ne 0 ]; then 
						mount -o remount,udba=none /
						test -d "$tmp" && rm -rf ${tmp:?} ; clear_mnt
						echo "failed to extract in newuid(). if unable resolve remove /dev/shm/xsc" && exit 1
					fi
					clear_mnt
			    fi
			done
		fi
		aend=$(date +%s.%N)
		if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then elapse=$( awk "BEGIN {print $aend - $astart}"); fi
        # save changes into seperate directory
		rsync -a "$ch/" "$mtmp" --exclude '.wh.*' --exclude-from=$EXFILES  # total current files
		trlt=$?
		errblk "$mtmp"
		test -e $LOGDIR/$LOGFILE && rm $LOGDIR/$LOGFILE  # dont exclude the log file
		find $mtmp -type f -printf '%P\n' > $tmp/contents  # the changes
        # what would be transfered then infer what to exclude with rsync dryrun
		createlog $mtmp $tmp $UPDATE $oMF

        # consistent log depends on version of rsync ** important

        #c="${mtmp#/}"  # --out-format="%f" full path. 
        #sed -i -e "\|$c/\.|d" -e "s|$c/||" -e '/^\./d' $UPDATE
		# cat $tmp/contents | grep -Fxvf $keep > $remove # total files - what would be transfered = remove

        sed -i -e '/^\./d' -e '/\/$/d' $UPDATE  # --out-format="%n" using relative # remove the unusable first line  . and any ending in /

		cp $UPDATE $keep
		# oMF is log made after at the same time
		#$keep           what needs to be transfered with usable paths
		#$remove       what should not be copied

		cat $tmp/contents | grep -Fvf $keep > $remove # the changes folder - what would be transfered = remove
		cat $remove >> $EXFILES # exclude these
		labelmk $oMF # copy\insert log before .xzm
		# cp $EXFILES /tmp/myfile.txt  debug
		# mksquashfs $ch /tmp/megar.xzm -comp $cmode -ef $EXFILES  debug
		base_cmd=(mksquashfs $ch "${target}${em}/${rname}" -comp $cmode -ef $EXFILES)  
		# [[ -s "$QEXCL" ]] && base_cmd+=(-ef $QEXCL)  # add excluded .wh. to EXFILES if needed
		if [ "$FEEDBACK" != "true" ]; then "${base_cmd[@]}" > /dev/null ; else "${base_cmd[@]}" ; fi
        if [ "$goahead" == "false" ]; then echo "${target}${em}/${rname}" > /dev/shm/xsc ; fi
		# module saved
	fi
# first save on startup
else
    if ! createxzm; then
        echo "Changes not saved either a file changed while saving or something went wrong."
	else
		echo "${target}${em}/${rname}" > /dev/shm/xsc
    fi
fi 
}
createxzm() { 
createlog $ch $tmp $UPDATE $oMF
labelmk $oMF
cm=(mksquashfs $ch "${target}${em}/${rname}" -comp $cmode -ef $EXFILES)
cpt=$( "${cm[@]}" 2>&1 | grep "changed size while reading" )
if [[ -n "$cpt" ]]; then 
    echo "$cpt"
    test -e "${target}${em}/${rname}" && rm "${target}${em}/${rname}"
    return 1
fi 
} 
# mksquash cant use -ef and -wildcards together. Below get around this. Then branch to either making a uid or uid_L try the fast way in both cases. If file changes during _uid_L go the slow way copy to mtmp to freeze fs
newxzm() { 
local p l d f fd
all=()
keep=()
mkdir $tmp
mkdir $mtmp
cp $EXFILES $QEXCL  # Backup EXFILES because we have to manipulate it to work with mksquash. EXFILES has all exclusions from changes-commit and VARS processed at top of script
# Process wildcards for mksquashfs
while IFS= read -r l; do [[ -z "$l" ]] && continue ; if [[ "$l" == \** ]]; then echo "$l" ; fi ; done < $EXFILES > $exclfiles  # read patterns from $EXCLUDE ie *share/Trash* 
# $tryncexl is excld.ini. 
# $exclfiles our patterns from $EXCLUDE
# Instead of sed can use  -printf '%P\n'  <--- works
while IFS= read -r p; do [[ -z "$p" || "$p" =~ ^# ]] && continue ; find "$ch" -path "$ch"/$p \( -type f -o -type d \) -print | sed "s|^$ch/||" ; done < <(cat $trsyncexl $exclfiles ) >> $EXFILES  # search the wildcards for mksquashfs
# all base folders in changes
while IFS= read -r d; do all+=("$(basename "$d")") ; done < <(find "$ch" -maxdepth 1 -mindepth 1 ) # ! -name ".wh.*"  
unset IFS 
# generate all base folders to exclude ie anything not in $FOLDERS at base /changes . avoids mnt, dev, run ect
# mksquash has to be accomodated so these steps are necessary. it can use flag -wildcards or -ef from file but not both 
# what is not in $FOLDERS we exclude
for d in "${all[@]}"; do fd="false" ; for f in $FOLDERS; do [[ "$d" == "$f" ]]  && fd="true" && break ; done ; [[ "$fd" == "false" && -d "$ch/$d" ]] && keep+=("$d") ; done 
printf "%s\n" "${keep[@]}" >> "$EXFILES"
test -e $exclfiles && rm $exclfiles  # remove tmp files.
# end Process wildcards for mksquashfs
if [ "$1" == "uid" ]; then
    if [ "$d2dmdl" == "true" ]; then
        tmp=$(mktemp -d "$xtgt/tmp.XXXXXX")  # using hdd for tmp files
		#test -d $thetgt/tmp && { mkdir $thetgt/tmp$$; tmp=$thetgt/tmp$$; } || { mkdir $thetgt/tmp; tmp=$thetgt/tmp; }  d2dmdl logic original from save-changesnew storage
    	#for x in $FOLDERS; do cp -arv $ch/"$x" $tmp &> /dev/null ; done
    fi
    newuid  # uid ^
# for uid_L
else 
    createxzm # try changes  ^ if fails try below
    trlt=$?
    # move to /tmp to freeze fs
    if [ "$trlt" -ne 0 ]; then 
	    echo "Files changed while saving copying to tmp..."
        cp $QEXCL $EXFILES # reset exclusions for rsync
		normalop="false"
        procxzm $normalop  # copy log and exclude with rsync.
	    base_cmd=(mksquashfs $mtmp "${target}${em}/${rname}" -comp $cmode)  # make the module
        if [ "$FEEDBACK" != "true" ]; then "${base_cmd[@]}" > /dev/null ; else "${base_cmd[@]}" ; fi
    fi
fi
end=$(date +%s.%N)
}
# Labeling of .xzm for files in /tmp below
label() {
mkdir -p "$mtmp$LOGDIR"
if [ "$mdlLOGPRF" == "full" ]; then
    { echo ; cat $UPDATE ; } >> $LOGDIR/$LOGFILE ; rm $UPDATE ; cp $LOGDIR/$LOGFILE $mtmp$LOGDIR/$LOGFILE
elif [ "$mdlLOGPRF" == "incr" ]; then
    test -e $ch$LOGDIR/$LOGFILE && rm $ch$LOGDIR/$LOGFILE ; cp $UPDATE $mtmp$LOGDIR/$LOGFILE && mv $UPDATE $LOGDIR/$LOGFILE    
fi
}
run_cmd() { 
if [ "$FEEDBACK" != "true" ]; then 
	"$@" >>"$UPDATE" 2>/dev/null
	trlt=$? 
else 
	"$@" | tee -a "$UPDATE"
	trlt=${PIPESTATUS[0]}
fi 
# see Merge ln 374
}
procxzm() {

local normalop="$1"
local found
local f y ex
# adtcmd=(--exclude '.wh.*')
cd $ch || { mount -o remount,udba=none /; exit; }
if [[ "$1" = "true" ]]; then
	shopt -s nullglob
    IFS="
    "
    for y in $(find $FOLDERS -name ".wh.*"); do
	    f="${y//.wh./}"
        test -e "$mtmp/$f" && rm -rf "$mtmp/$f"
		found="false"
		items=( "$INAME"/*/"$f" )
		if ((${#items[@]})); then found="true" ; fi
        [[ "$found" == "true" ]] || { echo "$y" | fixwh >> $EXCL; echo "$y" | fixsqh >> $EXFILES ; echo "$y" >> $EXCLUDED; test -e "$mtmp/$y" && rm -f "$mtmp/$y"; }
    done
	shopt -u nullglob
    { test -s "$EXCL" && find $FOLDERS -type d | egrep -vf $EXCL || find $FOLDERS -type d; } > $SFOLDERS
	for y in $(find $mtmp -name ".wh.*"); do
        f="$(echo "$y" | sed -e "s^$mtmp^^g" -e 's^\.wh\.^^g')"
        test -e "$f" && rm "$y";
    done
    unset IFS
    #find $mtmp -name ".wh.*" -exec rm -r {} \;  # ! -name ".wh..*"  routine to delete all .wh. in $mtmp
fi  
# _uid_ or _uid_L
base_cmd=(rsync -aHv "${adtcmd[@]}" --exclude-from=$trsyncexl) && [[ -s "$EXFILES" ]] && base_cmd+=(--exclude-from=$EXFILES)
run_cmd "${base_cmd[@]}" $FOLDERS "$mtmp/" ; errblk "$mtmp"  # merge
# could be new exclusions
# -mindepth 1 so doesnt list $mtmp itself
if [[ "$mrgAEX" = "true" ]]; then
    cd $mtmp || { mount -o remount,udba=none /; exit; }
    while IFS= read -r ex; do 
        [ -n "$ex" ] || continue
        ex="${ex%/}"
		# remove dir excludes
        if [[ "$ex" == */* ]]; then 
            find "$mtmp" -mindepth 1 -path "$mtmp/$ex" -exec rm -rf -- {} +
		# pattern glob
        else 
            find "$mtmp" -mindepth 1 -name "$ex" -exec rm -rf -- {} + 
        fi 
    done < <(cat "$trsyncexl" "$EXFILES") 
fi
brnd $UPDATE
label
}
createlmdl() {
local xsize c  ; local instm="$1"
    if [ "$instm" != "nolmdl" ]; then
        mkdir $mtmp
        if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then astart=$(date +%s.%N); fi
        for mods in "$target$em/"*_uid_L*.xzm; do [[ "$fname" == "" ]] && fname="$mods" ; if ! xzm2dir $mods $mtmp; then errmsg $mtmp "$fname" "$instm" ; fi ; done  # unsquashfs -no-exit -f -dest $mtmp $mods
        aend=$(date +%s.%N)
		if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then elapse=$( awk "BEGIN {print $aend - $astart}"); fi
	    procxzm "true"
    fi
    if [ "$ssbn" == "" ]; then
        if [ "$validrlt" == "false" ]; then cyan "mfile byte match failed generating new serial no." ; else cyan "no msr file. creating new one and new serial." ; fi
		[[ "$namingPRF" = "alpha" ]] && ssbn=$(rand_alpha)$$
        [[ "$namingPRF" = "numeric" ]] && ssbn=$(rand_num)$$
    fi
    if [ "$rlt" == "true" ]; then
        if [ "$validrlt" == "false" ]; then
            c=${fname%.xzm}".bak"
            mv $target$em"/"$fname $target$em"/"$c
        else
            green "Matched.. In link state"
            if [ "$keepLINKEDMRGED" == "false" ]; then
                rm $target$em"/"$fname
            else
                c=${fname%.xzm}".bak"
                mv $target$em"/"$fname $target$em"/"$c
            fi
        fi
    elif [ "$rlt" == "" ] && [ "$instm" != "nolmdl" ]; then
        c=${fname%.xzm}".bak"
        mv "$fname" $c
    fi
    SERIAL=`date +"%m-%d-%y_%R"|tr ':' '_'` ;  rname="${mdlnm}${SERIAL}_uid_L${ssbn}.xzm"
    if [ "$instm" != "nolmdl" ]; then
		cmd=(mksquashfs $mtmp "${target}${em}/${rname}" -comp $cmode -ef $EXFILES -ef $trsyncexl)
        [[ -s "$QEXCL" ]] && cmd+=(-ef "$QEXCL") ; "${cmd[@]}"
        end=$(date +%s.%N)
    else
        newxzm "_uid_L"
    fi
	cd $target$em
    is_rollback $mtmp "_uid_L" $ROLLBCK $ROLLSUMRY $archLMT $is_routine
    xsize=$( du -sb "${target}${em}/${rname}" | cut -f1)
    fname="${mdlnm}${SERIAL}_uid_L${ssbn}.xzm"
    if [ "$rlt" == "true" ]; then
        sed -i "s/bytes:.*/bytes:${xsize}/" $msr
        sed -i "s/file name:.*/file name:${fname}/" $msr
    else
        { echo "bytes:"$xsize ; echo "file name:${fname}" ; echo ; } > $msr
    fi
    rm -rf ${mtmp:?}
}
insertmenu() {
cat > /tmp/block.txt << 'EOF'
LABEL GRAPHICAL changes 
MENU LABEL Graphics changes
KERNEL /boot/syslinux/vmlinuz
INITRD /boot/syslinux/initrd.xz
APPEND
TEXT HELP
    Run Porteus the best way we can.
    Try to autoconfigure graphics
    card and use the maximum allowed
    resolution. If booting from a
    non-posix (FAT/NTFS) drive,
    see the Saving Changes Help
    below for how to save changes.
ENDTEXT
							
EOF

sed -i "38r /tmp/block.txt" $1
rm /tmp/block.txt
} #symlink 
backup() {
#rm $EXCL egrep and rsync exclude rm $exclfiles spare tmp rm $UPDATE This is available as a tmp file rm $EXFILES  # We need to reuse this as its already done
if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then start=$(date +%s.%N); fi
if [ ! -e $target ]; then echo "Target does not exist" && exit 0 ; fi
[[ "$1" != "c" ]] && rlt=$(cat /proc/cmdline | sed -n 's/.*changes=EXIT:\([^ ]*\).*/\1/p')
[[ "$rlt" == *"/dev/"* ]] && rlt=${rlt//dev/mnt}
[[ "$rlt" == *"$target"* ]] && { rlt=${rlt%/} && target=""; }
test -e $target$rlt && osize=$( du -sb "${target}${rlt}${MODULENM}/" | tail -n1 | awk '{print $1}')
mkdir $tmp ; : > /tmp/incfilter.log
if [ "$d2drive" == "false" ]; then
	green "Staging... " ; for x in $IFOLDERS; do cp -arv $ch/"$x" $tmp &> /dev/null ; done
else 
	green "Direct to drive saving" ; for folder in $IFOLDERS; do echo "+ /$folder/" >> /tmp/incfilter.log ; done
	for fld in $EXCLUDE; do if [[ "${fld:0:1}" == "/" ]]; then fld="${fld#/}" ; else fld="*${fld}*" ; fi ; echo "- /$fld/" >> /tmp/incfilter.log ; done
	echo "- /*" >> /tmp/incfilter.log
fi
if [ "$rlt" != "" ]; then
    if [ "$rlt" == "/" ]; then rlt="" ; fi
	if [ "$d2drive" == "true" ]; then dirSRC="$target$rlt/changes" ; else dirSRC=$tmp ; fi
	pst=$PWD ; cd $dirSRC
    if [ -d "${target}${rlt}${MODULENM}.bak/" ]; then
        green "Updating existing backup..."
        if [ "$LOGGING" == "true" ]; then
            if [ -f "${target}${rlt}${MODULENM}.bak.log" ]; then
                m=$(head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -c "STOP")
                if (( m == 0 )); then
                     adtCMD="--log-file=${target}${rlt}${MODULENM}.bak.log"

                    if grep -B 1 'END ORIGINAL FILES' "${target}${rlt}${MODULENM}.bak.log" | tail -2 | head -1 | grep -q '^PAUSED$'; then

                        glog

                    else

                        l=$(head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -c "PAUSED")
                        size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")

                        if [ "$size" -gt $((logSIZE * mbyte)) ]; then
                        
                            if [ "$ANALYTICS" == "true" ]; then
                                cyan "Log file has hit the limit. Clearing..."
                            fi

                            if [ "$logSPRF" == "delete" ]; then

                                if grep -q "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log"; then

                                    glog "true"

                                else
                                    > "${target}${rlt}${MODULENM}.bak.log"
                                fi

                            elif [ "$logSPRF" == "psv" ]; then

                                c=$( wc -l < "${target}${rlt}${MODULENM}.bak.log") # total count
                                q=$(awk "BEGIN {print $c * 0.85}")

                                if (( l == 1 )); then

                                    sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE

                                else

                                    h=$( grep -m 1 -n "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log" | awk -F: '{print $1}') # what line is it on
                                    b=$(( h + 16 ))

                                    if [ "$h" !=  "" ]; then

                                        if [[ $b -le $c ]]; then

                                            if sed -n "$(( h + 16))p" "${target}${rlt}${MODULENM}.bak.log" | grep -q "total size is"; then
                                                sed "${b}q" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE

                                            else
                                                 sed '/END ORIGINAL FILES/q' "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
                                            fi

                                        else

                                            sed '/END ORIGINAL FILES/q' "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
                                        fi

                                        sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" >> $UPDATE

                                    else

                                        sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
                                    fi
                                fi
                                
                                if [ "$ANALYTICS" == "true" ]; then
                                    size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")
                                    
                                    if (( size > logSIZE * mbyte )); then
                                        cyan "Log size limit reached on preserve mode. Please adjust max limit or logging preference."
                                        cyan "This means the file list is greater than the limit or the limit is too small."
                                    fi
                                fi

                                mv $UPDATE "${target}${rlt}${MODULENM}.bak.log"
                            elif [ "$logSPRF" == "stop" ]; then
                                adtCMD=""
                                if [ "$ANALYTICS" == "true" ]; then
                                    cyan "Log file hit max limit not logging..."
                                fi

                                if (( l >= 1 )); then
                                    sed -i '1s/PAUSED/PAUSEDSTOP/g' "${target}${rlt}${MODULENM}.bak.log"
                                else
                                    sed -i '1i STOP' "${target}${rlt}${MODULENM}.bak.log"
                                fi
                            fi
                        fi
                    fi

                    if (( l >= 1 )); then sed -i '0,/PAUSE/ { /PAUSE/ d }' "${target}${rlt}${MODULENM}.bak.log"; fi
                fi

            else
		        nsize=$osize
		        green "There was no logfile generating..." ; > "${target}${rlt}${MODULENM}.bak.log"
				dlog
				echo >> "${target}${rlt}${MODULENM}.bak.log"
				echo "original size(source)=Unkown" >> "${target}${rlt}${MODULENM}.bak.log"
				echo "new size(source)=$nsize" >> "${target}${rlt}${MODULENM}.bak.log"
				echo  "END ORIGINAL FILES $(date +"%m-%d-%y_%R")" >> "${target}${rlt}${MODULENM}.bak.log"
				nLOG="true"
            fi

        else 
        
            if [ -f "${target}${rlt}${MODULENM}.bak.log" ]; then

                if ! grep -B 1 'END ORIGINAL FILES' "${target}${rlt}${MODULENM}.bak.log" | tail -2 | head -1 | grep -q '^PAUSED$'; then

                    if grep -q "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log"; then
               
                        sed -i "/END ORIGINAL FILES/ i\PAUSED" "${target}${rlt}${MODULENM}.bak.log"

                    else 

                        if ! head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -q 'PAUSED'; then
                            if head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -q 'STOP'; then
                                sed -i '1{/STOP/ s/^/PAUSED/}' "${target}${rlt}${MODULENM}.bak.log"
                            else
                                  sed -i '1i PAUSED' "${target}${rlt}${MODULENM}.bak.log"
                            fi
                        fi
                    fi
                fi
            fi
        fi

        if [ "$adtCMD" != "" ]; then

            if [ "$FEEDBACK" != "true" ]; then
               	rsync -aH --delete --filter="merge /tmp/incfilter.log" --exclude '.wh.*'  --delete-excluded --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" $adtCMD
            else
                rsync -aHv --delete --filter="merge /tmp/incfilter.log" --exclude '.wh.*' --delete-excluded --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" | tee -a "${target}${rlt}${MODULENM}.bak.log"
            fi
			exc=$?
		    if [ $exc -eq 1 ]; then
				mount -o remount,udba=none /
				red "rsync failed â€” check log at ${target}${rlt}${MODULENM}.bak.log"
				if [ "$d2drive" == "false" ]; then
					cyan "Files left in memory. Copy and paste the following to rsync again:"
					echo "rsync -aH --delete --filter=merge /tmp/incfilter.log --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/ --log-file=${target}${rlt}${MODULENM}.bak.log"
					if [ "$ANALYTICS" == "true" ]; then
						echo "Then check the logfile for any errors.Then take the last two bytes sent and add it to total count=  at the top of the file if you want to keep exact track."
						echo "Or"
						printf 'rsync -aHv "%s" newdirectory/\tto make a new backup\n' "${target}${rlt}${MODULENM}/"
					fi
				else
		  		    if [ "$ANALYTICS" == "true" ]; then
						echo "Add up the last bytes sent values and add to total count=  at the top of the file before END ORIGINAL FILES.  if you want to keep exact track."
					fi
				fi
				exit 1
			elif [ $exc -eq 24 ]; then
				cyan "Some files have vanished. Check for excluding cache files"
				sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
			fi
        else        
            if [ "$nLOG" != "" ]; then
                if [ "$FEEDBACK" != "true" ]; then
                    rsync -aH --stats --delete --filter="merge /tmp/incfilter.log" --exclude '.wh.*'  --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" > $UPDATE 2>&1  # capture the log in a sentinal
                else
                    rsync -aH --stats --delete --filter="merge /tmp/incfilter.log" --exclude '.wh.*'  --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" 2>&1 | tee $UPDATE
                fi

            else
                if [ "$FEEDBACK" != "true" ]; then
                    rsync -aH --delete --filter="merge /tmp/incfilter.log" --exclude '.wh.*'  --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" > /dev/null
                else
                    rsync -aH --delete --filter="merge /tmp/incfilter.log" --exclude '.wh.*'  --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/"
                fi
            fi
			exc=$?
		    if [ $exc -eq 1 ]; then
				mount -o remount,udba=none /
				red "rsync failed â€” check log at ${target}${rlt}${MODULENM}.bak.log"
				if [ "$nLOG" != "" ]; then
					if [ "$d2drive" == "false" ]; then
						cyan "Files left in memory. Copy and paste the following to rsync again:"
				    	echo "rsync -aH --stats --delete --filter=merge /tmp/incfilter.log --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/ --log-file=${target}${rlt}${MODULENM}.bak.log"
					fi
					if [ "$ANALYTICS" == "true" ]; then
				       echo "Then check the logfile for any errors. Add up all the bytes sent values and put total count=  at the top of the file before END ORIGINAL FILES.  if you want to keep exact track."
				    fi
				else
					echo "rsync -aH --delete --filter=merge /tmp/incfilter.log --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/"
				fi
				echo
				echo "Or failing that"
				printf 'rsync -aHv "%s" newdirectory/\tto make a new backup\n' "${target}${rlt}${MODULENM}/"
				exit 1
		    elif [ $exc -eq 24 ]; then
				cyan "Some files have vanished. Check for excluding cache files"
				sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
			fi
            if [ -s $UPDATE ]; then
                c=$( wc -l < "$UPDATE")
                if (( c > 17)); then sentinal="true"; cp $UPDATE /tmp/parity.txt; fi
                sed -n '/Number of files/,$p' $UPDATE >> "${target}${rlt}${MODULENM}.bak.log"
            fi
        fi
		end=$(date +%s.%N)
        cyan "Changes backup has been updated."

        if [ "$ANALYTICS" == "true" ]; then
            ossize=$( sed -nE 's/.*original size\(source\)=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n 1)
            if [ "$ossize" == "" ]; then
                oput="Unkown"
            else
                oput="$(( ossize / mbyte )) MB"
            fi

            csize=$(du -sb "${target}${rlt}${MODULENM}.bak/" | cut -f1)
            nsize=$osize
            c=$( sed -nE 's/.*total count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n 1)
            c="${c:-0}"
            
            if [ "$adtCMD" != "" ]; then
                z=$( tail -n1 ${target}${rlt}${MODULENM}.bak.log | grep -oP '(?<=sent\s)\d+(?=\s+bytes)' | head -n 1)
				if (( z == 0 )); then z=$(tail -n 20 ${target}${rlt}${MODULENM}.bak.log | grep -oP '(?<=sent\s)[\d,]+' | tail -n 1 | sed 's/,//g'); fi
            elif [ "$adtCMD" == "" ] && [ "$nLOG" == "true" ]; then
                if [ "$ANALYTICS" ==  "true" ]; then
                    green "A new log file has been made."
                fi
                z=$( tail -n2 ${target}${rlt}${MODULENM}.bak.log | head -n1 | grep -oP '(?<=sent\s)[\d,]+' | tr -d ',' )
            fi

            r=$(( c + z ))
            grep -q "total count=" "${target}${rlt}${MODULENM}.bak.log" && sed -i "s/total count=[0-9]\+/total count=$r/" ${target}${rlt}${MODULENM}.bak.log || sed -i "/END ORIGINAL FILES/ i\total count=$r" "${target}${rlt}${MODULENM}.bak.log"

            c=$( sed -nE 's/.*original count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n 1)
            c="${c:-0}"
            if (( c != 0 )); then
                cyan " Since the original backup was first made sent" $(( ( c + z ) / mbyte )) "MB worth of data"
            fi

            if [ "$logSPRF" != "stop" ] && [ "$nLOG" == "true" ]; then
                size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")
                if (( size > logSIZE * mbyte )); then
                red "New log file made is greater than the limit. adjust if needed to keep log data on next backup."
                fi
            fi
            cyan "You have sent $(( r / mbyte )) MB worth of data to the ${target}${rlt}${MODULENM}.bak/ backup"
            green "Sent $(( z / mbyte )) MB to backup. "

            echo
            if  [ "$adtCMD" != "" ] && [ "$nLOG" == "true" ]; then
                cyan "Size of source when backup first made: $oput"
                green "Current size of source: $(( osize / mbyte ))"
            fi

            green "Current size of backup: $(( csize / mbyte )) MB"

            if [ "$nLOG" == "true" ]; then
                echo
                cyan "You saved $(( (nsize - csize) / mbyte )) MB by generating this backup."
            fi
            if [ "$ANALYTICSECT" == "true" ] ; then el=$(awk "BEGIN {print $end - $start}") ; printf "Backup took %.3f seconds.\n" "$el" ; fi
            if [ "$sentinal" == "true" ]; then
                rm $UPDATE
                echo -e "\nYou are seeing this message as you have most likely deleted an entire directory on the source."
                echo "rsyan will not remove a non empty directory on the backup that is empty on the source for safety reasons."
                echo " check parity.txt in /tmp to see what these directories are and delete them in the backup."
            fi
        fi
    else

		if [ "$ANALYTICS" == "true" ]; then start=$(date +%s.%N); fi
		mkdir ${target}${rlt}${MODULENM}.bak
		if [ -f "${target}${rlt}${MODULENM}.bak.log" ]; then
			glog "true"
		else
			dlog
			if [ "$LOGGING" == "true" ]; then
				echo "original size(source)=$osize" >> "${target}${rlt}${MODULENM}.bak.log"
				echo "END ORIGINAL FILES" >> "${target}${rlt}${MODULENM}.bak.log"
        	fi
		fi
		if [ "$LOGGING" == "false" ]; then
			test -f "${target}${rlt}${MODULENM}.bak.log" && rm "${target}${rlt}${MODULENM}.bak.log"
		fi
        cyan "Creating new backup this may take a few minutes."

        if [ "$FEEDBACK" != "true" ]; then
            rsync -aH --stats --filter="merge /tmp/incfilter.log" --exclude '.wh.*'  --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" >> "${target}${rlt}${MODULENM}.bak.log" 2>&1
        else
            rsync -aHv --stats --filter="merge /tmp/incfilter.log" --exclude '.wh.*'  --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" | tee -a "${target}${rlt}${MODULENM}.bak.log"
        fi
		exc=$?
		if [ $exc -eq 1 ]; then
		    mount -o remount,udba=none /
		    red "rsync failed â€” check log at ${target}${rlt}${MODULENM}.bak.log"
		    cyan "Please check the logfile if its a valid backup or try again."
		    cyan "failing that delete the backup and try again."
		    rm -rf $tmp
		    exit 1
		elif [ $exc -eq 24 ]; then
			cyan "Some files have vanished. Check for excluding cache files"
			sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
		fi
		end=$(date +%s.%N)
        cyan "Your changes backup has been created! in ${target}${rlt}/"
        cyan "${MODULENM}.bak/"

        if [ "$ANALYTICS" == "true" ]; then
			if [ "$ANALYTICSECT" == "true" ] ; then el=$(awk "BEGIN {print $end - $start}") ; printf "Backup took %.3f seconds.\n" "$el" ; echo ; fi
            csize=$( du -sb "${target}${rlt}${MODULENM}.bak/" | cut -f1)
            tsize=$(( osize - csize ))
            z=$( grep "Total bytes sent:" "${target}${rlt}${MODULENM}.bak.log" | tail -n 1 | sed -E 's/[^0-9]*([0-9,]+).*/\1/' | tr -d ',')	            
            sed -i "/END ORIGINAL FILES/ i\total count=$z" "${target}${rlt}${MODULENM}.bak.log" #insert the total byte count
            green "You have sent $(( z / mbyte )) MB worth of data so far to the ${target}${rlt}${MODULENM}.bak/ backup"
            cyan "You saved $(( tsize / mbyte )) MB by creating this backup"
        fi
        echo
    fi
	cd $pst
fi
test -e $EXCLUDED && rm $EXCLUDED ; rm -rf $tmp
}
cleanup() {
if [[ "$1" != "6" ]]; then
	# Remount aufs with 'udba=none' flag:
	mount -o remount,udba=none /
	test -e $EXCL && rm $EXCL # parsing rsync
	#test -e $EXFILES && rm $EXFILES # commit script rsync exclusion list
	test -e $SFILES && rm $SFILES
	#test -e $SFOLDERS && rm $SFOLDERS
	test -e $EXCLUDED && rm $EXCLUDED
	test -e /tmp/incfilter.log && rm /tmp/incfilter.log
fi
#Remove /mnt/live/tmp/changes-exit if called from rc.6 (temporary for legacy initrd where cleanup still has changes=EXIT: routine)
[[ "$1" == "6" ]] && [[ "$2" != "c" ]] && rm /mnt/live/tmp/changes-exit
exit
}
initf() { FOLDERS="$(for x in $(grep ^/ $CHNEXIT_CONF | sed s/.//); do test -e $ch/"$x" && echo "$x"; done)" ; dycmb ; exldir $EXFILES ; }
savex() {
msr=${target}${em}"/lscheck"
cyan "Syncing what's left in buffers" && sync
if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then start=$(date +%s.%N); fi
mount -o remount,udba=notify /
if [ "$d2drive" == "false" ] || { [ "$d2drive" == "true" ] && [ "$d2dmdl" == "false" ]; } ; then
    #mkdir $tmp
    green "Staging... "
else
    green "Direct to drive saving on d2dmdl"
    if [ -z "$mdldvc" ]; then xtgt="$thetgt" ; else xtgt="$mdldvc" ; fi
    test -d $xtgt/mtmp && mtmp=$xtgt/mtmp$$ || mtmp=$xtgt/mtmp
fi
SERIAL=`date +"%m-%d-%y_%R"|tr ':' '_'`
line=43 ; pth="/boot/syslinux/porteus.cfg" #Bootloader
[[ -n "$bootdvc" ]] && thetgt=$bootdvc && [[ -n "$grubln" ]] && { line=$grubln ; pth="/boot/grub/grub.cfg"; } 
[[ -z "$grubln" ]] && rltt=$( sed -n "${line}p" "$thetgt$pth" | grep -oP 'changes=\K[^ ]*') && [[ -n "$rltt" ]] && insertmenu $thetgt$pth
test -e "$thetgt$pth" && rlt=$( sed -n "${line}p" "$thetgt$pth" | grep -oP 'extramod=\K[^ ]*') # Is there an extramod on ln?  ## Notes returns the value grep 'extramod=[^ ]*')
epath=$(printf '%s' "$target$em" | sed 's/[&|]/\\&/g')
if [ "$rlt" != "" ]; then
    if [[ ! "${rlt}" == *$target${em%/}*  ]]; then
        test -d "$target$em" || mkdir -p "$target$em" #Bootloader
	    [[ -n "$grubln" ]] && test -e $thetgt$pth && cp $thetgt$pth $thetgt$pth$$.bak
        sed -i "${line}s|\(extramod=\)\([^ ]*\)|\1${epath};\2|" "$thetgt$pth"
        loadermsg
        IFS=';' read -ra parts <<< "${rlt}"
        unset IFS ; u=""
        for part in "${parts[@]}"; do
            erlt=$( sed -n "${line}p" "$thetgt$pth" | grep -oP 'extramod=\K[^ ]*')
            testfile="${part}/.writetest_$$"
            if touch "$testfile" 2>/dev/null; then
                rm -f "$testfile"
                for file in "${part}"/*_uid_*; do [ -e "$file" ] || continue ; mv "$file" "${target}${em}" ; u="true" ; done
            else
                echo "$part was not writable some previous changes modules with _uid_ could not be moved"
            fi
            if [ "$u" == "true" ]; then
				test -d $part"/archive" && mv $part"/archive" "$target$em" ; test -e $part"/lscheck" && mv $part"/lscheck" "$target$em" ; test -e $part"/mergemodules" && rm $part"/mergemodules"  
                test -e $part"/mergemodulesod" && rm $part"/mergemodulesod" ; test -e $part"/createlmodule" && rm $part"/createmodule" ; test -e $part"/renameLbak" && rm $part"/renameLbak" 
				test -e $part"/renamebak" && rm $part"/renamebak"
            fi
            if [ "$u" == "true" ] && [ -d "$part" ] && [ -z "$(ls -A "$part")" ]; then
                erlt="${erlt//;$part/}"
                erlt="${erlt//$part;/}"
                erlt="${erlt//$part/}"
                erlt=$(printf '%s' "$erlt" | sed 's/[&|]/\\&/g')   #escape | and also & which may appear in a directory so doesnt break sed
                sed -i "s|\(extramod=\)[^ ]*|\1${erlt}|" "$thetgt$pth"
                cyan "bootloader updated"
            fi
        done
        if [ "$u" != "" ]; then green "all previous changes modules in other extramod directories moved to new extramod dir" ; fi
    fi
else
    cmd="sed -i \"0,/APPEND/ s|\\(APPEND\\)|\\1 extramod=${epath}|\" \"$thetgt$pth\""
    if [ -n "$grubln" ]; then test -e $thetgt$pth && cp $thetgt$pth $thetgt$pth$$.bak ; cmd="sed -i \"${line}s|\\\$| extramod=$epath/|\" \"$thetgt$pth\"" ; fi
    test -e "$thetgt$pth" && bash -c "$cmd" || echo "Using other bootloader append ${target}${em} to it with extramod="
fi # END Bootloader
if [ -s "${target}${em}${MODULENM}${SERIAL}_uid_$$.xzm" ]; then
    echo ; echo A changes .xzm was detected but nothing was done. ; cyan "${MODULENM}${SERIAL}_uid_$$.xzm already exists" && { sleep 5; exit 0; }
else
    test -d "$target$em" || mkdir "$target$em"
    touch "$target$em/._test1" 2>/dev/null
    cyan "testing filesystem on ${target} for posix compatibility"
    ln -s "$target$em"/._test1 "$target$em"/._test2 2>/dev/null && chmod +x "$target$em"/._test1 2>/dev/null && [ -x "$target$em"/._test1 ] && chmod -x "$target$em"/._test1 2>/dev/null && [ ! -x "$target$em"/._test1 ] && rm -f "$target$em"/._test1 "$target$em"/._test2
	res=$?
    if [ "$res" -ne 0 ]; then
        mount -o remount,udba=none /
        rm -f "$target$em"/._test1 "$target$em"/._test2
	    echo && echo -e "[1;33m""A Windows filesystem (FAT, NTFS) or other non-posix compatible filesystem\nhas been detected on $target.\nYour changes cannot be saved directly to the specified storage media with this\nsetup. Please use the '[1;36mPorteus save file manager[1;33m' to create a .dat container\nand use it for saving your changes after your next reboot.""[0m"
        exit
    fi
    r=$(find "$target$em" -maxdepth 1 -type f -name '*_uid_*.xzm' | wc -l)
    if [ "$r" -eq 0 ]; then # if this is the first time running and there isnt a symlink to the merge script create it
        if [ ! -e "$target$em"/mergemodules ]; then ln -s /usr/local/save-changesnew/mergemodules.sh "$target$em"/mergemodules; fi
		if [ ! -e "$target$em"/mergemodulesod ]; then ln -s /usr/local/save-changesnew/mergemodulesod.sh "$target$em"/mergemodulesod; fi
	    if [ ! -e "$target$em"/createlmodule ]; then ln -s /usr/local/save-changesnew/createlmdl.sh "$target$em"/createlmodule; fi
        if [ ! -e "$target$em"/renamebak ]; then ln -s /usr/local/save-changesnew/renamebak "$target$em"/renamebak; fi
        if [ ! -e "$target$em"/renameLbak ]; then ln -s /usr/local/save-changesnew/renameLbak "$target$em"/renameLbak; fi
    fi
    pst=$PWD
    if [ "$linkedSTATE" == "true" ]; then
        f=$(find "$target$em" -maxdepth 1 -type f -name '*_uid_L*.xzm' | wc -l)
        if [ "$f" -gt 1 ]; then
            echo "Cannot have more than one _uid_L\.\*\.xzm file" && exit 0
        elif [ "$f" -eq 1 ]; then
            rlt=""
            if [ -e $msr ]; then
                content=$(awk -v RS= '{gsub(/\n+$/, "", $0); print $0}' "$msr")
                k=$( echo "$content" | sed -n 's/.*bytes:[[:space:]]*\([0-9]\+\).*/\1/p')
                if [ "$k" != "" ]; then
                    p=$( echo "$content" | sed -n 's/^file name:[[:space:]]*\(.*\)/\1/p')
                    if [ "$p" != "" ]; then
                        if [ -f $target$em"/"$p ]; then
                            c=$( du -sb "${target}${em}/${p}" | cut -f1)
                            if [ "$c" -eq "$k" ]; then
                                ssbn=$( echo $p | sed -n 's/.*_uid_L\(.*\)\.xzm$/\1/p')
                                if [ "$ssbn" == "" ]; then cyan "failed to parse ssbn in msr"; fi
                            else
                                validrlt="false"
                            fi
                            fname=$p ; rlt="true"
                        fi
                    fi
                fi
                if [ "$rlt" == "true" ]; then
                    createlmdl "msr"
                else
                    cyan "Bad msr file. making new serial no. the previous one will be renamed to .bak" ; createlmdl "badmsr"
                fi
            else
                createlmdl "nomsr"
            fi
            cd $pst
        elif [ "$f" -eq 0 ]; then
            createlmdl "nolmdl"
        fi
    else # End linked
		cd $target$em
		[[ "$namingPRF" == "numeric" ]] && rname="${mdlnm}${SERIAL}_uid_$(rand_num)$$.xzm"
		[[ "$namingPRF" == "alpha" ]] && rname="${mdlnm}${SERIAL}_uid_$(rand_alphauid)$$.xzm" 
		newxzm "uid"
    fi
	if [ "$goahead" == "true" ]; then  # dont display the time if error
		if [ -s "${target}${em}/${rname}" ]; then
			chown $USR "${target}${em}/$rname"
     		if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then 
			    el=$(awk "BEGIN {print $end - $start}")
			    tt=$el
				qtn=0
                [[ -n "$elapse" ]] && qtn=$elapse
                smp=$el

                #[[ -n "$elapse" ]] && qtn=${elapse/.} ; smp=${el/.} # fails on octal > 7 use awk
                
			    if awk "BEGIN {exit !($qtn != 0 && $qtn < $smp)}"; then
				    #el=$(awk "BEGIN {print $el - $elapse}")  better to show the times than the difference
	                if [ "$dirtybit" !=  "true" ]; then
	                    mtd="Extract time"
	                else
	                    mtd="Time to merge"
	                fi
	                printf "Total save time %.3f seconds. ( %s %.3f )\n" "$el" "$mtd" "$elapse"
                elif (( qtn == 0 )); then
                    printf "Total save time %.3f seconds.\n" "$el"
                fi
		    fi
			cyan "Your changes have been saved. in ${target}${em}/" ; cyan $rname
			if [ "$mdlMRGPRF" == "back" ] && [ "$mrgMODULES" == "true" ] && [ "$linkedSTATE" == "false" ]; then
				cd $target$em ;  r=$(find . -maxdepth 1 -type f -name '*_uid_*.xzm' ! -name '*_uid_L*' | wc -l)
				if (( r > mdllmt)); then
				    green "Merging changes modules..." ; sleep 5
				    /usr/local/save-changesnew/mergemodules.sh $keepMRGED $ROLLBCK $ROLLSUMRY $archLMT
			        rel=$?
				    if [ "$rel" -ne 0 ]; then
			            if [ "$rel" -eq 1 ]; then
			                red "There was problem auto merging. see $elog" ; cyan "Everything preserved."
			            else
			                echo "mergemodules.sh err: $rel"
			            fi
	                else
	                    cyan "Modules merged."
	                fi
				fi
			fi
		fi
	fi
	cd $pst
fi
mount -o remount,udba=none /
test -e $oMF && rm $oMF
test -e $QEXCL && rm $QEXCL
test -e $EXCL && rm $EXCL
#test -e $EXFILES && rm $EXFILES
test -e $UPDATE && rm $UPDATE
test -e $SFILES && rm $SFILES
# test -e $SFOLDERS && rm $SFOLDERS
test -d $tmp && rm -rf ${tmp:?}
test -d $mtmp && rm -rf ${mtmp:?}
[[ -z "$sts" ]] && sleep 5
exit
}
pl() { for x in $FOLDERS; do find "$ch/$x" -type f -printf '%P\0' | while IFS= read -r -d '' f; do printf '%s/%s\0' "$x" "$f" ; done ; done > "$SFILES" ; }
rand_alpha() { letters=( {A..Z} {a..z} ); echo -n "${letters[RANDOM % 52]}${letters[RANDOM % 52]}" ; }
rand_alphauid() { 
letters=( {A..Z} {a..z} ) ; u=( {A..Z} ) ; t=( {a..z} ) 
while :; do v1=${letters[RANDOM % 52]} ; [[ "$v1" != "L" ]] && break ; done
v2=${letters[RANDOM % 52]} ; (( RANDOM % 2 )) && v3=${u[RANDOM % 26]} || v3=${t[RANDOM % 26]} ; echo -n "$v1$v2$v3"
}
rand_num() { printf "%02d" $((RANDOM % 100)) ; }
# rand_numuid() { echo -n $((RANDOM % 10)) ; }
loadermsg() { green "Updated bootloader in /syslinux/"; cyan "if you use a different loader use cheatcode extramod=${target}${em} include changes modules" ; }
# Fix folder names and make `egrep' interpret wildcards
fixdir() { sed -e 's_\._\\._g' -e 's_?_._g' -e 's_*_.*_g' -e 's@..@^@'; }
# Fix EXCL to work with mksquashfs and rsync exclusion file
fixsqh() {  sed -e 's|^/||' -e 's/^\^//' ; } # change note remove leading ^ and / if present
# Fix whiteout names so `egrep' doesn't interpret special characters as regex
#fixwh() { sed -e '/^\^/!s@^@^@' -e 's_\\_\\\\_g' -e 's_\._\\._g' -e 's_?_\\?_g' -e 's_+_\\+_g' -e 's_*_\\*_g' -e 's_\$_\\$_g' -e 's_\[_\\[_g'  -e 's_]_\\]_g' -e 's_(_\\(_g' -e 's_)_\\)_g' -e 's_{_\\{_g' -e 's_}_\\}_g' -e 's_|_\\|_g' -e 's_\&_\\&_g' -e 's_\(^.\)\^\(.*\)_\1\\^\2_'; } # escape \ infilenames  ] { } |
fixwh() { sed -e '/^\^/!s@^@^@' -e 's_\._\\._g' -e 's_?_\\?_g' -e 's_+_\\+_g' -e 's_*_\\*_g' -e 's_\$_\\$_g' -e 's_\[_\\[_g' -e 's_(_\\(_g' -e 's_\&_\\&_g' -e 's_\(^.\)\^\(.*\)_\1\\^\2_'; } # Translating
# Fix regarding ^^ doesnt break egrep but wont match a pattern  ^/thisdir/^myfile or ^/thisdir/my^file
#fixwh() { sed -e 's_\._\\._g' -e 's_?_\\?_g' -e 's_+_\\+_g' -e 's_*_\\*_g' -e 's_\$_\\$_g' -e 's_\[_\\[_g' -e 's_(_\\(_g'  -e 's_\&_\\&_g' -e 's@^@^@'; } Original
unfixwh() { sed -e 's/\\//g' -e 's/\(^.\)\^\(.*\)/\1^\2/' ; }
#fixexcl() {  sed -e 's|\^||g' -e 's| |\\ |g' -e 's|]|\\]|g' -e 's|)|\\)|g'; } Original
fixcmp() { sed -e 's_|_\\|_g' -e 's_ _\\ _g' -e 's_\._\\\._g' -e 's_\]_\\]_g' -e 's_\[_\\[_g' -e 's_(_\\(_g' -e 's_)_\\)_g' ; } # -e 's_\/_\\\/_g' cache clear script
fixOT() { sed -e 's_?_\\?_g'  -e 's_\^_\\^_g' -e 's_+_\\+_g' -e 's_*_\\*_g' -e 's_\$_\\$_g'  -e 's_\&_\\&_g' ; }

#clog() { tmpdir=$(mktemp -d) && mount -o loop "$1" "$tmpdir" && find "$tmpdir" -type f -printf '%P\n' >> "$2" && umount "$tmpdir" && rmdir "$tmpdir" ; } # print contents of new .xzm
