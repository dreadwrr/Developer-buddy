#!/bin/bash
#inotify db3 					12/31/2025
. /usr/local/save-changesnew/rntchangesfunctions
#atmp=/tmp/myfld$$
#tmp_input="/tmp/inotify_input_$$.tmp"
ch="/mnt/live/memory/changes"
BRAND=`date +"MDY_%m-%d-%y-TIME_%R"|tr ':' '_'`
# fmt="%Y-%m-%d %H:%M:%S"
log_file=$1
LCLMODULENAME="$2"
CACHE_F="$3"
time="$6"
checkSUM="$4"
xMODE="$5"
match_found=0
dpaths=()

#> /tmp/output
# echo "$BRAND inoftiy started" >> /tmp/inotify.log


F=(
	'bin' 
	'etc'
	'home'
	'lib' 
	'lib64' 
	'opt' 
	'root' 
	'sbin' 
	'tmp'
	'usr' 
	'var'
	'tmp'
)



cd $ch || exit
for w in "${F[@]}"; do
    if [[ -d "$w" ]]; then
        dpaths+=( "$w" )
    fi
done
sbwr # see /usr/local/save-changesnew/rntchangesfunctions
timeout "$time" inotifywait -m -r -e create -e moved_to --format '/%w%f%0' "${dpaths[@]}" | while read -r -d '' o; do
    # log_date=$(date +"$fmt")
    #  echo "$log_date processing $o" >> /tmp/inotify.log
    if [[ -d "$o" ]]; then
        # echo "$(date +"$fmt") Directory created: $o" >> /tmp/inotify.log
		# incase the file is created at the same time ie scripts or a process. however during testing -r captures it
		#find "$o" -cmin -5 -not -type d -printf '%T@ %A@ %C@ %i %n %s %u %g %m %p\0' |
		#while IFS= read -r -d '' record; do
		#	if [[ "$o" =~ \.(tmp|swp|bak|part|crdownload|partial|lock)$ ]]; then continue ; fi  
		#	echo "$log_date found new file in dir $o" >> /tmp/inotify.log
		#	sblk "$record" "$log_file" "/dev/null" "$checkSUM" "$xMODE" "$CACHE_F"
		#done
        continue
    
    elif [[ -f "$o" && "$o" != *.part ]]; then 
        # echo "$log_date found checking for matches $o" >> /tmp/inotify.log
        # if [[ "$o" =~ \.(tmp|swp|bak|part|crdownload|partial|lock)$ ]]; then continue ; fi  original

		if [[ "$o" == *.* ]]; then
			ext="${o##*.}"
			ext="${ext,,}"
			if [[ "$ext" =~ ^(tmp|swp|bak|part|crdownload|partial|lock)$ ]]; then
				continue
			fi
		fi

        match_found=0
        for item in "${webb[@]}"; do
            if [[ "$o" =~ $item ]]; then
                match_found=1
                break
            fi
        done

        if (( match_found == 0 )); then
		    # echo "$log_date matched $o" >> /tmp/inotify.log
		    { stat --printf="%Y %X %Z %i %h %s %U %G %a %n" "$o" 2>/dev/null; printf '\0'; } |
		    while IFS= read -r -d '' record; do
		        [[ -z "$record" ]] && continue
		        sblk "$record" "$log_file" "/dev/null" "$checkSUM" "$xMODE" "$CACHE_F"
		    done
        fi
    fi
done
test -e $log_file && rm $log_file
# original drafting
#RS=$'\x1E'  # | sed "s/$/$RS/"  seperator   , then decode # file="${o//$RS/$'\n'}" 
# { stat --format="%Y %X %Z %i %h %s %U %G %a %n" "$o" 2>/dev/null; printf '\0'; } | sblk /dev/stdin "$log_file" "/dev/null" $checkSUM $xMODE $CACHE_F  original appends \n before \0
# { stat --printf="%Y %X %Z %i %h %s %U %G %a %n" "$o" 2>/dev/null ; printf '\0;' } | sblk /dev/stdin "$log_file" "/dev/null" $checkSUM $xMODE $CACHE_F
#dpaths+=("/var") # downloads can be in 
# collect some directories
#while IFS= read -r d; do dpaths+=("$d") ; done < <(find /tmp -type d )
#"${dpaths[@]}"

# alternative,  limit scope to avoid max_user_watches limit
#while IFS= read -r d; do dpaths+=("$d") ; done < <(find /var -maxdepth 5 -type d ) #

# find /var -maxdepth 1 -type l   find symlinks
# find /mnt/live/memory/changes -type d | wc -l   count how many directories are in changes

# downloads can be in /tmp , /var   /var/slapt-get    /var/cache    etc
# if it is another distro we dont want changes **


