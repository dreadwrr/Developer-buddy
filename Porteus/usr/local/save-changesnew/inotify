#!/usr/bin/env bash
#inotify db3 					01/13/2025
. /usr/local/save-changesnew/rntchangesfunctions

# inotify to watching either / or /mnt/live/memory/changes. filters out some files and also browser suppressions in sbwr array
# Also filters out app inclusions in inotifyexl array
# purpose to prepare hashed files that are downloads from a package manager or are copied files that have preserved
# metadata where ctime is greater than mtime. This is because they would not show up in a regular file search.
#
# end result bypassing, one of two loops, the ctime loop. Any files over 1MB are cached and are picked up
# by recentchangessearch app and then stored in ctimecache.gpg.

# inclusions from app. also .wh. files that can appear from watchingn changes. possibly want to filter out other files ie share/Trash
inotifyexl() {
inclusion=(
	'.*/\.wh\.([^/]*)$'
	".*/Downloads/${LCLMODULENAME}x"
	"/tmp/${LCLMODULENAME}x"
	"/tmp/${LCLMODULENAME}_MDY_[^/]*/${LCLMODULENAME}x.+$"
)
}

#VARS
#atmp=/tmp/myfld$$
ch="/mnt/live/memory/changes"
fmt="%Y-%m-%d %H:%M:%S"
BRAND=`date +"MDY_%m-%d-%y-TIME_%R"|tr ':' '_'`

log_file=$1
LCLMODULENAME="$2"
CACHE_F="$3"
checkSUM="$4"
updatehlinks="$5"
xMODE="$6"
time="$7"
match_found=0
dpaths=()

debug_file=/tmp/inotify.log
pblk_log_file=/tmp/output
:> $CACHE_F ; :> $pblk_log_file

echo "$BRAND inoftiy started" >> $debug_file


F=(
	'bin' 
	'etc'
	'home'
	'lib' 
	'lib64' 
	'opt' 
	'root' 
	'sbin' 
	'tmp'
	'usr' 
	'var'
)


pst=$PWD
ch="${ch%/}"
[[ -d $ch ]] && { cd $ch && abpath="$ch/" || exit ; } || { [[ ! -d $ch ]] && cd "/" && abpath="/" || exit ; }
cd $pst || exit

for w in "${F[@]}"; do
    if [[ -d "$abpath$w" ]]; then
        dpaths+=( "$abpath$w" )
    fi
done

sbwr
inotifyexl

#changed to -e moved_to from -e move  . moved_to can miss some kernel optimizations can miss a copy with preserved metadata
timeout "$time" inotifywait -m -r -e create -e moved_to --format '%e|%w%f%0' "${dpaths[@]}" | while read -r -d '' o; do

    debug_log="true"
    debug_file=/tmp/inotify.log
    pblk_log_file=/tmp/output

    [[ "$debug_log" = "true" ]] && log_date=$(date +"$fmt")
    event=${o%%|*}
    o=${o#*|}
    
	if [[ $abpath != "/" ]]; then o="${o#$ch}" ; fi

    log_lineout $debug_log $debug_file "$log_date" "File event: $event file: $o"

    if [[ -d "$o" ]]; then
        log_lineout $debug_log $debug_file "$log_date" "Directory created: $o"

         #incase the file is created at the same time ie scripts or a process and could be missed by intoify. however during testing -r captures it
		#find "$o" -cmin -5 -not -type d -printf '%T@ %A@ %C@ %i %M %n %s %u %g %m %p\0' |
		#while IFS= read -r -d '' record; do
		#	if [[ "$o" =~ \.(tmp|swp|bak|part|crdownload|partial|lock)$ ]]; then continue ; fi  
		#	echo "$log_date found new file in dir $o" >> /tmp/inotify.log
		#	sblk "$record" "$log_file" "/dev/null" "$checkSUM" "$xMODE" "$CACHE_F"
		#done
        continue
    
    elif [[ -f "$o" ]]; then 
        log_lineout $debug_log $debug_file "$log_date" "inotify found checking for matches $o"

        # if [[ "$o" =~ \.(tmp|swp|bak|part|crdownload|partial|lock)$ ]]; then continue ; fi  original
		if [[ "$o" == *.* ]]; then
			ext="${o##*.}"
			ext="${ext,,}"
			if [[ "$ext" =~ ^(tmp|swp|bak|part|crdownload|partial|lock)$ ]]; then
				continue
			fi
		fi
        
        match_found=0
        for item in "${webb[@]}"; do
            if [[ "$o" =~ $item ]]; then
                match_found=1
                break
            fi
        done

		if (( match_found == 0 )); then
			for item in "${inclusion[@]}"; do
				if [[ "$o" =~ $item ]]; then
					match_found=1
					break
				fi
			done
		fi

        if (( match_found == 0 )); then
            log_lineout $debug_log $debug_file "$log_date" "notify matched input to pblk $o"
            
            # Notes: stat --printf="%y %x %z %i %A %h %s %U %G %a %n" "$o"  # alternative doesnt print microsecond**
            # y 2026-01-14 00:48:20.527855839
            # have to parse with date -d "2026-01-14 00:48:20.527855839" +%s.%N 2>/dev/null

		    { find "$o" -printf "%T@ %A@ %C@ %i %M %n %s %u %g %m %p\0" 2>/dev/null; } |
		    while IFS= read -r -d '' record; do
		        [[ -z "$record" ]] && continue
		        pblk "$record" "$log_file" "/dev/null" $checkSUM $xMODE "$CACHE_F" $debug_log "$pblk_log_file"
		    done

        else
            log_lineout $debug_log $debug_file "$log_date" "inotify found excluded by matching skipped. for $o"
        fi
     else
        log_lineout $debug_log $debug_file "$log_date" "inotify file not found or parsing error. for $o"
    fi
done
test -e $log_file && rm $log_file
# original drafting
#RS=$'\x1E'  # | sed "s/$/$RS/"  seperator   , then decode # file="${o//$RS/$'\n'}" 
# { stat --format="%Y %X %Z %i %h %s %U %G %a %n" "$o" 2>/dev/null; printf '\0'; } | sblk /dev/stdin "$log_file" "/dev/null" $checkSUM $xMODE $CACHE_F  original appends \n before \0
# { stat --printf="%Y %X %Z %i %h %s %U %G %a %n" "$o" 2>/dev/null ; printf '\0;' } | sblk /dev/stdin "$log_file" "/dev/null" $checkSUM $xMODE $CACHE_F
#dpaths+=("/var") # downloads can be in 
# collect some directories
#while IFS= read -r d; do dpaths+=("$d") ; done < <(find /tmp -type d )
#"${dpaths[@]}"

# alternative,  limit scope to avoid max_user_watches limit
#while IFS= read -r d; do dpaths+=("$d") ; done < <(find /var -maxdepth 5 -type d ) #

# find /var -maxdepth 1 -type l   find symlinks
# find /mnt/live/memory/changes -type d | wc -l   count how many directories are in changes

# downloads can be in /tmp , /var   /var/slapt-get    /var/cache    etc
# if it is another distro we dont want changes **
