#!/bin/bash
#   Developer buddy 3.0 core                                               12/31/2025

# Filter terminal or supress browser. common items to exclude from prompt      .  regex  notes: ([^/]*)$  
sbwr() {
webb=(
    'mozilla'
	'\.mozilla'
	'chromium-ungoogled'
    ".*/Downloads/${LCLMODULENAME}x"
	"/tmp/${LCLMODULENAME}x"
	'.*/\.wh\.([^/]*)$'
# other
)
}


get_colors(){
txtyellow=${txtbld}$(tput setaf 3)
txtblue=${txtbld}$(tput setaf 4)
function yellow() { echo -e $txtyellow "$1" $rst; }
function blue(){ echo $txtblue "$1" $rst; }
}
postop() {
local -A ref_lines
local filepath size_kb stbool sym onr mtyp chgtime found_rout
local action copy cam
local f y dt at sz
local invr="$3"
local flsrh="$4"
# take the search data then  filter it if its a filtered search. stat the file report if its active. no need to grab other stats as have all necessary data. if for some reason the file disapears still have original
# data.
if [ "$POSTOP" == "true" ]; then
	#while IFS= read -r x; do printf '%s\0' "$x"; done < $1 > $atmpxdata original
	cp $1 $atmp$xdata
	if [ -n "$invr" ] && [ -n "$flsrh" ]; then
		if [ "$flsrh" == "true" ] || [ "$invr" == "filtered" ]; then
			if ! { [ "$flsrh" == "true" ] && [ "$invr" == "filtered" ]; } ; then /usr/local/save-changesnew/filter $atmp$xdata $USR ; fi
		fi
	fi
    if [ -f $USRDIR/doctrine.tsv ]; then
        /usr/local/save-changesnew/updateconfig.sh $2 "POSTOP" "true"  # change POSTOP in /usr/local/bin/recentchanges to false. script was added for python tk  # sed -i 's/^export POSTOP="true"/export POSTOP="false"/' $2  original
        
    else

		# check in rout if it was a copy
		if [ -s "$rout" ]; then
			while IFS= read -r line || [ -n "$line" ]; do
				key="${line#*,*,*,}"
				[[ -n "$key" ]] && ref_lines["$key"]="$line"
			done < $rout
			rm $rout
		else
			echo "rout doesnt exist"
		fi
	
		#pull from sortcomplete for prestated data
        echo -e "Datetime\tFile\tSize(kb)\tType\tSymlink\tChange_time\tcam\tAccessed\tOwner\tStatable\tCopy" > $atmp/doctrine
        while IFS= read -r x || [ -n "$x" ]; do
			mtyp="Unknown"
		    stbool=""
			copy=""
		    size_kb=0
			read -r f1 f2 f3 f4 f5 _ f7 f8 _ f10 f11 f12 _ _ f15 _  <<< "$x"
			[[ -z "$f15" ]] && continue
			dt="$f1 $f2"
			f="$f3"	
			y="${f#\"}"  # remove leading quote
	 		f="${y%\"}"  # remove trailing
			filepath="$(ap_dec "$f")"
			chgtime="$f4 $f5"
			at="$f7 $f8"
			if [ "$f10" -ge 0 ] 2>/dev/null; then size_kb=$(( f10 / 1024 )); fi
			sym=$f11
			onr=$f12
			cam=$f15
            if [ -f "$filepath" ]; then
                # if [ -L "$filepath" ]; then sym="y"; fi
				sz=$(stat --format="%s" "$filepath" 2>/dev/null)
			    if [ -n "$sz" ]; then
					stbool="y"
				    size_kb=$((sz / 1024 ))
		            mtyp=$( file --brief --mime-type "$filepath")
		            if [ "$mtyp" == "application/octet-stream" ]; then mtyp="Unknown"; fi
			    fi
				y="$( ap_filedec "$f")"
				found_rout="${ref_lines[$y]}"
				if [ -n "$found_rout" ]; then
					IFS=',' read -r action _ <<< "$found_rout"
					if [ -n "$action" ] && [ "$action" == "Copy" ]; then
						copy="y"
					fi
				fi
                echo -e "$dt\t$y\t$size_kb\t$mtyp\t$sym\t$chgtime\t$cam\t$at\t$onr\t$stbool\t$copy" >> $atmp/doctrine
            fi
        done < $atmp$xdata
        unset IFS
        head -1 $atmp/doctrine > $USRDIR/doctrine.tsv
        tail -n +2 $atmp/doctrine | sort -t$'\t' -k3,3n -k9,9 >> $USRDIR/doctrine.tsv
        green "File doctrine.tsv created in $USRDIR"
        #column -t -s $'\t' $USRDIR/doctrine.tsv      this command prints a nice tab seperated log
    fi
fi
}
stmp() {
sf=$MODULENAME"_"$FLBRAND
if (( tmpSRHS > 0 )); then #store it in tmp
    test -d /tmp/rc || mkdir /tmp/rc
	r=$(find /tmp/rc -maxdepth 1 -type f -name '*rntfiles_MDY*' 2>/dev/null | wc -l)
    if [ "$r" -eq "$tmpSRHS" ]; then #Clear last file
        test -f /tmp/rc/full || { touch /tmp/rc/full ; cyan "searches builtup in /tmp/rc"; }
        for file in "/tmp/rc"$MODULENAME"_MDY"*
        do
            rm -f $file
            break
        done
    fi
	awk 'NF' $1 > $TMPCOMPLETE; mv $TMPCOMPLETE $1
    cp $1 "/tmp/rc"$sf
fi
}
filterhits() {
local lt=$atmp/patterns.txt
local fl=/usr/local/save-changesnew/filter
test -f $2 || echo "Entry,Hits" >> $2
sed -n '/^[[:space:]]*#/!s|sed -i '\''/\(.*\)/d'\''.*|\1|p' "$fl" > $lt
while IFS= read -r pattern; do
    k=$( echo "$pattern" | sed -e 's/\\//g' -e "s|'\"\${2}\"'|$USR|g") #convert for grep
    x=$( grep -Fc -- "$k" $1) # search matches from logs
    if grep -Fq "sed -i '/$pattern/d" $2; then
        if (( x > 0 )); then
            y=$( grep -F "sed -i '/$pattern/d" $2 | cut -d',' -f2)
            b=$(( y + x ))
            lno=$(grep -Fn "sed -i '/$pattern/d" "$2" | cut -d: -f1)
            sed -i "${lno}s/,[0-9]\+\$/,$b/" $2
        fi
    else
        line=$(grep -F "sed -i '/$pattern/d" "$fl" | grep -v '^[[:space:]]*#')
        if [ "$line" != "" ]; then
            echo "\"$line\",$x" >> $2
        fi
    fi
done < $lt
unset IFS
rm $lt
}
generatekey() {
	# 5.1 porteus   GPG 2.x+ generate key but if 5.01 has GPG2 do it too
	if which gpg2 > /dev/null 2>&1 || gpg --version | grep -q "(GnuPG) 2"; then #gpg --full-generate-key
		read -sp "Enter passphrase for new GPG key: " p
cat > /tmp/keyparams.conf <<EOF
%echo Generating a GPG key
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
Name-Real: John e
Name-Email: $email
Expire-Date: 0
Passphrase: $p
%commit
%echo done
EOF
		if which gpg2 > /dev/null 2>&1; then
			gpg2 --batch --pinentry-mode loopback --passphrase "$p" --generate-key /tmp/keyparams.conf
		else
			gpg --batch --pinentry-mode loopback --passphrase "$p" --generate-key /tmp/keyparams.conf
		fi
		shred -u /tmp/keyparams.conf
		echo "GPG key generated for ${email}."
	else
		if grep -iq "Porteus 5.01" /etc/os-release; then
			if which expect > /dev/null 2>&1; then # is expect installed?
				echo "expect needs to be installed. And run the keygen file for 5.01. Remember to remove passphrase after from file."
			else
				echo "Please run the keygen file for 5.01. Then erase the passphrase you entered in the file from the file."
			fi
		fi
		return 1
	fi
}
storeenc() {
shopt -s expand_aliases
local c t ft ct odt oct cFILE filepath
local -A ref_map=()
if [ "$STATPST" == "true" ]; then
	if which gpg2 > /dev/null 2>&1; then
		if ! gpg2 --list-keys | grep -q $email; then
			generatekey
		fi
	else
		if ! gpg --list-keys | grep -q $email; then
			generatekey
		fi
	fi
	if grep -m 1 -q '^Modified,' $1; then  msg=" stats"; else msg=" log"; fi
	if [ -s "$2" ]; then
		ag="true"
		if [ "$3" != "dcr" ]; then
			xdata=$atmp$workdir$xdata
			if ! decrypt $xdata $2; then
				if [ "$ag" == "false" ]; then
					echo "Agent not installed for gpg 1.4 skipping... ${msg}"
				else
					echo "Failed to decrypt ${2}${msg}"
				fi
				return 1
			fi
			source=$xdata
		else
			source=$xdata3
		fi
		if [ "$msg" == " stats" ]; then
			while IFS= read -r line || [ -n "$line" ]; do
				key=${line#*,*,*,}
				[[ -n "$key" ]] && ref_map["$key"]="$line"
			done < $source
         while IFS="" read -r p || [ -n "$p" ]; do
			ft=$(echo "$p" | cut -d',' -f1)
			dt=$(echo "$p" | cut -d',' -f2 | tr -d '"')
			if [ "$ft" == "Nosuchfile" ]; then #  sed 's/^ *//;s/ *$//')  remove leading trailing space
				echo "$p" >> $source
			else
				ct=$(echo "$p" | cut -d',' -f3 | tr -d '"')
				filepath=${p#*,*,*,} # format action,"date time","change time", file name 
				if [[ ! -v ref_map["$filepath"] ]]; then
	                echo "$p" >> $source
				else
				 	found="${ref_map["$filepath"]}"
					old_dt=$(echo "$found" | cut -d',' -f2 | tr -d '"')
					old_ct=$(echo "$found" | cut -d',' -f3 | tr -d '"')
					if [[ "$dt" > "$old_dt" ]] || [[ "$ct" > "$old_ct" ]]; then
						echo "$p" >> $source
					fi
				fi
			fi
         done < $1
			unset IFS
		else # its a log
		    c=$( grep -c '^$' $source)
		    if  (( c == logCT )); then
		        sed -i '1,/^$/d' $source
		    fi
			while IFS= read -r line; do
				read -r f1 f2 f3 f4 f5 _ <<< "$line"
				[[ -n "$f5" ]] || continue
				cFILE="$f3"				
				odt="$f1 $f2"
				oct="$f4 $f5"
				key="$odt $cFILE $oct"
				ref_map["$key"]=1
			done < "$source"
			while IFS= read -r p || [[ -n "$p" ]]; do
				read -r f1 f2 f3 f4 f5 _  <<< "$p"
				cFILE="$f3"
				dt="$f1 $f2"
				ct="$f4 $f5"
				key="$dt $cFILE $ct"
				if [[ -z "${ref_map[$key]}" ]]; then echo "$p" >> "$source" ; ref_map["$key"]=1 ; fi		
				# r=$( grep -F "$dt \"$y\" $ct" $source)  # moved to use assoc array same as stat
				# [[ -z "$r" ]] &&  echo "$p" >> $source
			done < $1
			unset IFS
		    echo >> $source # end of log
		fi
		t=(--encrypt -r $email -o $2 $source)
		if which gpg2 > /dev/null 2>&1; then 
			cmmd=(gpg2 --yes) # 5.01 with 2.0
		else
			cmmd=(gpg --yes) # 5.1 with gpg2 or 5.01 with gpg 1.4.23 and gpg agent 2.1.11
		fi
		[[ "$nc" == "true" ]] && cmmd+=(--compress-level 0)
		cmmd+=("${t[@]}")
		if ! "${cmmd[@]}"; then
			echo "Encryption failed for file: $source  . $2$msg "
			return 1
		fi
		if [ "$4" != "true" ]; then rm $source ; fi #shred -u $source
		if [ "$msg" == " log" ]; then echo $c; fi

	else # no file create file
		echo >> $1
		if which gpg2 > /dev/null 2>&1; then # 5.01 with 2.0
			if ! gpg2 --yes -e -r $email -o $2 "$1"; then #encrypt
				 echo "Encryption failed for file: $1"
				 return 1
			fi
		else # 5.1 or 5.01 with 1.4.23
			if ! gpg --yes -e -r $email -o $2 "$1"; then #encrypt
				 echo "Encryption failed for file: $1"
				 return 1
			fi
		fi
		echo "The${msg} was created."
	fi
fi
}
decrypt() {
if grep -iq "Porteus 5.01" /etc/os-release && ! which gpg2 > /dev/null 2>&1; then # GnuPG 1.4.23
    if which gpg-agent > /dev/null 2>&1; then
	    export GPG_TTY=$(tty)            # If you cant get it to work try commenting these two out and the other two in recentchanges might fix it
        export GPG_AGENT_INFO=/root/.gnupg/S.gpg-agent:0:1
	    if ! gpg --yes -d -o $1 $2; then
		    return 1
	    fi
    else
        ag="false"
        return 1
    fi
else # all version with  GPG 2.0
	if which gpg2 > /dev/null 2>&1; then # porteus 5.01 with v2
		if ! gpg2 --yes -d -o $1 $2; then
    		return 1
		fi
	else # porteus 5.1 with v2
		if ! gpg --yes -d -o $1 $2; then
    		return 1
		fi
	fi
fi
}
iscopy() {
local r y
while IFS= read -r p; do
    read -r f1 f2 f3 f4 f5 f6 f7 f8 f9 _ <<< "$p"
	[[ -z "$f9" ]] && continue
    dt="$f1 $f2" ; cFILE="$f3" ; ct="$f4 $f5"
    in="$f6" ; at="$f7 $f8" ; chksum="$f9"
	while IFS= read -r line; do
		read -r _ _ _ _ _ of6 of7 of8 _<<< "$line"
		[[ -z "$of8" ]] && continue
		oin="$of6" ; oat="$of7 $of8"
		if [ "$in" -ge 0 ] 2>/dev/null && [ "$oin" -ge 0 ] 2>/dev/null; then
			if (( in != oin )); then
				if is_valid_date "$at" && is_valid_date "$oat"; then 
					r="${cFILE#\"}"
					cFILE="${r%\"}"
				    y="$( ap_filedec "$cFILE")"
					echo "Copy $dt $ct $y" >> "$rout"
					break
				fi
			fi
		fi
	done < <(grep -E "[[:space:]]$chksum[[:space:]]" "$1")
done < "$2"
}
collision() {
local filepath="$1"		;	local label="$2"
local chksum="$3"		;	local filesize="$4"
local recordfile recordc recordsize 
local tmp y
while IFS= read -r line; do
	tmp="${line#*\"}"
	y="${tmp%\"*}"
    read -r _ _ _ _ _ _ _ _ recordc recordsize _ <<< "$line"
	[[ -z "$recordsize" ]] && continue
    if [[ "$y" != "$filepath" && "$recordc" != "None" && "$recordsize" != "None" ]]; then
		if [ "$recordsize" -ge 0 ] 2>/dev/null; then
	        if [[ "$chksum" == "$recordc" && "$filesize" != "$recordsize" && "$recordsize" -ne 0 ]]; then
                recordfile="$( ap_filedec "$y")"
			    collisions+=("COLLISION: $label vs $recordfile | Checksum: ${chksum} && ${recordc} | Sizes: $filesize != $recordsize")
                csm="true"
		    fi
		fi
    fi
done < <(grep -E "[[:space:]]$chksum[[:space:]]" "$ofile")
}
is_valid_date() { date -d "$1" >/dev/null 2>&1 ; c=$?; return $c ; }
newmeta() {
local current_own="$1"		;	local current_grp="$2"
local current_perm="$3"	;	local prev_own="$4"
local prev_grp="$5"			;	local prev_perm="$6"
old_meta="$prev_own $prev_grp $prev_perm"
cur_meta="$current_own $current_grp $current_perm"
if [[ "$old_meta" == "$cur_meta" ]]; then
	return 1
fi
}
stealth() {
local file="$1"		;	local label="$2"	
local cksum="$3"	;	local current_size="$4"
local original_size="$5"	
local delta abs_delta
if [ "$current_size" -ge 0 ] 2>/dev/null && [ "$original_size" -ge 0 ] 2>/dev/null; then
	delta=$(( current_size - original_size ))
	abs_delta=${delta#-}
	if [ "$original_size" == "$current_size" ]; then
		echo "Warning file ${label} same filesize different checksum. Contents changed." >> $cerr
	elif [ "$abs_delta" -le 12  ] && [ "$abs_delta" -ne 0 ]; then
		msg="Checksum indicates a change in ${label}. Size changed slightly — possible stealth edit."
		if [ "$cdiag" == "true" ]; then
			 echo "$msg ($original_size → $current_size)." >> $slog
		else
			 echo "$msg" >> $scr
		fi
	fi
	if [ "$cdiag" == "true" ]; then 
        collision "$file" "$label" $cksum $current_size
    fi
fi
}
hablk() {
local cam_file tmp afrm label
local m n y
csm="false"
:> $TMPCOMPLETE
while IFS= read -r p || [[ -n "$p" ]]; do
    cam_file="false"
	found_line=""
	tmp="${p#*\"}"
	y="${tmp%\"*}"
	read -r f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 _ f12 f13 f14 f15 _ _ f18 _ <<< "$p"  # skip symlink lmt and finally hardlinks if enabled
	in="$f6"
	if [ -n "$in" ] && [ "$in" -ge 0 ] 2>/dev/null; then 	
		if [ "$1" == "A" ]; then found_line="${ref_map[$y]}" ; else found_line=$( grep -F "\"$y\"" "$ofile" | tail -n 1) ; fi  # for line in "${ref_lines[@]}"; do if [[ "$line" == *"$y"* ]]; then found_line="$line" ; fi ; done regular array old multicore using grep*
		if [ -n "$found_line" ]; then
			original_ln="$found_line"
			read -r of1 of2 _ _ _ of6 of7 of8 of9 of10 _ of12 of13 of14 of15 _ _ of18 _ <<< "$original_ln"  # skip filename changetime symlink lmt and finally hardlinks if enabled
			cFILE="$( ap_dec "$y")"
            label="$( ap_filedec "$y")"
            oat="$of7 $of8" ; cat="$f7 $f8"
            if ! (is_valid_date "$oat" && is_valid_date "$cat"); then 
                continue
            fi
			dt="$f1 $f2" ; omt="$of1 $of2" ; ct="$f4 $f5"
			if [ "$checkSUM" == "true" ]; then
				if [ ! -f "$cFILE" ]; then
					echo "Deleted $dt $dt $label" >> $rout
                    continue
				fi
                ocs="$of9" ; cs="$f9" ; os="$of10" ; csze="$f10" ; ocam="$of15" ; cam="$f15"
                [[ "$cs" != "None" && "$ocs" != "None" ]] || continue
                usec="$f18" ; ousec="$of18"
                if [ -z "$usec" ] || [ -z "$ousec" ]; then  # ensure full entries
                    continue
                fi
            else
                ocam="$of9" ; cam="$f9"
            fi
			oin="$of6"
			if [ -n "$oin" ] && [ "$oin" -ge 0 ] 2>/dev/null; then
                is_valid_date "$dt" && is_valid_date "$omt" || continue
                if [ "$cam" == "y" ] || [ "$ocam" == "y" ]; then
                    cam_file="true"
                fi
				if [ "$dt" == "$omt" ]; then
					if [ "$checkSUM" == "true" ]; then
                        if [ "$usec" != "None" ]; then
                            n=${usec%%.*}
                            if [ "$n" -ge 0 ] 2>/dev/null; then
                            echo "Unusual modified time file has microsecond all zero: $label. at mtime $usec" >> $slog
                            fi
                        fi
					    # read a_mod i fs au ag apmr < <(stat --format="%Y %i %s %U %G %a" "$cFILE" 2>/dev/null)
                        read a_mod fs < <(stat --format="%Y %s" "$cFILE" 2>/dev/null)
					    afrm=$(date -d "@$a_mod" +"$fmt" 2>/dev/null)
                        if [ -n "$afrm" ]; then
                            if [ "$afrm" == "$dt" ]; then
                                if [ "$cs" != "$ocs" ] && [ "$cam_file" == "false" ]; then
                                    echo "Suspect $dt $ct $label" >> $rout
                                    echo "Suspect file: $label previous checksum ${ocs} currently ${cs}.changed without a new modified time." >> $cerr
                                fi
                                if (( oin == in )); then
                                    if newmeta $f12 $f13 $f14 $of12 $of13 $of14; then
                                        echo "Metadata $dt $ct $label" >> $rout
                                        echo "Permissions of file: $label changed $of12 $of13 $of14 → $f12 $f13 $f14" >> $slog
                                    fi
                                fi
                            else
								if [ "$cam_file" == "false" ]; then
	                                m="File changed during the search."
	                                if [ "$cdiag" == "true" ]; then
		                                echo "$m $label at ${afrm} initially ${dt}. Size was $os, now $fs." >> $slog
	                                else
		                                echo "$m $label. File likely changed. system cache item." >> $slog
	                                fi
                                    #a_checksum=$(md5sum "$cFILE" 2> /dev/null | awk '{print $1}')
                                    #if [ -n "$a_checksum" ] && [ "$a_checksum" != "$ocs" ]; then
                                    #	stealth "$cFILE" "$label" $a_checksum $fs $csze
                                    #fi
                                    #if [ "$i" -ge 0 ] 2>/dev/null; then
                                    #	if [ "$i" == "$oin" ]; then
                                    #        if newmeta $au $ag $apmr $of12 $of13 $of14; then
                                    #            echo "Metadata $dt $ct $label" >> $rout
                                    #            echo "Permissions of file: $label changed $of12 $of13 $of14 → $au $ag $apmr" >> $slog
                                    #        fi
                                    #	fi
                                    #fi
							    fi
                            fi
                        else
                            echo "Deleted $dt $dt $label" >> $rout
                        fi
					fi        
				else
					if [ "$checkSUM" == "true" ]; then
						if (( oin != in )); then
							if [ "$ocs" == "$cs" ]; then
								echo "Overwrite $dt $ct $label" >> $rout
							else
								echo "Replaced $dt $ct $label" >> $rout
								stealth "$y" "$label" $cs $csze $os
							fi
						else
							if [ "$ocs" != "$cs" ]; then
								echo "Modified $dt $ct $label" >> $rout
								stealth "$y" "$label" $cs $csze $os
							else
								if newmeta $f12 $f13 $f14 $of12 $of13 $of14; then
									echo "Metadata $dt $ct $label" >> $rout
									echo "Permissions of file: $label changed $of12 $of13 $of14 → $f12 $f13 $f14" >> $slog
                                fi
                                if [ "$cam_file" == "false" ]; then
                                   echo "Touched $dt $ct $label" >> $rout
                                fi
							fi
						fi
					else
						if (( oin != in )); then
							echo "Replaced $dt $ct $label" >> $rout
						else
                            if [ "$cam_file" == "false" ]; then
							    echo "Modified $dt $ct $label" >> $rout
                            fi
						fi
					fi
				fi
			fi
		else
            if [ "$checkSUM" == "true" ]; then
			    echo "$p" >> $2  # is copy?
            fi
		fi
	fi
done < $SORTCOMPLETE
(( ${#collisions[@]} )) && for entry in "${collisions[@]}"; do echo "$entry" >> "$cerr" ; done
}
hanly(){
local y=8
declare -a collisions=()
x=$(wc -l < "$SORTCOMPLETE")
if [ "$mMODE" == "mc" ] && (( x > 100 )); then
	workfld=$workdir
	y=$(( (x + max_jobs - 1) / max_jobs )) 
	split -l $y --numeric-suffixes=1 --suffix-length=4 "$SORTCOMPLETE" "$atmp/sortchunk_"
	find "$atmp" -type f -name 'sortchunk_*' -print0 | xargs -0 -P"$max_jobs" -I{} /usr/local/save-changesnew/haloop $atmp$workfld "{}" $2 $checkSUM $cdiag  # sort -z
	isoutput haloop1* haloop2* haloop3* haloop4* $rout $slog $cerr $TMPCOMPLETE
else
	cores=""
    # mapfile -t ref_lines < "$2" old array 
	declare -A ref_map  # key="$(cut -d' ' -f3 <<< "$p")"                     
	while read -r p; do key="$(perl -nE 'say $1 if /"((?:[^"\\]|\\.)*)"/' <<< "$p")" ; ref_map["$key"]="$p" ; done < $2
	hablk "A" $TMPCOMPLETE
fi
# check for copies
test -s $TMPCOMPLETE && iscopy $2 $TMPCOMPLETE
rm $2  # remove the copy of log pst used in hanly
processha "$@"
}
is_excluded() {
local file="$1"
local flgchk="false"
for item in "${webb[@]}"; do if [[ "$file" =~ $item ]]; then flgchk="true" ; break ; fi ; done
[[ "$flgchk" = "true" ]] && echo "$flgchk"
}
is_suppressed() {
    local ck=""
    [[ "$flg" == "true" ]] && return 0
    [[ "$supbrwr" == "true" ]] && ck=$( is_excluded "$file")
    [[ -n "$ck" ]]
}
filteroutput() {
local filtername="$2"
local critical="$3"
local pricolor="$4"
local seccolor="$5"
local col="COLLISION:"
local type="$6"
local flg="false"
sbwr
while IFS= read -r file; do 
	if [[ "$file" == "$filtername"* ]]; then
        ! is_suppressed && "$pricolor" "$file $type"
	else
		if [[ "$critical" != "no" ]]; then
            if [[ "$file" == "$critical"* ]] || [[ "$file" == "$col"* ]]; then 
                "$seccolor" "$file $type Critical" ; flg="true"
            fi
        elif [[ "$critical" == "no" ]]; then
           ! is_suppressed && "$seccolor" "$file $type"
        fi
	fi
done < $1
[[ "$flg" == "true" ]] && return 1 || return 0
}
processha() {
local action filepath 
local ts1 ts2 y
local invr="$3"
[[ -z "$invr" ]] && invr="$1"
if [ -s $rout ]; then
	#sed -E 's/^(([^[:space:]]+[[:space:]]+){3})([^[:space:]]+[[:space:]]+){2}(.*)/\1\4/' "$rout" | grep -v -E "^(Deleted|Nosuchfile)" > $tfile       original
	# same as above but can also decode 
	:> $TMPCOMPLETE
    while IFS=' ' read -r action ts1 ts2 _ _ filepath; do
		[[ "$action" == *"Deleted"* || "$action" == *"Nosuchfile"* ]] && continue
		# y="$( ap_filedec "$filepath")"
		echo "$action $ts1 $ts2 $filepath" >> $TMPCOMPLETE
    done < $rout
	mv $TMPCOMPLETE $tfile3
	unset IFS
    { echo ; echo "Hybrid analysis" ; echo ; } >> "$difffile"

	sort -u -o $tfile3 $tfile3
	if [ -s $ABSENT ]; then sort -u -o $ABSENT $ABSENT; comm -23 $tfile3 $ABSENT > $TMPCOMPLETE ; else sort -k2,2 -k3,3 -o $TMPCOMPLETE $tfile3 ; fi

	if [ "$flsrh" == "true" ] || [ "$invr" == "filtered" ]; then
		if ! { [ "$flsrh" == "true" ] && [ "$invr" == "filtered" ]; } ; then /usr/local/save-changesnew/filter $TMPCOMPLETE $USR ; fi
	fi
	if [ "$flsrh" == "true" ]; then
		cDATE=$( head -n1 $TMPOPT | awk '{print $1 " " $2}')
		awk -v tme="$cDATE" '$0 >= tme' "$TMPCOMPLETE" > $TMPOUTPUT
		cp $TMPOUTPUT $TMPCOMPLETE
	fi
	awk '{printf "%-9s\t%-19s %s\n", $1, $2" "$3, substr($0, index($0,$4))}' "$TMPCOMPLETE" >> "$difffile"

	get_colors
	if [ -s "/tmp/cerr" ]; then 
        if [ "$supbrwr" == "true" ]; then
            sbwr
			grep -E "^(Suspect|COLLISION)" /tmp/cerr > $TMPCOMPLETE
            for item in "${webb[@]}"; do sed -i "\|$item|d" /tmp/cerr ; done
            [[ -s $TMPCOMPLETE ]] && { csum="true" ; cat $TMPCOMPLETE ; } >> /tmp/cerr
            sort -u -o /tmp/cerr /tmp/cerr 
        fi
		if ! filteroutput "/tmp/cerr" "Warning" "Suspect" "yellow" "red" "elevated"; then
			csum="true"
		fi
	fi
	if [ -n "$cores" ] && [ "$csum" == "false" ]; then echo "Detected $cores CPU cores."; fi
fi
}
suffix() {
    suffixes=(
        "xSystemDiffFromLastSearch"
        "xFltDiffFromLastSearch"
        "xFltchanges"
        "xFltTmp"
        "xSystemchanges"
        "xSystemTmp"
        "xNewerThan"
        "xDiffFromLast"
    )
}
inclusions() {
# local results=${LCLMODULENAME:0:3}
local c=$SORTCOMPLETE
sed -i '/\/usr\/local\/save-changesnew\/flth\.csv/d' $c  # sed -i '/\/tmp/\/rnt/d' $2
sed -i '/\/home\/'"${USR}"'\/Downloads\/'"${LCLMODULENAME}x"'/d' $c
for var in logpst statpst pydbpst; do gp="${!var}" ; sed -i "\|$gp|d" $c ; done
}
clearlogs() {
suffix
for suffix in "${suffixes[@]}"; do rm -f "${MODULENAME/#\//}$suffix"* 2>/dev/null ; done
}
logic() {
if [ "$syschg" == "false" ]; then  cyan "No sys files to report." ; fi
if [ "$samerlt" == "true" ] && [ "$syschg" == "true" ] && [ "$nodiff" == "true" ]; then cyan "The sys search was the same as before." ; fi
if [ "$diffrlt" == "false" ] && [ "$nodiff" == "true" ];then green " Nothing in the sys diff file. That is the results themselves are true" ; [[ -n "$1" ]] & cyan "$1" ; fi
}
display() {
local locale=$1
if [ "$dspEDITOR" != "false" ]; then
	[[ "$dspEDITOR" = "xed" ]] && test -e /usr/bin/xed && xed $locale"$2" 
	[[ "$dspEDITOR" = "xed" ]] && ! test -e /usr/bin/xed && echo $dspEDITOR not installed 
	[[ "$dspEDITOR" = "featherpad" ]] && test -e /usr/bin/featherpad && featherpad $locale"$2" 
  	[[ "$dspEDITOR" = "featherpad" ]] && ! test -e /usr/bin/featherpad && echo $dspEDITOR not installed
fi
}
isdiff() {
if [ -s "$1" ]; then
	diffrlt="true"
	CDATE=$( head -n1 $SORTCOMPLETE | awk '{print $1 " " $2}')
    if [ "$flsrh" == "false" ]; then awk -v tme="$CDATE" '$0 >= tme' "$difffile" > $3 ; else cat "${difffile}" > $3; fi
	echo >> "${difffile}"
	while IFS="" read -r p || [ -n "$p" ]; do cFILE="$( echo "$p" | cut -d " " -f3-)" ; dt="$( echo "$p" | cut -d " " -f1,2)" ; grep -Fqs "$cFILE" $2 && echo "Modified" "$p" >> $ABSENT || { echo "Deleted " "$p" >> $ABSENT ;  echo "Deleted" "$dt" "$p" >> $rout ; } ; done < $3
	test -f $ABSENT  && { echo Applicable to your search ; cat $ABSENT ; } >> "$1" || { echo "None of above is applicable to search. It is the previous search"; } >> "$1"
else
    samerlt="true" # test -e "$1" && rm "$1"
fi
}
# find old search for convenience
hsearch() {
r=$(find . -type f -path "*${MODULENAME}_MDY*/*" | wc -l)
if (( r >= 1 )); then
	for folder in $(ls -d /tmp"${MODULENAME}"_MDY* | sort -r); do # most recent folder
		for file in $folder$MODULENAME"xSystemchanges${argone}"*; do
		    test -f $file && { OLDSORTED=$file ; nodiff="true"; break; }
		done
		[[ -n "$OLDSORTED" ]] && break
	done
fi
}
# ascii positional encoding
ap_safeline() {
local o="$1"
# escape input newlines for pasing
o="${o//\\/\\ap5c}" ; o="${o//$'\n'/\\ap0A}" ; printf '%s' "$o"
}
ap_enc() {
local o="$1"
# Escape existing if filename has \ap5c, \ap22, \ap0A . then completly encode
o="${o//\"/\\ap22}" ; o="${o//$'\t'/\\ap09}" ; o="${o//$'\n'/\\ap0A}" ; o="${o// /\\ap20}"  
printf '%s' "$o"
}
# file operations
ap_dec() {
local k="$1"
k="${k//\\ap0A/$'\n'}" ; k="${k//\\ap09/$'\t'}" ; k="${k//\\ap22/\"}" ; k="${k//\\ap5c/\\}" ; k="${k//\\ap20/\ }"
printf '%s' "$k"
}
# final file output
ap_filedec() {
local k="$1"
k="${k//\\ap0A/$'\\n'}" ; k="${k//\\ap09/$'\t'}" ; k="${k//\\ap22/\"}" ; k="${k//\\ap5c/\\}" ; k="${k//\\ap20/\ }"
printf '%s' "$k"
}
escf() {
local o="$1" # original design
o="${o//\\/\\\\}" ; o="${o//$'\n'/\\\\n}"; o="${o//\"/\\\"}"
# o="${o//$/\\\$}"
# o="${o//$'\t'/\\t}" 
printf '%s' "$o"
}
unescf() {
local k="$1"
k="${k//\\\\n/$'\n'}" ; k="${k//\\\"/\"}" ; k="${k//\\\\/\\}" 
#  k="${k//\\\$/\$}"
# k="${k//\\t/$'\t'}" 
printf '%s' "$k"
}
pyerrblk() {
if [ "$ret" -ne 0 ]; then
	if [ "$ret" -eq 2 ] || [ "$ret" -eq 3 ]; then
		echo "Problem with GPG refer to instructions on setting up pinentry ect. Database preserved."
	elif [ "$ret" -eq 4 ]; then
		echo "Problem with database in psysrg.py"
	else
		echo "Pstsrg.py failed. exitcode ${ret}"
	fi
fi
}
backend() { 
ofile=$atmp/tmpinfo ; tfile3=$atmp/tmpd
# mkdir -p "$xopt"
# TMPDIR=$(mktemp -d $xopt/tmpda.XXXXXX)  copy of log pst to seperate dir
if [ -d /tmp/rc ] && [ "$ANALYTICS" == "true" ] && [ "$STATPST" == "false" ]; then
    for file in /tmp/rc/*; do
        cat $file >> $ofile 2> /dev/null
    done
    if [ -s $ofile ]; then
        sort -u -o $ofile $ofile
		hanly $SORTCOMPLETE $ofile $1
		ret=$?
		if [ "$ret" -gt 0 ]; then
			echo "failure in ANALYTICS hanly subprocess"
		fi
    fi
fi
if [ "$STATPST" == "true" ]; then
	if [ "$ANALYTICS" == "false" ]; then
		if [ "$backend" == "default" ]; then
			if [ -s $logpst ]; then
				chmod 700 $atmp$workdir # decypt once perform ha and save
				# ofile=$TMPDIR/tmpinfo
				ofile=$atmp$workdir/tmpinfo
				if decrypt $xdata3 $logpst; then
					awk 'NF' $xdata3 > $ofile
					 if [ -s $ofile ]; then
						#sort -u -o $ofile $ofile
						hanly $SORTCOMPLETE $ofile $1
						ret=$?
						if [ "$ret" -ne 0 ]; then
							echo "failure in STATPST hanyl subprocess"
						fi
					fi
					pstc="true"
				else
					echo "Failed to decrypt log file in hanly for STATPST. log file ${logpst}"
				fi
			else
				pstc="true"
			fi
			if [[ "$pstc" = "true" ]]; then
				imsg="$(storeenc $SORTCOMPLETE $logpst "dcr")"
				ret=$?
				if [ "$ret" -ne 0 ]; then
					echo "$imsg"
				else
					if [ "$imsg" -ge 0 ] 2>/dev/null; then
						if (( imsg % 10 == 0 )); then  cyan "$imsg searches in gpg log"; fi
					elif [ "$imsg" != "" ]; then
						green "Persistent search log file created."
					fi
				fi
				if [ -s $rout ]; then
					if [ -s $COMPLETE ]; then cat $COMPLETE >> $rout; fi
					sort -u -o $rout $rout
					sed -i -E 's/^([^ ]+) ([^ ]+ [^ ]+) ([^ ]+ [^ ]+) (.+)$/\1,"\2","\3",\4/' $rout
					imsg="$(storeenc $rout $statpst "false" $POSTOP)" # decrypt store encrypt
					ret=$?
					if [ "$ret" -ne 0 ]; then
						echo "$imsg"
					else
						if [ "$imsg" != "" ]; then green "Persistent stats file created."; imsg=""; fi
					fi
				fi
			fi
		else
			cores=""
			if ! gpg --list-keys | grep -q $email; then generatekey ; fi	
			python3 /usr/local/save-changesnew/pstsrg.py $SORTCOMPLETE $COMPLETE $pydbpst $rout $checkSUM $cdiag $USR $email $mMODE $ANALYTICSECT $proteusSHIELD $compLVL
			ret=$?
			pyerrblk
			processha $argf
		fi
	fi
fi
[[ -s "$difffile" ]] && [[ -n "$( tail -n 1 "$difffile")" ]] && [[ "$ANALYTICSECT" == "true" ]] && [[ "$backend" == "default" ]] && green "Hybrid analysis on"

if [[ "$csum" != "true" && -s $slog && "$supress" == "false" ]]; then
	filteroutput $slog "Checksum" "no" "blue" "yellow" "Scr"
fi

if [[ "$csum" == "true" ]]; then
	{ echo; echo "cdiag alert"; echo ; grep -v "^Warning File" /tmp/cerr ; } >> "$difffile"
	rm /tmp/cerr
fi

#test -e $TMPDIR && rm -rf "${TMPDIR:?}"
#test -f $rout && rm $rout
test -f $slog && rm $slog
}
strup() { /usr/local/save-changesnew/start_inotify $log_file $LCLMODULENAME $CACHE_F "$checkSUM" "ctime" 3600 ; }
intst() {
local sz
#Init
if [ "$ANALYTICSECT" == "true" ]; then start=$(date +%s.%N); fi
if [[ "$updatehlinks" = "true" && "$backend" != "database" ]]; then updatehlinks="false" ; fi 
if [[ "$mMODE" == "mc" ]]; then
	cores=$( nproc 2>/dev/null || echo 1)
	max_jobs=$(( cores > 16 ? 16 : cores ))
fi	
if [ "$xRC" == "true" ]; then
	if pgrep -af 'save-changesnew/inotify' > /dev/null; then
		if [ -f "$log_file" ]; then
			cp $log_file $tout
			rm $log_file		
		fi		
        if pkill -f 'inotifywait -m -r -e create -e moved_to --format /%w%f%0'; then
            :>$log_file
            strup
        else
			test -e $tout && rm $tout
			test -e $log_file	&& rm $log_file
        fi
	else
		test -e $log_file	&& rm $log_file
		strup	
	fi
else
    if pgrep -af 'save-changesnew/inotify' > /dev/null; then
        pkill -f 'inotifywait -m -r -e create -e moved_to --format /%w%f%0'
        test -e $log_file && rm $log_file
    fi
fi
if [ "$STATPST" == "true" ]; then
    if [ "$backend" != "database" ]; then
        if [ -f $logpst ]; then
            sz=$( stat -c %s "$logpst")
            if [ $(( sz / 1048576 )) -gt $logSIZE ]; then
                if [ "$logPRF" == "del" ]; then
					cyan "$logpst reached size limit of $logSIZE. to resume persistent logging delete file"
					: > $logpst
                elif [ "$logPRF" == "stop" ]; then
                    cyan "persist log saving stopped on size limit"
                fi
                STATPST="false"
                if [ "$logPRF" == "rfh" ]; then
                    rm $logpst
                    STATPST="true"
                fi
		    elif [ $(( sz / 1048576 )) -ge $compLVL ]; then
			    nc="true"
            elif [ $sz -eq 0 ]; then
                STATPST="false"
            fi
        fi
    fi
fi
}
isoutput() {
local y=$#
local i c x files
if (( y >= 7 )); then
	c=4
elif (( y == 4 )); then
	c=2
elif (( y == 2 )); then
	c=1
else
	echo either 2 4 or 8 args
fi
for ((i = 1; i <= c; i++)); do
    files=($atmp$workfld/${!i})
    x=$((i + c))
    if [[ ${#files[@]} -gt 0 ]] && [[ " ${files[*]} " != *"${!i}"* ]]; then
        output="${!x}"
        cat "${files[@]}" >> $output
    fi
done
}
process_sort() {
local filepath cFILE dt r y
[[ "$updatehlinks" = "true" ]] && green "Updating hardlinks"
while IFS= read -r y; do 
	read -r f1 f2 f3 _  <<< "$y"
	dt="$f1 $f2" ; cFILE="$f3"
	r="${cFILE#\"}"
	cFILE="${r%\"}"
	filepath="$( ap_filedec "$cFILE")"
	# filepath="$( escf "$filepath")"
	printf '%s %s\n' "$dt" "$filepath"
done < $1 > $2
}
merge_ctime() {
local y
local tme="$3"
declare -A sort_lines
while IFS= read -r line || [[ -n "$line" ]]; do read -r f1 f2 f3 _ <<< "$line" ; cFILE="$f3" ; sort_lines["$cFILE"]="$line" ; done < $1
while IFS= read -r y; do 
	read -r f1 f2 f3 _  <<< "$y"
	dt="$f1 $f2" ; cFILE="$f3"
	if [[ ! "$dt" < "$tme" ]]; then
		if [[ ! -v sort_lines["$cFILE"] ]]; then
			printf '%s\n' "$y"
		fi
	fi
done < $2 >> $1
}
upt_cache() {
local inode=$1 
local size=$2 
local mtime=$3 
local checksum=$4 
local path="$5"
local cache_file=$6
printf '%s|%s|%s\t%s\t%s\n' "$inode" "$size" "$mtime" "$checksum" "$path" >> "$cache_file"
}
get_cached() {
local inode=$1
local size=$2
local mtime=$3
local key="$inode|$size|$mtime"
grep -m1 "^${key}   " "$CACHE_F" | awk -F $'\t' '{print $2}'
}
# [[:space:]]
# Used for sysprofile as you dont want to cache the checksum
rblk() {
local csum pmn wnr grp fs sl lmt mt
local cFILE ; local y
local fmt="%Y-%m-%d %H:%M:%S"
local sl="None"
local cam="None"

local lmt=""
#usec="None"

cur_line="$( ap_safeline "$1")"
IFS=' ' read -r mtime atime itime i fs onr grp pmr cFILE <<< "$cur_line"
y="$( ap_enc "$cFILE")"
cFILE="$( ap_dec "$cFILE")" 
mt=$(date -d "@${mtime%%.*}" +"$fmt")
ct=$(date -d "@${itime%%.*}" +"$fmt")
if [ -e "$cFILE" ] && [ -f "$cFILE" ]; then
	if [ -n "$mt" ]; then
		if [ "$4" == "true" ]; then
			csum=$(md5sum "$cFILE" 2> /dev/null)
			csum=${csum%% *}
			csum=${csum:-None}
			fs=${fs:-None} 
			[[ -L "$cFILE" ]] && sl="y"
			wnr=${onr:-None} ; grp=${grp:-None} ; pmn=${pmr:-None}
			adtcmd="$csum $fs $sl $wnr $grp $pmn $cam"
		else
	    	adtcmd=""
		fi
        # (( ${itime%%.*} > ${mtime%%.*} )) && { cam="y" ; lmt=$mt ; mt=$ct ; }
		ats=$(date -d "@${atime%%.*}" +"$fmt")			
		ct=${ct:-None None}
		ats=${ats:-None None}
        lmt=${lmt:-None None}
		output="$mt \"$y\" $ct $i $ats $adtcmd"  # $lmt $usec
		printf '%s\n' "$output" >> $2
	fi
else
	[[ -z "$mt" ]] && { crt=$(date +"$fmt") ; mt=$crt; }
	printf "%s %s %s %s\n" "Nosuchfile" "$mt" "$mt" "$y" >> $3
fi
}
# Mainloop do cache files over 1MB.
sblk() {
local fmt="%Y-%m-%d %H:%M:%S"
local frac len mt ct y r
local cam csum pmn wnr grp fs sl lmt usec cFILE
r=""				;	sl=""
lmt=""			;	nlinks=""
cam="None"	;	usec="None"
# log_date="$(date +"$fmt")"
# echo "$log_date sblk line in $cur_line" >> /tmp/output  # debug
cur_line="$( ap_safeline "$1")"
IFS=' ' read -r mtime atime itime i n fs onr grp pmr cFILE <<< "$cur_line"
if { [[ "$5" = "ctime" ]] && (( ${itime%%.*} > ${mtime%%.*} )); } || [[ "$5" = "main" ]]; then
    y="$( ap_enc "$cFILE")" 
    cFILE="$( ap_dec "$cFILE")" 
    mt=$(date -d "@${mtime%%.*}" +"$fmt")
    ct=$(date -d "@${itime%%.*}" +"$fmt")
    if [ -e "$cFILE" ] && [ -f "$cFILE" ]; then
	    if [ -n "$mt" ]; then
		    frac=${mtime#*.}
		    len=${#frac}   
		    if (( len > 0 )); then
			    if [[ "$frac" =~ ^0+$ ]]; then
				    usec=$mtime
			    fi
		    fi
		    #if (( len == 6 )); then
		    #	us=${frac:0:6}   
		    #	if [ "$us" == "000000" ]; then
		    #		usec="y"
		    #	fi
		    #elif (( len == 9 )); then
		    #	us=${frac:0:9}
		    #	if [ "$us" == "000000000" ]; then
		    #		usec="y"
		    #	fi   
		    #fi
		    if [ "$4" == "true" ]; then
			    if (( fs > 1000000 )); then
					[[ -e "$CACHE_F" ]] && r=$(get_cached "$i" "$fs" "$mtime")
                    if [[ -n "$r" ]]; then
                        csum="$r"
                    else
                        csum=$(md5sum "$cFILE" 2>/dev/null)
                        [[ -n "$csum" ]] && csum=${csum%% *} && upt_cache "$i" "$fs" "$mtime" "$csum" "$y" "$6"
                    fi
				else
					csum=$(md5sum "$cFILE" 2>/dev/null)
                    csum=${csum%% *}
			    fi
			    csum=${csum:-None}
			    fs=${fs:-None} 
			    [[ -L "$cFILE" ]] && sl="y" ; sl=${sl:-None}
			    wnr=${onr:-None} ; grp=${grp:-None} ; pmn=${pmr:-None}
                
			    adtcmd="$csum $fs $sl $wnr $grp $pmn"
		    else
	        	adtcmd=""
		    fi
            [[ "$updatehlinks" = "true" ]] && nlinks=$n
			[[ "$5" = "ctime" ]] && { cam="y" ; lmt=$mt ; mt=$ct ; }
		    ats=$(date -d "@${atime%%.*}" +"$fmt")			
		    ct=${ct:-None None}
		    ats=${ats:-None None}
            lmt=${lmt:-None None}
		    output="$mt \"$y\" $ct $i $ats $adtcmd $cam $lmt $usec $nlinks"
		    printf '%s\n' "$output" >> $2
	    fi
    else
	    [[ -z "$mt" ]] && { crt=$(date +"$fmt") ; mt=$crt; }
	    printf "%s %s %s %s\n" "Nosuchfile" "$mt" "$mt" "$y" >> $3
    fi
#else
#    echo "$log_date sblk continued  $1" >> /tmp/output  # debug
fi  
}
# load balance for if there is over 1000 files
search() {
local x p y
x=$(tr -cd '\0' < "$1" | wc -c)
if [[ "$mMODE" = "default" ]] || (( x < 100 )); then
    while IFS= read -r -d '' p ; do 
        [[ -z "$p" ]] && continue
        sblk "$p" $2 $3 $4 $5 $CACHE_F         
    done < $1
	unset IFS
else
    y=$(( (x + max_jobs - 1) / max_jobs ))
    #y=200																					
    xargs -0 -n "$y" -P "$max_jobs" /usr/local/save-changesnew/mainloop $atmp$workfld $4 $5 $6 $updatehlinks $CACHE_F < $1                                            
    if [[ "$5" = "main" ]]; then
        isoutput mainloop1* mainloop2* $2 $3
        isoutput cache1* $CACHE_F
    else
        isoutput mainloop3* mainloop4* $2 $3
        isoutput cache2* $CACHE_F
    fi
fi
}
ctimeloop() {
# what is not in the main search 
sort -z -o $2 $1                
sort -z -o $tout $toutnul
comm -z -23 $tout $2 > $TMPCOMPLETE
if [ -s $TMPCOMPLETE ]; then	
	search $TMPCOMPLETE $tout $COMPLETE $checkSUM "ctime" batch2
fi
}

