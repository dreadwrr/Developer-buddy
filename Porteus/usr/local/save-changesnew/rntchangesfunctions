#!/bin/bash
#   Developer buddy 3.0 core                                               08/11/2025
#   saving in tmp, filter hits, encrypt decrypt and hanly        
postop() {
if [ "$POSTOP" == "true" ]; then 
	while IFS= read -r x; do x="$(unescf "$x")" ; printf '%s\0' "$x"; done < $1 >> $xdata
    if [ -f $USRDIR/doctrine.tsv ]; then 
        sed -i 's/^export POSTOP="true"/export POSTOP="false"/' $2
    else
        echo -e "Datetime\tFile\tSize(kb)\tType\tModified\tAccessed\tOwner" > $atmp/doctrine
        while IFS= read -r -d '' x; do        
            f="$(cut -d' ' -f3- <<< "$x")"
            dt=$(cut -d' ' -f1-2 <<< "$x")
            if [ -e "$f" ] && [ -f "$f" ]; then  
                onr=$( stat -c "%U" "$f")    
                mtyp=$( file --brief --mime-type "$f") 
                if [ "$mtyp" == "application/octet-stream" ]; then mtyp="Unknown"; fi
                if [ -L "$f" ]; then mtyp="Symlink"; fi
                sz=$( stat -c %s "$f")
                md=$( stat -c '%Y' "$f") ; x=$(date -d "@$md" +'%Y-%m-%d %H:%M:%S')
                ae=$( stat -c '%X' "$f") ; y=$(date -d "@$ae" +'%Y-%m-%d %H:%M:%S')
                echo -e "$dt\t$f\t$(( sz / 1024 ))\t$mtyp\t$x\t$y\t$onr" >> $atmp/doctrine
            fi
        done < $xdata
        unset IFS
        head -1 $atmp/doctrine > $USRDIR/doctrine.tsv
        tail -n +2 $atmp/doctrine | sort -t$'\t' -k7,7 -k3,3n >> $USRDIR/doctrine.tsv
        green "File doctrine.tsv created in $USRDIR"
        #column -t -s $'\t' $USRDIR/doctrine.tsv      this command prints a nice tab seperated log
    fi
fi
}  
stmp() {                         
sf=$MODULENAME"_"$FLBRAND
if (( tmpSRHS > 0 )); then #store it in tmp
    test -d /tmp/rc || mkdir /tmp/rc 
	r=$(find /tmp/rc -maxdepth 1 -type f -name '*rntfiles_MDY*' 2>/dev/null | wc -l)
    if [ "$r" -eq "$tmpSRHS" ]; then #Clear last file
        test -f /tmp/rc/full || { touch /tmp/rc/full ; cyan "searches builtup in /tmp/rc"; }
        for file in "/tmp/rc"$MODULENAME"_MDY"*
        do
            rm -f $file
            break
        done
    fi
	awk 'NF' $1 > $TMPCOMPLETE; mv $TMPCOMPLETE $1
    cp $1 "/tmp/rc"$sf
fi
}
filterhits() {
local lt=$atmp/patterns.txt
local fl=/usr/local/save-changesnew/filter
test -f $2 || echo "Entry,Hits" >> $2
sed -n '/^[[:space:]]*#/!s|sed -i '\''/\(.*\)/d'\''.*|\1|p' "$fl" > $lt
while IFS= read -r pattern; do
    k=$( echo "$pattern" | sed -e 's/\\//g' -e "s|'\"\${2}\"'|$USR|g") #convert for grep
    x=$( grep -Fc -- "$k" $1) # search matches from logs
    if grep -Fq "sed -i '/$pattern/d" $2; then
        if (( x > 0 )); then
            y=$( grep -F "sed -i '/$pattern/d" $2 | cut -d',' -f2)    
            b=$(( y + x ))
            lno=$(grep -Fn "sed -i '/$pattern/d" "$2" | cut -d: -f1)
            sed -i "${lno}s/,[0-9]\+\$/,$b/" $2
        fi
    else
        line=$(grep -F "sed -i '/$pattern/d" "$fl" | grep -v '^[[:space:]]*#')
        if [ "$line" != "" ]; then
            echo "\"$line\",$x" >> $2
        fi
    fi
done < $lt
unset IFS
rm $lt
}
generatekey() {
	# 5.1 porteus   GPG 2.x+ generate key but if 5.01 has GPG2 do it too
	if which gpg2 > /dev/null 2>&1 || gpg --version | grep -q "(GnuPG) 2"; then #gpg --full-generate-key
        read -sp "Enter passphrase for new GPG key: " p
cat > /tmp/keyparams.conf <<EOF
%echo Generating a GPG key
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
Name-Real: John e
Name-Email: $email
Expire-Date: 0
Passphrase: $p
%commit
%echo done
EOF
       		if which gpg2 > /dev/null 2>&1; then
        	gpg2 --batch --pinentry-mode loopback --passphrase "$p" --generate-key /tmp/keyparams.conf
        	echo made
        else
        	gpg --batch --pinentry-mode loopback --passphrase "$p" --generate-key /tmp/keyparams.conf
        fi
        shred -u /tmp/keyparams.conf
        echo "GPG key generated for ${email}."	
	else
    	if grep -iq "Porteus 5.01" /etc/os-release; then  
    		if which expect > /dev/null 2>&1; then # is expect installed?
    			echo "expect needs to be installed. And run the keygen file for 5.01. Remember to remove passphrase after from file."
    		else
    			echo "Please run the keygen file for 5.01. Then erase the passphrase you entered in the file from the file."
    		fi
			return 1
		fi
	fi	
}
#create/open and save encrypted log/stats gpg $1 logfile $2 output
storeenc() {
shopt -s expand_aliases
local c
if [ "$STATPST" == "true" ]; then
	if ! gpg --list-keys | grep -q $email; then
		generatekey
	fi
    if grep -m 1 -q '^Modified,' $1; then  msg=" stats"; else msg=" log"; fi 
    if [ -s "$2" ]; then
        ag="true"
		if [ "$3" != "dcr" ]; then
			if ! decrypt $xdata $2; then
				if [ "$ag" == "false" ]; then
                    echo "Agent not installed for gpg 1.4 skipping... ${msg}"
                else
                    echo "Failed to decrypt"  $2$msg
				fi
				return 1
            fi
			source=$xdata
		else
			source=$xdata2
		fi
		if [ "$msg" == " stats" ]; then 
			declare -A ref_map  # Load the database          As we at 300 searches this is far more efficient than grepping the entire file its in assosiative array
			while IFS="" read -r line || [ -n "$line" ]; do
				key=${line#*,*,}
				[[ -n "$key" ]] && ref_map["$key"]="$line"
			done < $source
        	while IFS="" read -r p || [ -n "$p" ]; do
            	ft=$(echo "$p" | cut -d',' -f1)       # Action | tr -d '"')   optional ""                   Modified, Delete  field
				if [ "$ft" == "Nosuchfile" ]; then # We want to keep track of any occurence of this
					filepath=$(echo "$p" | cut -d',' -f3- | sed 's/^ *//;s/ *$//')
					entry="Nosuchfile,,${filepath}"
					echo "$entry" >> $source
				else
                	dt=$(echo "$p" | cut -d',' -f2 | tr -d '"')   	 #  , "date time" 
					filepath=${p#*,*,}  # returns after 2nd ,
					entry="$ft,\"${dt}\",${filepath}"
					if [[ ! -v ref_map["$filepath"] ]]; then
	                	echo "$entry" >> $source
					else
				 		found="${ref_map["$filepath"]}"
						old_dt=$(echo "$found" | cut -d',' -f2 | tr -d '"')
						if [[ "$dt" > "$old_dt" ]]; then
							echo "$entry" >> $source
						fi
					fi
				fi
        	done < $1
        	unset IFS
        else # its a log
            c=$( grep -c '^$' $source)
            if  (( c == logCT )); then 
                sed -i '1,/^$/d' $source 
            fi
            cat $1 >> $source
            echo >> $source # end of log
        fi
		if which gpg2 > /dev/null 2>&1; then # 5.01 with 2.0
		    cmmd=(gpg2 --yes -e -r $email -o $2 $source)
			if [ "$nc" == "true" ]; then cmmd=(gpg2 --yes --compress-level 0 -e -r $email -o $2 $source); fi
        else # 5.1 with gpg2 or 5.01 with gpg 1.4.23 and gpg agent 2.1.11
		    cmmd=(gpg --yes -e -r $email -o $2 $source) # normal usage
			if [ "$nc" == "true" ]; then cmmd=(gpg --yes --compress-level 0 -e -r $email -o $2 $source); fi
        fi
		if ! "${cmmd[@]}"; then  
			echo "Encryption failed for file: $source  . $2$msg "
			return 1
		fi
        rm $source #shred -u $source
        if [ "$msg" == " log" ]; then echo $c; fi
    else # no file create file 
        echo >> $1
		if which gpg2 > /dev/null 2>&1; then # 5.01 with 2.0
            if ! gpg2 --yes -e -r $email -o $2 "$1"; then #encrypt
                echo "Encryption failed for file: $1"
                return 1
            fi   
        else # 5.1 or 5.01 with 1.4.23
            if ! gpg --yes -e -r $email -o $2 "$1"; then #encrypt
                echo "Encryption failed for file: $1"
                return 1
            fi   
        fi
        echo "The${msg} was created."
    fi
fi

}
decrypt() {			
if grep -iq "Porteus 5.01" /etc/os-release && ! which gpg2 > /dev/null 2>&1; then # GnuPG 1.4.23 
    if which gpg-agent > /dev/null 2>&1; then
	    export GPG_TTY=$(tty)            # If you cant get it to work try commenting these two out and the other two in recentchanges might fix it
        export GPG_AGENT_INFO=/root/.gnupg/S.gpg-agent:0:1
	    if ! gpg -d -o $1 $2; then
		    return 1
	    fi	
    else
        ag="false"
        return 1
    fi
else # all version with  GPG 2.0
	if which gpg2 > /dev/null 2>&1; then # porteus 5.01 with v2
		if ! gpg2 -d -o $1 $2; then
    		return 1
		fi
	else # porteus 5.1 with v2
		if ! gpg -d -o $1 $2; then
    		return 1
		fi	
	fi
fi          
}
hanly(){
	local csm=""
	local cores=""
	>$tfile
	if [ "$mMODE" == "mc" ]; then
		cores=$(nproc 2>/dev/null)
		: "${cores:=1}"
		max_jobs=$cores
		if (( max_jobs > 16 )); then max_jobs=16; fi
		split -l 8 "$SORTCOMPLETE" "$atmp/sortchunk_"
		ls "$atmp"/sortchunk_* | xargs -P"$max_jobs" -I{} /usr/local/save-changesnew/haloop "$atmp" "{}" "$2" "$checkSUM"
		if compgen -G $atmp/haloop1_*_tmp.log > /dev/null; then cat "$atmp"/haloop1_*_tmp.log >> $rout; fi
		if compgen -G $atmp/haloop2_*_tmp.log > /dev/null; then cat "$atmp"/haloop2_*_tmp.log >> $tfile; fi
	else
		mapfile -t ref_lines < "$2"
		while IFS= read -r p || [ -n "$p" ]; do
			found_line=""
			cFILE=$(perl -nE 'say $1 if /"((?:[^"\\]|\\.)*)"/' <<< "$p")  
			y="$( escapef "$cFILE")"
			current_ln="${p//\"$y\"/}"
			current_ln="$(echo "$current_ln" | xargs)"
			read -r f1 f2 f3 f4 f5 f6 f7 <<< "$current_ln"
    		in="$f3"
    		if [ -n "$in" ] && [ "$in" -ge 0 ] 2>/dev/null; then
				for line in "${ref_lines[@]}"; do if [[ "$line" == *"\"$y\""* ]]; then found_line="$line" ; fi ; done
				if [ -n "$found_line" ]; then
					sline="$found_line"
					original_ln="${sline//\"$y\"/}"
					original_ln="$(echo "$original_ln" | xargs)" 
					read -r of1 of2 of3 of4 of5 of6 of7 <<< "$original_ln"
					cFILE="$(unescf "$cFILE")"
					oin="$of3"
					if [ -n "$oin" ] && [ "$oin" -ge 0 ] 2>/dev/null; then
						omt="$of1 $of2"
						oat="$of4 $of5" 
						org="$of6"
						t=$(date -d "$oat" +%s 2>/dev/null)   
						dt="$f1 $f2"
						cat="$f4 $f5"
						cs="$f6"
						k=$(date -d "$cat" +%s 2>/dev/null)
						if [ "$dt" == "$omt" ]; then
							if [ "$checkSUM" == "true" ]; then
								if [ -n "$t" ] && [ -n "$k" ]; then
									if [ -n "$org" ] && [ -n "$cs" ] && [ -f "$cFILE" ]; then
										os="$of7"
										csze="$f7"
										if [ -n "$csze" ]; then
											if [ "$org" != "$cs" ]; then
												a_checksum=$(md5sum "$cFILE" | awk '{print $1}') 
												a_mod=$(stat --format=%Y "$cFILE")
												afrm=$(date -d "@$a_mod" +"%Y-%m-%d %H:%M:%S")
												if [ -n "$os" ] && [ -n "$afrm" ]; then
													if [ "$afrm" == "$dt" ]; then
														echo "Csumc $dt $y"| tee -a "$rout" >> "$tfile"| tee -a /tmp/cerr; csm="true"	
													else
														if [ "$a_checksum" != "$cs" ] && [ "$cdiag" == "true" ]; then
															echo "File changed during the search. ${y} at ${afrm}. Size was $os, now $fs. " >> /tmp/scr
														elif [ "$a_checksum" != "$cs" ]; then
															echo "File changed during search ${y}. File likely changed. system cache item." >> /tmp/scr
														fi
													fi	
												fi
											else
												stealth "$cFILE" $os $csze "$y" $cdiag "csum"
											fi
										fi
									fi
								fi
							fi
						else
							if (( oin != in )); then
								if [ "$checkSUM" == "true" ]; then
									if [ -n "$org" ] && [ -n "$cs" ]; then
										if [ "$org" == "$cs" ]; then
											echo "Overwrt $dt $y" | tee -a $rout >> "$tfile"
										else
											os="$of7"
											csze="$f7"
											if [ -n "$t" ] && [ -n "$k" ]; then
												if [ -n "$csze" ]; then stealth "$cFILE" $os $csze "$y" $cdiag ;fi
											fi
											echo "Replaced $dt $y" | tee -a $rout >> "$tfile"
										fi
									fi
								else
									echo "Replaced $dt $y" | tee -a $rout >> "$tfile"
								fi
							else
								if [ "$checkSUM" == "true" ]; then
									if [ -n "$org" ] && [ -n "$cs" ]; then
										if [ "$org" != "$cs" ]; then
											os="$of7"
											csze="$f7"
											if [ -n "$t" ] && [ -n "$k" ]; then
												if [ -n "$csze" ]; then stealth "$cFILE" $os $csze "$y" $cdiag ;fi
											fi
											echo "Modified $dt $y" | tee -a $rout  >> $tfile
										else
											echo "Touched $dt $y" | tee -a $rout >> $tfile
										fi
									fi
								else
									echo "Modified $dt $y" | tee -a $rout >> $tfile
								fi
							fi
						fi	
					fi
				fi
			fi
		done < "$SORTCOMPLETE"
		unset IFS
	fi
	rm $2
    processha
}
processha() {
    if [ -s $rout ]; then
        if [ -s $tfile ]; then
            echo >> "$difffile"
            echo "Hybrid analysis" >> "$difffile"
            echo >> "$difffile"
			sort -o $tfile $tfile
			if [ -s $ABSENT ]; then sort -o $ABSENT $ABSENT; comm -23 $tfile $ABSENT > $TMPCOMPLETE ; else cat $tfile > $TMPCOMPLETE ; fi
			if [ "$flsrh" == "true" ] || [ "$3" == "filtered" ]; then
			     if ! { [ "$flsrh" == "true" ] && [ "$3" == "filtered" ]; } ; then																														    	
				 /usr/local/save-changesnew/filter $TMPCOMPLETE $USR 
			     fi
			fi
			if [ "$flsrh" == "true" ]; then
				cDATE=$( head -n1 $TMPOPT | awk '{print $1 " " $2}')          
				awk -v tme="$cDATE" '$0 >= tme' "$TMPCOMPLETE" > $TMPOUTPUT
				cp $TMPOUTPUT $TMPCOMPLETE
			fi
			awk '{printf "%-10s %-25s %-60s\n", $1, $2" "$3, $4}' $TMPCOMPLETE >> "$difffile"
       		if [ "$csm" != "" ]; then echo "csum"; else [ -n "$cores" ] && echo "$cores"; fi
        fi
	fi
}
search() {
while IFS= read -r -d '' x; do
	adtcmd="" ; output="" ; fs=""
	y="$(escapef "$x")"
	if [ -e "$x" ] && [ -f "$x" ]; then
		stat_out=$(stat -c "%Y %X %i" "$x")
		read -r f atime i <<<"$stat_out"
		mt=$(date -d "@$f" +"%Y-%m-%d %H:%M:%S")
		ats=$(date -d "@$atime" +"%Y-%m-%d %H:%M:%S")
		if [ -n "$mt" ]; then
			if [ "$checkSUM" == "true" ]; then
				csum=$(md5sum "$x")
				csum=${csum%% *}
				fs=$(stat --format=%s "$x") 
				adtcmd="$csum $fs"
			fi	
			output="$mt \"$y\" $i $ats $adtcmd"
			printf '%s\n' "$output" >> $2
		fi
	else
		printf 'NOTA-FI-LE 77:77:77 "%s"\n' "$y" >> $2
		printf 'Nosuchfile,,%s\n' "$y" >> $3
	fi
done < $1
unset IFS
}
searcharr () {
while IFS= read -r -d '' x; do
	adtcmd="" ; output="" ; fs=""
	y="$(escapef "$x")"
	if [ -e "$x" ] && [ -f "$x" ]; then
		stat_out=$(stat -c "%Y %X %i" "$x")
		read -r f atime i <<<"$stat_out"
		mt=$(date -d "@$f" +"%Y-%m-%d %H:%M:%S")
		ats=$(date -d "@$atime" +"%Y-%m-%d %H:%M:%S")
		if [ -n "$mt" ]; then
			if [ "$checkSUM" == "true" ]; then
				csum=$(md5sum "$x")
				csum=${csum%% *}
				fs=$(stat --format=%s "$x") 
				adtcmd="$csum $fs"
			fi
			output="$mt \"$y\" $i $ats $adtcmd"
			if [ "$2" == "ctime" ]; then
				xfile+=("$output")
			else
				ffile+=("$output")
			fi
		fi
	else
		ffile+=("NOTA-FI-LE 77:77:77 \"$y\"")
		nsf+=("Nosuchfile,,$y")
	fi
done < $1
unset IFS
}
clearlogs() { 
    local suffixes=(
        "xSystemDiffFromLastSearch"
        "xFltDiffFromLastSearch"
        "xFltchanges"
        "xFltTmp"
        "xSystemchanges"
        "xSystemTmp"
        "xNewerThan"
        "xDiffFromLast_"
    )
for suffix in "${suffixes[@]}"; do rm -f "${MODULENAME/#\//}$suffix"* 2>/dev/null ; done 
}
escapef() {
local i="$1"
local o
o="${i//$'\n'/\\n}" ; o="${o//\\/\\\\}" ; o="${o//\"/\\\"}" ; o="${o//$/\\\$}"  
printf '%s' "$o"
}
unescf() {
local t="$1"
local k
k="${t//$'\\n'/$'\n'}" ; k="${k//\\\\/\\}" ; k="${k//\\\"/\"}" ; k="${k//\\\$/\$}"
printf '%s' "$k"
}
stealth() {
local file="$1"
local original_size="$2"
local current_size="$3"
local label="$4"  # \n \\n
local diag="$5"
if [ -f "$file" ] && [ "$diag" == "true" ]; then
	local a_mod
	local afrm
	a_mod=$(stat --format=%Y "$file")
	afrm=$(date -d "@$a_mod" +"%Y-%m-%d %H:%M:%S") # UTC 
	if [ -n "$original_size" ] && [ -n "$current_size" ] && [ -n "$afrm" ]; then
		local delta=$(( current_size - original_size ))
		local abs_delta=${delta#-}
		if [ "$abs_delta" -le 3  ] && [ "$abs_delta" -ne 0 ]; then
			echo "Checksum indicates a change in ${label}. Size changed slightly — possible stealth edit. ($original_size → $current_size)." >> /tmp/scr
		elif [ "$abs_delta" -ne 0 ] && [ "$diag" == "csum" ]; then
			echo "File collision ${label}. Same modified date and checksum. Either md5 is too weak or file was edited and matches exact checksum." >> /tmp/cerr
		fi
	fi
fi
}
