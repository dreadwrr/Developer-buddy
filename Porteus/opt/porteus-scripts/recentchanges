#!/bin/bash
#   Analytics NMS5 porteus 
#   recentchanges. Developer buddy      make xzm     08/11/2025  v3.0
#Added compLVL disable compression if over 200mb for up to 50% speed increase
## idea behind v5 is to be able to find anyfile even if its from a package manager and preserves metadata
## switched loops to null terminated to capture every possible file even if file is like file\nhasthis
### cMODE normal regular loop proven reliable, mem use arrays less io or mc multiple cores or parallel more risky but works
### Expanded on hybrid analysis and added checkSUM so can detect if a file changed without modified time and is logged.
### Csumch, Overwrit, Metacng, Replacd, touched, xtimechg and modified
# If STATPST on ANALYTICS is locked out for security as you dont want to save in /tmp if logpst srg
#   Provide ease of pattern finding ie what files to block we can do this a number of ways
#   1) if a file was there (many as in more than a few) and another search lists them as deleted its either a sys file or not but unwanted nontheless
#   2) Is a system file inherent to the specifc platform
#   3) intangibles ie trashed items that may pop up infrequently and are not known about
#
#  The purpose of this script is to save files ideally less than 5 minutes old. So when compiling or you dont know where some files are
#or what changed on your system. So if you compiled something you call this script to build a module of it for distribution.
#
#  If not using for developing call it a file change snapshot
#
#  We use the find command to list all files 5 minutes or newer. Filter it and then get to copying the files in a temporary staging directory.
#  Then take those files and make an .xzm. It will be placed in   /tmp  along with a transfer log to staging directory and file manifest of the xzm 
#
#
#  recentchanges command from    /usr/bin/recentchanges
#  Also borred script features from various scripts on porteus forums
# working off of base save-changes script by
# Author: Brokenman <brokenman@porteus.org>
# Author: fanthom <fanthom@porteus.org>
. /usr/share/porteus/porteus-functions
get_colors
. /usr/local/save-changesnew/versionquery
. /usr/local/save-changesnew/validprogram.sh
. /usr/local/save-changesnew/rntchangesfunctions

# CHANGEABLE       New to version 3   
export email="john.e@email.com" # default for asymmetrical gpg auth for STATPST
                                                        # asks for paraphrase and caches for 15 minutes 
                                                        # leave default

export logSIZE=50 # default 50mb for persistent storage pst

export logCT=300 # Max searches to store in pst storage before removing one

export logPRF="del" # del delete and stop    what to do on max logSIZE 
                                # stop leave in place
                                # rfh refresh clear and log again retain 25% but 15% of original log and 10% allowance for new files not to exceed 25% of logSIZE

export compLVL=200  # default 200mb to disable compression on logpst size 

export tmpSRHS=7 # Default 7 store most recent searches in /tmp try 30 and then nrun recentchanges query with STATPST false
                                # for hybrid analysis in diff file
                                 # also queries ie recentchanges query stats 

export mMODE="normal"  # normal default. robust less prone to failure
								  # mem    balanced store search in arrays less i/o									
								   # mc      turbo mode run the search in parallel or multiple cores. 

# CHANGEABLE BOOLEANS

export ANALYTICS="true" # store recent searches in /tmp       default false 
                                        # gives hybrid analysis in diff file more files to compare no overhead as only checks modified
                                        # makes more sense to work off of /tmp than to decrypt everytime
                                        # for that reason you can choose /tmp or STATPST or both and recentchanges query
                                        # if you want your searches to be encrypted just use STATPST

                                        # if you start decrypting here searching there running post ops and everything else its a bad idea
                                        # for that reason I put protections in place for POSTOP

                                        # useful for quickly checking system filess
                                        # not as secure but still owned by root in /tmp but its temporary anyway and can be turned off

export STATPST="false" # persistent storage searches encrypted in /usr/local/save-changesnew for recentchanges query see logSIZE / logCT
                                    # Only overhead is gpg compression set compression to off. At large size speeds can increase by as much as 50%.
                                    # if you prefer security turn ANALYTICS false and use this


export ANALYTICSECT="true" # provides more feedback
                                            # total search time ect
                                            # we dont want too much output on the terminal just a slight bit more
                                            # others stats

export FEEDBACK="false"  # include find output in terminal as well ie scrolling terminal look   

## Diagnostics
export checkSUM="false"	# compare file checksums for slight changes
										# slower useful if you want to check deeper level of stats


export POSTOP="false" # Diagnostics. Create file doctrine. Runs post search operation that can only be done at this time as search is relevant    
                                    # more overhead so recommend off unless one off. output /Downloads  
                                    #
                                    # if it is run again and a file is still there it will not run the POSTOP and the script will set POSTOP to false to itself

# END CHANGEABLE
if [ "$STATPST" == "true" ] && [ "$ANALYTICS" == "true" ]; then echo With STATPST cant run with ANALYTICS. for security reasons as its stored in gpg. ; echo you can modify to run both if wanted. && exit; fi 
if [ "$1" = "-v" ]; then get_vrn $1 ; elif [ "$1" = "--help" ] || [ "$1" = "-h" ] || [ "$1" = "help" ] || [ "$1" = "-help" ]; then get_vrn $1; fi # If inquery tag no need to call root. pass to other function and exit.
# if [[ $(id -u) -ne 0 ]]; then sudo "$0" "$@"; exit 0; fi
#if [[ $(whoami) != "root" ]]; su -c "$0"; exit fi
if [ `whoami` != "root" ]; then
    echo "Please enter your root password below"
    argone="$1"
    argtwo="$2"    
    argthree=`whoami` # What user is it?
    if [ -z "$1" ]; then
    	argone="noarguser"
    fi
    if [ -z "$2" ]; then
    	argtwo="noarguser"
    fi	
    su - -c "/opt/porteus-scripts/recentchanges $argone '$argtwo' $argthree '$PWD'"		#change this if you move the location of this script so it calls if not root
    exit
fi
# Handle root call
THETIME=$2 ; USR=$3
passdir=$4
if [ "$2" == "" ]; then  THETIME="noarguser"; fi
if [ "$3" == "" ] || [ "$4" == "" ]; then USR="guest" ; passdir=$PWD; fi		#Default user
if [ "$3" == "SRC" ]; then echo "Incorrect usage please use recentchanges SRC s , s SRC or SRC" && exit 1; fi #Error handlings
if  ! id $3 >/dev/null 2>&1; then echo "user:" ${3} "not found"; exit 1; fi # quick user check if called by root recentchanges compile asdfas asdfasd    it could break the script  asdfasd user notfound
#Fork to other modes
# Alternative user check
#
#ps aux | grep -q "^$2"
#testone=$? # If a desired time is specified we will search for that  (in seconds)        
#if [ "$testone" == "1" ]; then
#	echo "User not found!"
	#exit 
#fi
#Fork to other modes
if [ "$1" == "compile" ]; then 
   	/usr/local/save-changesnew/compilesearch.sh $1 $USR "$passdir"
   	testone=$?  # If a desired time is specified we will search for that  (in seconds)    
   	if [ "$testone" == "1" ]; then
   		echo "Script failure."
   		exit 1 
   	fi     		
   	test -e /home/$USR/.config/save-changesnew/xCustomFilterProfile && { test -e /usr/bin/featherpad && featherpad /home/$USR/.config/save-changesnew/xCustomFilterProfile 2> /dev/null || echo featherpad not installed; }    		  		
   	exit
elif [ "$1" == "search" ]; then
   	test -d "${passdir}" || { echo  "not a valid directory. usage recentchanges search time."; exit 1; }
    argf="$5"
    if [ -z "$5" ]; then argf="bnk"; fi
   	source /usr/local/save-changesnew/recentchangessearch.sh "$1" "$THETIME" $USR "$passdir" $argf "$0"
   	exit
elif [ "$1" == "query" ]; then
    /usr/local/save-changesnew/query "$THETIME" $USR "$passdir"
    exit
fi  
work=work$$										;		tmp=/tmp/work$$
workdir=/myfiles								;		chxzm=/rntfiles.xzm
SVFILES=$tmp/save.rncfilesmanifest.tmp			;   	BRAND=`date +"MDY_%m-%d-%y-TIME_%R"|tr ':' '_'`
SVFOLDERS=$tmp/save.rncfoldersmanifest.tmp		;		FLBRAND=`date +"MDY_%m-%d-%y-TIME_%R_%S"|tr ':' '_'`
ABSENT=$tmp/tmp_absent.txt						;		UPDATE=$tmp/save.transferlog.tmp      
RECENT=$tmp/list_recentchanges_filtered.txt     ;		RECENTAPP=$tmp/list_recentapp_filtered.txt          
COMPLETE=$tmp/list_complete.txt					;		SORTCOMPLETE=$tmp/list_complete_sorted.txt 
TMPCOMPLETE=$tmp/tmp_complete.txt				;		RSYNCEXCL=$tmp/list_filesexclude.txt
TMPOPT=$tmp/tmp_holding	                        ;		RECENTNUL=$tmp/list_recentchanges_filterednul.txt 
FOLDERLOG=$tmp/save.totalfolders.tmp			;		REJECTLOG=$tmp/list_rejectsrc.txt                                                                
dr=/usr/local/save-changesnew					;       logpst=$dr/logs.gpg #Version 3
flth=$dr/flth.csv								;       statpst=$dr/stats.gpg                     
atmp=/tmp/atmp$$								;       rout=$atmp/routput.tmp 
xdata=$atmp/logs_stats.log						;       tout=$atmp/toutput.tmp 
toutnul=$atmp/toutputnul.tmp					;		slog=/tmp/scr
USRDIR=/home/$USR/Downloads						;		xdata2=$atmp/logs.log.log
THETIME=$1														
SRCDIR=""                                                                      
diffrlt="false"									;       validrlt="false"     								
nodiff="false"									;       samerlt="false"      
syschg="false"									;		approval="true"
mkdir $tmp #create directories
mkdir $tmp$workdir
mkdir $atmp
if [ "$ANALYTICSECT" == "true" ]; then start=$(date +%s.%N); fi #if [ "$ANALYTICS" == "true" ]; then
if [ "$STATPST" == "true" ]; then # pst check
    if [ -f $logpst ]; then
        sz=$( stat -c %s "$logpst")
        if [ $(( sz / 1048576 )) -gt $logSIZE ]; then
            if [ "$logPRF" == "del" ]; then
               : > $logpst
            elif [ "$logPRF" == "stop" ]; then
                cyan "persist log saving stopped on size limit"
            fi
            STATPST="false"
            if [ "$logPRF" == "rfh" ]; then
                rm $logpst
                STATPST="true"
            fi
		elif [ $(( sz / 1048576 )) -ge $compLVL ]; then
			nc="true" #disable compression
        elif [ $sz -eq 0 ]; then
            cyan "$logpst is 0 bytes. to resume persistent logging delete file"
            STATPST="false"
        fi
    fi
fi
if [ "$1" == "" ]; then THETIME="noarguser"; fi # root call
if [ "$THETIME" == "SRC" ]; then # Handle argument redirection as if we moved this script to another subscript it wouldnt be user friendly 
    SRCDIR=$THETIME
    if [ "$2" != "" ]; then
        THETIME=$2 #redirection grab time from 2 THETIME is either          a number   or    noarguser
    else
		THETIME="noarguser" # Its just the tag
   fi
fi
if [ "$2" == "SRC" ]; then				
    SRCDIR=$2
elif [ "$2" == "SEARCH" ] || [ "$2" == "search" ]; then
    echo "The SRC tag is for recentchanges only"; exit
fi
if [ "$THETIME" != "noarguser" ] && [ "$THETIME" != "" ]; then # If a desired time is specified we will search for that  (in seconds)
    
    #check if the argument is a number
    if [ "$THETIME" -ge 0 ] 2>/dev/null; then
    	argone=$THETIME  #What the user passed
    else
    	echo argument specified not a valid integer or valid flag; exit 1
    fi 
    
	cyan "Grabbing files (filtered) and searching for total sys files $argone seconds old or newer"  
    p=60
	
	tmn=$( echo "scale=2; $argone /$p" | bc)

	if [ $(( $argone % $p )) -eq 0 ]; then tmn=$(( $argone / $p )); fi

    if [ "$FEEDBACK" != "true" ]; then	       
        find /bin /etc /home /lib /lib64 /opt /root /sbin /usr /var -mmin -"$tmn" -not -type d -print0 2> /dev/null | tee "$RECENTNUL" > /dev/null 2> /dev/null
		find /bin /etc /home /lib /lib64 /opt /root /sbin /usr /var \( -cmin -"$tmn" -o -amin -"$tmn" \) -not -type d -print0 2> /dev/null | tee "$toutnul" > /dev/null 2> /dev/null            # This cannot be fed into $RECENT ******
    else
        find /bin /etc /home /lib /lib64 /opt /root /sbin /usr /var -mmin -"$tmn" -not -type d | tee "$RECENTNUL" -print0 2>/dev/null #Show terminal output FEEDBACK
		find /bin /etc /home /lib /lib64 /opt /root /sbin /usr /var \( -cmin -"$tmn" -o -amin -"$tmn" \) -not -type d -print0 | tee "$toutnul" 2> /dev/null            
    fi
	
    #cp $RECENT $COMPLETE    #we need two files one to work with and one to add customized time for user reading
                            #due to output supression above we do it this way    |tee $file1 $file2 > /dev/null doesnt work
    
# Search the default time  5 minutes.
else 
    
    cyan "Grabbing files (filtered) and searching for total sys files 5 minutes old or newer"
    argone="5"
    if [ "$FEEDBACK" != "true" ]; then	       
	    find /bin /etc /home /lib /lib64 /opt /root /sbin /usr /var -mmin -"$argone" -not -type d -print0 2> /dev/null | tee "$RECENTNUL" > /dev/null 2> /dev/null
		find /bin /etc /home /lib /lib64 /opt /root /sbin /usr /var \( -cmin -"$argone" -o -amin -"$argone" \) -not -type d -print0 2> /dev/null | tee "$toutnul" > /dev/null 2> /dev/null            # This cannot be fed into $RECENT ******
			
    else
        find /bin /etc /home /lib /lib64 /opt /root /sbin /usr /var -mmin -"$argone" -not -type d -print0 | tee "$RECENTNUL" 2>/dev/null 
		find /bin /etc /home /lib /lib64 /opt /root /sbin /usr /var \( -cmin -"$argone" -o -amin -"$argone" \) -not -type d -print0 | tee "$toutnul" 2> /dev/null
    fi
	#cp $RECENT $COMPLETE   #we suppressed the output from find so now we have to copy a duplicate to work with
						   #we need a copy to sort to human readable of all changed system files
fi
if [ "$checkSUM" == "true" ]; then cyan "Running checksum. Please wait..."; fi
if [ "$ANALYTICSECT" == "true" ]; then 
	end=$(date +%s.%N)
	if [ "$checkSUM" == "true" ]; then 
		  cstart=$(date +%s.%N)
	fi 
fi

########
#$RECENT
#$tout
#$RECENTUL
# ?

######## 

###New to version 3
#read -r -p "Press Enter to continue..."
#exit

while IFS= read -r -d '' f; do
		f="${f//$'\n'/\\n}"
		echo "$f"
done < $RECENTNUL >> $RECENT               # Our main list  with \n escaped to \\n  so we can compare here and also further down
while IFS= read -r -d '' f; do
		f="${f//$'\n'/\\n}"
		echo "$f"
done < $toutnul >> $tout 						# Tempory Secondary list ..   for comparison
if [ -s $tout ]; then grep -Fxv -f $RECENT $tout > $TMPCOMPLETE; fi
> $tout
if [ -s $TMPCOMPLETE ]; then
	while IFS= read -r x; do x="${x//$'\\n'/\n}"; printf '%s\0' "$x"; done < $TMPCOMPLETE >> $xdata    # convert back to \n  and \0 for copying
	# Slackpkg and pacman download detection ect
	# We have to store the access time ******   and/or  checksum if enabled
	#
	# We are appending the results of this after our original loop. Just so these new files are shown.
	# what we do with the data can be extensive but only need to process it if checksum is enabled.
	#
	# Efficiency gains are massive with xargs so running this includes those minute files that arent shown and even that is fast
	# So we are able to bring even more detection that way if the user wants to run in Diagnostic mode.
	#
	#Notes
#   3) intangibles ie trashed items that may pop up infrequently and are not
	#Original idea but lets do filenames with spaces as well
	#As filenames with spaces could potentially break anything remove all file names with spaces                       
	#sed -E 's/^([^ ]+ ){2}//' $TMPCOMPLETE >> /tmp/fparity.txt
	#grep -vFf /tmp/fparity.txt $TMPCOMPLETE > $TMPOPT && mv $TMPOPT $TMPCOMPLETE
	#sed -i '/^\([^ ]* \)\{3,\}/d' $TMPCOMPLETE

	# This loop ensures we find all files even those with preserved metadata
	#
	# These are very picky files can be missing all sorts of attributes. Have to becareful
	#
	#
	# While loop more reliable than xargs capture all stats in one go

	if [ "$mMODE" == "normal" ]; then
		while IFS= read -r -d '' x; do
			adtcmd="" ; output="" ; fs=""
			y="${x//$'\n'/\\n}"
			if [ -e "$x" ] && [ -f "$x" ]; then
				stat_output=$(stat -c "%Y %X %Z %i" "$x") # Get modified access time change time and inode number
				read -r mtime atime itime i <<< "$stat_output"
				ct=$(date -d "@$itime" +"%Y-%m-%d %H:%M:%S")
				at=$(date -d "@$atime" +"%Y-%m-%d %H:%M:%S") #mdate=$(date -d "@$mtime" +"%Y-%m-%d %H:%M:%S")
				if [ -n "$ct" ]; then # This at least ensures the format is correct with a date
					if (( itime > mtime )); then				
						if [ "$checkSUM" == "true" ]; then
							csum=$(md5sum "$x" | awk '{print $1}')
							fs=$(stat --format=%s "$x") 
							adtcmd="$csum $fs"
						fi	
						if [ -n "$ct" ] && [ -n "$at" ]; then # This is critical we want to ensure the best possible chance of proper format exclude everything else
							output="$ct \"$y\" $i $at $adtcmd"
							printf '%s\n' "$output" >> $tout
						fi
					fi
				fi

			else
				printf 'NOTA-FI-LE 77:77:77 "%s"\n' "$y" >> $tout
				printf 'Nosuchfile,,"%s"\n' "$y" >> $COMPLETE
			fi
		done < $xdata
		unset IFS
	elif [ "$mMODE" == "mem" ]; then
		declare -a ffile
		declare -a nsf
		while IFS= read -r -d '' x; do
			adtcmd="" ; output="" ; fs=""
			y="${x//$'\n'/\\n}"
			if [ -e "$x" ] && [ -f "$x" ]; then
				stat_output=$(stat -c "%Y %X %Z %i" "$x")
				read -r mtime atime itime i <<< "$stat_output"
				ct=$(date -d "@$itime" +"%Y-%m-%d %H:%M:%S")
				at=$(date -d "@$atime" +"%Y-%m-%d %H:%M:%S")
				if [ -n "$ct" ]; then
					if (( itime > mtime )); then
						if [ "$checkSUM" == "true" ]; then
							csum=$(md5sum "$x" | awk '{print $1}')
							fs=$(stat --format=%s "$x") 
							adtcmd="$csum $fs"
						fi
						if [ -n "$ct" ] && [ -n "$at" ]; then
							output="$ct \"$y\" $i $at $adtcmd"
						    ffile+=("$output")
						fi
					fi
				fi
			else			
				ffile+=("NOTA-FI-LE 77:77:77 \"$y\"")
				nsf+=("Nosuchfile,,\"$y\"")
			fi
		done < $xdata
		unset IFS
	elif [ "$mMODE" == "mc" ]; then
		xargs -0 -I{} /usr/local/save-changesnew/searchfiles "{}" "$atmp" "$checkSUM" < $xdata
		if compgen -G "$atmp/searchfiles1_*_tmp.log" > /dev/null; then cat "$atmp"/searchfiles1_*_tmp.log >> "$tout"; fi
		if compgen -G "$atmp/searchfiles2_*_tmp.log" > /dev/null; then cat "$atmp"/searchfiles2_*_tmp.log > "$COMPLETE"; fi
	else
		echo incorrect mMODE && exit
	fi
	rm $xdata
fi
### End New to version 3


# Lose the quotes
#awk -F'"' '{print $2}'   file           grabs filename between quotes


#We have a log of all system changes $COMPLETE will include that

#parse stat modified time
#stat -c '%y' "$x" | sed -e 's/\...........-....//g'     Actual time then shave off with sed some random stuff on the side
#date -d @1234567890 +'%Y-%m-%d %H:%M:%S'       <-------- convert epoch seconds to time and then rearrange format

#We will be using epoch
#Lets add file modified time so it can be easily viewed and replace $COMPLETE with $SORTCOMPLETE
#Files are copied lets take our time and check for bogus files on the right  ie cache items
#> $SORTCOMPLETE																																				
#while IFS= read x; do test -e "$x" && test -f "$x" && { f=$(stat -c '%Y' "$x") ; echo $(date -d "@$f" +'%Y-%m-%d %H:%M:%S') "$x"; } >> $SORTCOMPLETE || { echo "NOTA-FI-LE 77:77:77" "$x" >> $SORTCOMPLETE; echo "Nosuchfile,,\"${x}\"" >> $tout; }; done < #$COMPLETE   
#unset IFS

 # Main loop
 # Run capture stats in one shot more reliable than xargs                  
if [ "$mMODE" == "normal" ]; then     
	while IFS= read -r -d '' x; do
		adtcmd="" ; output="" ; fs=""
		y="${x//$'\n'/\\n}"
		if [ -e "$x" ] && [ -f "$x" ]; then
			read -r f atime i <<<$(stat -c "%Y %X %i" "$x")
			mt=$(date -d "@$f" +"%Y-%m-%d %H:%M:%S")
			ats=$(date -d "@$atime" +"%Y-%m-%d %H:%M:%S")
			if [ -n "$mt" ]; then  # This at least ensures the format is correct if there is no date
				if [ "$checkSUM" == "true" ]; then
					csum=$(md5sum "$x" | awk '{print $1}')
					fs=$(stat --format=%s "$x") 
					adtcmd="$csum $fs"
				fi
				output="$mt \"$y\" $i $ats $adtcmd"
				printf '%s\n' "$output" >> "$SORTCOMPLETE"
			fi
		else
			printf 'NOTA-FI-LE 77:77:77 "%s"\n' "$y" >> $SORTCOMPLETE
			printf 'Nosuchfile,,"%s"\n' "$y" >> $COMPLETE
		fi
	done < $RECENTNUL
	unset IFS
elif [ "$mMODE" == "mem" ]; then
	while IFS= read -r -d '' x; do
		adtcmd="" ; output="" ; fs=""
		y="${x//$'\n'/\\n}"
		if [ -e "$x" ] && [ -f "$x" ]; then
			read -r f atime i <<<$(stat -c "%Y %X %i" "$x")
			mt=$(date -d "@$f" +"%Y-%m-%d %H:%M:%S")
			ats=$(date -d "@$atime" +"%Y-%m-%d %H:%M:%S")
			if [ -n "$mt" ]; then  # This at least ensures the format is correct if there is no date
				if [ "$checkSUM" == "true" ]; then
					csum=$(md5sum "$x" | awk '{print $1}')
					fs=$(stat --format=%s "$x") 
					adtcmd="$csum $fs"
				fi
				output="$mt \"$y\" $i $ats $adtcmd"
				ffile+=("$output")
			fi
		else
			ffile+=("NOTA-FI-LE 77:77:77 \"$y\"")
			nsf+=("Nosuchfile,,\"$y\"")
		fi
	done < $RECENTNUL
	unset IFS
	printf "%s\n" "${ffile[@]}" >> $SORTCOMPLETE
	if [ ${#nsf[@]} -gt 0 ]; then printf "%s\n" "${nsf[@]}" >> $COMPLETE; fi
elif [ "$mMODE" == "mc" ]; then
	#xargs -0 -I{} -P4 /usr/local/save-changesnew/mainloop "{}" "$atmp" "$checkSUM" < $RECENTNUL
	xargs -0 -n8 -P4 /usr/local/save-changesnew/mainloop "$atmp" "$checkSUM" < $RECENTNUL
	if compgen -G "$atmp/mainloop1_*_tmp.log" > /dev/null; then cat "$atmp"/mainloop1_*_tmp.log > "$SORTCOMPLETE"; fi
	if compgen -G "$atmp/mainloop2_*_tmp.log" > /dev/null; then cat "$atmp"/mainloop2_*_tmp.log >> "$COMPLETE"; fi
else
	echo incorrect mMODE && exit
fi


# Main loop we append to it below from our top loop # 
# $COMPLETE is tout now **************************   No such file ******************** #
#Regarding cache items that do not exist this is leading to what I call the segway of recentchanges we can call other functions and methods
#
#We can inform the user that there are files ie empty sym links or their filters are capturing .cache or cache items. Inform rather than do will always be rule #1
#
#
#Now we could export a file with all filters used from this script but instead lets lead to our segway
#
#we build in detection   your compiled files where at this time. well at this time a folder was made in   /etc/  by your compiler. 
#so we output a file rntfilesSuggestions       warn you should adjust your filter to  remove    /etc   filter
#
#we then package those files in /etc  and send it to   rntfilesMissed.xzm  with no archive.   the user can decide to extract the .xzm and grab that one missing folder out of there
#
#
if [ -s $SORTCOMPLETE ]; then 
	sort -u -o  $SORTCOMPLETE $SORTCOMPLETE      # Original  -o       version 3   -u -o
	SRTTIME=$( head -n1 $SORTCOMPLETE | awk '{print $1 " " $2}')  # day and time
	PRD=$SRTTIME
	# Version 3
	if [ -s $tout ]; then grep -v 'NOTA-FI-LE 77:77:77' "$tout" | awk -v tme="$PRD" '{ ts = $1 " " $2; if (ts >= tme) print }' > $TMPOPT ; cat $TMPOPT >> $SORTCOMPLETE; fi  #   We dont want anything before our main files.
	#
	##
	# At this point we have to filter out files from the future cache files ect

	SRTTIME=$( head -n1 $SORTCOMPLETE | awk '{print $1 " " $2}')  # day and time
	s=$( echo $(date -d "$SRTTIME" "+%s"))  
	if [ "$THETIME" == "noarguser" ]; then         # Also if its noarguser         We know its 300 seconds
		RANGE=$(( s + 300 ))
	else
		#if [ "$2" -ge 0 ] 2>/dev/null; then      #   seconds
			RANGE=$(( s + argone ))  # End time range based on search criteria 
		#fi
	fi
	PRD=$( echo $(date -d "@$RANGE" +'%Y-%m-%d %H:%M:%S')) # convert back to YYYY MM-DD HH:MM:SS
	grep -v 'NOTA-FI-LE 77:77:77' "$SORTCOMPLETE" | awk -v tme="$PRD" '{ ts = $1 " " $2; if (ts <= tme) print }' > $tout ; mv $tout $SORTCOMPLETE
	syschg="true"; sort -u -o $SORTCOMPLETE $SORTCOMPLETE  # Original  -o       version 3   -u -o
		
	# Human readable
	# We want a human readballe first two columns date and time and the filename without the quotes.
	awk '{print $1, $2}' $SORTCOMPLETE > $tout
	awk -F'"' '{print $2}' $SORTCOMPLETE  > $TMPCOMPLETE
	paste -d' ' $tout $TMPCOMPLETE > $TMPOPT
	sort -o $TMPOPT $TMPOPT
	#sed -i -E 's/^([^ ]+ [^ ]+ [^ ]+)( .*)$/\1/' $TMPOPT   # bring it to proper format   We are only interested in the first 3 fields   doesnt work with spaces ***
	# Lose the quotes
	#sed -i 's/"//g' $TMPOPT  # this works
	# End Human readable
	# End Version 3
fi
/usr/local/save-changesnew/filter $RECENT $USR #Apply filtering


# $SORTCOMPLETE is our search file with all the data and  "  "   filename
# $TMPOPT is human readable from SORTCOMPLETE and unfiltered
# $RECENT is the original search date time filename and filtered
# $COMPLETE is used by the function below to storage PST stats it holds some stats
# $tout is available as a tmp file now
# $TMPCOMPLETE is used as a tmp file below becareful which one is available
# $UPDATE  is used as a tmp file and becomes available at the tail end of the script

##Copy the files Send files to  /tmp/work$$/myfiles
#Send files to  /tmp/work$$/myfiles
> $tout ; >$UPDATE
while IFS= read -r x; do x="${x//$'\\n'/$'\n'}" ; printf '%s\0' "$x"; done < $RECENT >> $tout            # convert it  back to \n for copying
while IFS= read -r -d '' x; do if cp -a --parents "$x" "$tmp$workdir" > /dev/null 2>> $xdata; then printf '%s %s\n' "$x" "success" >> $UPDATE; else echo "Failed to copy: $x" >&2; echo "ERROR: $x" >> $UPDATE; fi; done < $tout
unset IFS
if [ -s $xdata ]; then echo > $UPDATE ; cat $xdata $UPDATE; fi
test -e $xdata && rm $xdata
echo $BRAND >> $UPDATE      #stamp data/time to logfile
#Transfer log completion

#We have a log of all system changes $COMPLETE will include that
#More logging
#  Now
#  make a log of all files that are true to the /myfiles  ie exact files that made it
# into   /tmp/work$$/myfiles      sometimes a file may not copy  ie error out
#                               this is our manifest of the .xzm
#/tmp/
find $tmp$workdir -not -type d -print0 > $SVFILES
# Tempory Secondary list ..   for comparison
>$tout
while IFS= read -r -d '' x; do x="${x//$'\n'/$'\\n'}" ; echo "$x" ; done < $SVFILES >> $tout 
mv $tout $SVFILES 					# escape any \n to \\n	

sed -i -e "s|$tmp$workdir||g" $SVFILES #Clean up the logfile    dir name 
cat $SVFILES | sed -e 's![^/]*$!!g' > $SVFOLDERS     #/basedir/somedir/myfile.txt   return /basedir/somedir/    <----- the root folder of the files

# SRC tag
#If the user compiled an application package it
if [ "$SRCDIR" == "SRC" ]; then
    arrfiles=() # Array for storing filenames 
    arrreject=()
    appname="Application"       #Our default application name    
    FLTOUT="/tmp/${appname}ItemsFilteredout"

    #Remove old application
    test -e "/tmp/${appname}.xzm" && rm "/tmp/${appname}.xzm"
    # Remove old app logs
    rm "/tmp/"*"_xdata" 2> /dev/null 
    
    rlt=$( validprogram $SVFOLDERS)      #Check if there is a valid program
 
 	if [ "$rlt" == "/" ]; then
 		echo Fatal error. exiting.
 		exit 1
 	fi

    #if there are files to process
    if [ "$rlt" != "" ]; then
        #Copy the files from $RECENT to a new directory minus any bogus files
        # generate a new list
        cat $SVFILES | grep "${rlt}" > $RECENTAPP
        # remove bogus files
        cat $SVFILES | grep -v "${rlt}" > $RSYNCEXCL

        # manipulate logfile to work with mksquahfs
        #sed -i -e "s|$tmp$workdir||g" $RSYNCEXCL
        #sed -i '/^[[:space:]]*$/d' $RSYNCEXCL
        #sed -i 's/^\///g' $RSYNCEXCL

 
        #Make the xzm and leave it in    /tmp
        #mksquashfs $tmp$workdir "/tmp/"$appname".xzm" -ef $RSYNCEXCL

        while IFS= read -r p || [ -n "$p" ]; do                          # used \\n to compare now convert back
			p="${p//$'\\n'/$'\n'}"
			rm -- "$tmp$workdir$p"
        done < $RSYNCEXCL
		unset IFS

		find $tmp$workdir -type d -empty -delete
        mksquashfs $tmp$workdir "/tmp/${appname}.xzm"  # -ef $RSYNCEXCL   wont work for filenames with  \n

        #Send master log or manifest for the module to  /tmp    and label it accordingly
        cp $RECENTAPP "/tmp/${appname}_xdata"
        echo $BRAND >> "/tmp/${appname}_xdata"
        sort -o $RECENTAPP $RECENTAPP

		# Convert $SORTCOMPLETE      we should already have a copy       **********
        #echo >> $FLTOUT
        cat $SORTCOMPLETE | grep -Ff $RECENTAPP | grep -v 'NOTA-FI-LE 77:77:77'  | tee $TMPCOMPLETE > /dev/null 
        
        
        # get time and append compile statistics and analysis
        endtm=$( gettime "$TMPCOMPLETE" "/tmp/${appname}_xdata")
        printf "\n\n" >> "/tmp/${appname}_xdata"
        cat $TMPOPT | grep -Fvf $RECENTAPP > $TMPCOMPLETE 
        
        #	Now that we have the files taken care of we could run another function to run a timecheck based on the file times.
        #if any folders are outside of the range we can delete them (they are in in /tmp ) and send it to  _xdata.
        #But when dealing with files its always best to include rather than delete and possibly miss some files.
        #
        # As system time cant be esclusively depended on. Corrupt data or some wierd setting could alter the file time.
        #
        #validate( $TMPCOMPLETE)           

        # Original not as efficient
        #
		#find "$tmp$workdir$rlt" -type f >> $REJECTLOG
		#sed -i -e "s|$tmp$workdir||g" $REJECTLOG	
		#while IFS= read x; do grep "$x" $RECENTAPP || { approval="false"; echo "$x"; } >> "/$tmp/tmpcache"; done < $REJECTLOG   
		#unset IFS
		
		# New more efficient  Use array instead of outputting to file
		#
        #declare -a myARR
	    cd $tmp$workdir || exit
	    srcpath="${rlt#?}"         #Strip the first character  "/"
        # Use 'find' to gather all and properly handle file paths with spaces or special characters
        
        y=$( wc -l < $RECENTAPP) # total file count
        x=0
		while IFS= read -r -d '' f
        do 

			f="${f//$'\n'/$'\\n'}"
            grep -Fq -- "$f" $RECENTAPP && x=$(( x + 1 )) || { approval="false"; arrreject+=("$f"); } 
        done < <(find "${srcpath}" \( -type f -o -type l \) -print0)

		r=$( find "${rlt}" -type f | wc -l)  # system count
		echo Root:"${rlt}" >> "/tmp/${appname}_xdata" 
		echo "File count: "$x "of ${y}" >> "/tmp/${appname}_xdata"
		echo "System count: "$r >> "/tmp/${appname}_xdata"
		echo >> "/tmp/${appname}_xdata"
		echo >> "/tmp/${appname}_xdata"
		
		if [ "$approval" == "true" ]; then
			echo "Status: Complete. Files verified " >> "/tmp/${appname}_xdata"
			echo >> "/tmp/${appname}_xdata"
		else
			echo >> "/tmp/${appname}_xdata"
			echo "Status: Missed base directory. Confirm files or use recentchanges for rntfiles.xzm" >> "/tmp/${appname}_xdata"
			echo >> "/tmp/${appname}_xdata"
			echo "Following file(s) do not belong" >> "/tmp/${appname}_xdata"
            for element in "${arrreject[@]}"; do echo "$element" >> "/tmp/${appname}_xdata"; done		
            #echo "${arrreject[@]}"
		fi 
		echo >> "/tmp/${appname}_xdata"
		echo >> "/tmp/${appname}_xdata"
        echo $BRAND >> $RECENTAPP
        
        if [ -s $TMPCOMPLETE ]; then
            #echo "Items filterout from filtered files."  >> "/tmp/"$appname"_xdata" 
            #echo >> "/tmp/"$appname"_xdata"
            #cat $TMPCOMPLETE >> "/tmp/"$appname"_xdata"							# version 3 proper format sed -E 's/^([^ ]+ [^ ]+ [^ ]+)( .*)$/\1/'
	    { echo "Items filterout from filtered files."; echo ; cat $TMPCOMPLETE; }  >> "/tmp/${appname}_xdata"  #echo $BRAND >> "/tmp/"$appname"_xdata"
        else
            echo "No items filtered out from filter."  >>"/tmp/${appname}_xdata"  
        fi
        #bash parsing
        #k=${file%/*}  /this/dir/   returns /this/dir 
        #k=${file#*/}  /this/dir    returns   this/dir
        #k=${file%%/*}  this/dir    returns this
        #k=${file##*/}     /this/dir/myfile.txt       returns    myfile.txt
        #
        find "$tmp$workdir$rlt" -type f -print0 > $TMPCOMPLETE
        while IFS= read -r -d '' f; do f="${f//$'\n'/$'\\n'}" ; arrfiles=("${arrfiles[@]}" "${f##*/}"); done < $TMPCOMPLETE
        unset IFS
        #Alternative search. Could specify *.tar ect
        #
        # for file in "${rlt}"/*
        #  do
        #y=$( echo $file | sed 's/\.tar\.gz//g')
        #"${mypol##*/}
        #     arrfiles=("${arrfiles[@]}" "${file##*/}")
        #echo "${file##*/}"
        #  done

        x=${#arrfiles[@]}
        y=0
        echo ""
        for i in "${arrfiles[@]}"
        do
            p=$(( y + 1 ))
            printf "%2d %-40s\t\t" "$p" "${i}" 
   
            (( y++ ))
            if  [ $(( y % 2 )) -eq 0 ]; then
                echo -en "\n"
            else
                if (( y == x )); then
                    echo -en "\n"
                fi           
            fi
            if (( y > 70 )); then
                break
            fi
        done

        echo "Root folder" "${rlt##*/}"

        echo  "Press enter for default filename"
        read  -p 'Filename or Selection: ' usrslc
        #sed 's/\(.*\)\./\1/g'      replace last delimter    ie  103.96.548       103.96548
        #sed 's/\.[^\.]*$//'  return all before the last delimiter      ie    103.96.548         103.96
        # sed -e 's/\.[^\.]..$//'   strips  file extensions  ie     .txt .ogg removes any 3 letter extension   myfile.txt returns  myfile

        # process input
        if [ "$usrslc" != "" ]; then
            #is it a number
            if [ "$usrslc" -ge 0 ]  2>/dev/null; then
                echo selected "$usrslc"
                if [ "${#arrfiles[@]}" -ge "$usrslc" ]; then
                    filename=$( echo ${arrfiles[$(( usrslc - 1 ))]} | sed -e 's/\.[^\.]..$//' -e 's/ /_/g')
                else
                    echo
                    echo "Using default filename."
                    # Default
                    filename=$appname 
                fi
            else
                # User entered name
                filename=$usrslc
            fi
        else
            # Default
            filename=$appname     
        fi

        if [ "$filename" != "${appname}" ]; then
            mv /tmp/"${appname}".xzm /tmp/"${filename}".xzm
            mv /tmp/"${appname}"_xdata /tmp/"${filename}"_xdata
        fi

        #cp $RECENT /tmp/"${filename}"_Filepool
        #pass ownership to user
        chown $USR /tmp/"${filename}".xzm
        chown $USR /tmp/"${filename}"_xdata
        #chown $USR /tmp/"${filename}"_Filepool
    fi
fi

echo $BRAND >> $SVFILES
cd /tmp || exit
MODULENAME=${chxzm:0:9}     # Our module name
LCLMODULENAME=${chxzm:1:8}
chxzmnm=$MODULENAME"manifest.txt"                  # Our module name manifest txt file
#$sessID$$
moduledir=$MODULENAME"_"$FLBRAND
#rdbDIR=$( echo $moduledir | sed -e 's/.*TIME/TIME/')     #manipulate string
FLTOUT="/tmp"$MODULENAME"ItemsFilteredout"

#Is there results in the .xzm?
k=$( head -n1 $SVFILES | grep "MDY")

# If MDY is not on the first line its not empty
if [ -z "$k" ]; then
	validrlt="true"

    #Move old files

    #Clear old history leave 2 behind (folders)
    r=$(find . -maxdepth 1 -type d -name '*rntfiles_MDY*' | wc -l)
    if [ "$r" -eq 2 ]; then
        for folder in "/tmp"$MODULENAME"_MDY"*
        do
            rm -r $folder
            break
        done
    fi

    # prepare to save old search
    #test -e "/tmp"$chxzm || test -e "/tmp"$chxzmnm || test -e "/tmp"$MODULENAME"Transferlog" || test -e  "/tmp"$MODULENAME"xSystemchanges"$argone || test -e  "/tmp"$MODULENAME"xSystemDiffFromLastSearch"$argone && mkdir "/tmp"$moduledir
    mkdir "/tmp"$moduledir && chown $USR "/tmp"$moduledir
    # Move old rntfiles to  /tmp/rntfiles$$
    test -e /tmp"$chxzm" && mv /tmp"$chxzm" "/tmp"$moduledir ; test -e "/tmp"$chxzmnm && mv "/tmp"$chxzmnm "/tmp"$moduledir; test -e "/tmp"$MODULENAME"Transferlog" && mv "/tmp"$MODULENAME"Transferlog" "/tmp"$moduledir

    # Move any xSystemchanges -->   /tmp/rntfiles$$/   also any      xSystemDiffFromLastSearch   same place
    mv $LCLMODULENAME"xSystemchanges"* "/tmp"$moduledir 2> /dev/null ; mv $LCLMODULENAME"xSystemDiffFromLastSearch"* "/tmp"$moduledir 2> /dev/null  

    test -e  "/tmp"$MODULENAME"ItemsFilteredout" && rm  "/tmp"$MODULENAME"ItemsFilteredout"

    #End Move old files

	# rntfiles.xzm execute only if SRC tag not used
    if [ "$SRCDIR" != "SRC" ]; then
    	#Make the xzm and leave it in    /tmp
	    mksquashfs $tmp$workdir "/tmp"$chxzm
	
	    #Send master log or manifest for the module to  /tmp    and label it accordingly
	    cp $SVFILES "/tmp"$chxzmnm
      
	    #Send transfer log from   /     to   /tmp/work$$/myfiles   send this to /tmp and label it accordingly
	    cp $UPDATE  "/tmp"$MODULENAME"Transferlog"

        #Make a filtered out log
        if [ "$validrlt" == "true" ]; then
            sort -o $RECENT $RECENT
					#$SORTCOMPLETE
            cat $TMPOPT | grep -Fvf $RECENT > $FLTOUT ; echo $BRAND >> $FLTOUT
            cat $TMPOPT | grep -Ff $RECENT | grep -v 'NOTA-FI-LE 77:77:77' | tee $TMPCOMPLETE > /dev/null 
            #Handle analysis
            #sed 's/^[^:]*:\([^:]*\):.*/\1/'           #strips 00:00:00   between : :
            sed -i '/^[[:space:]]*$/d' $TMPCOMPLETE
            endtm=$( gettime $TMPCOMPLETE "/tmp"$chxzmnm)
            
      
            #diff -u $RECENT $SORTCOMPLETE | grep -E "^\+" > "/tmp"$MODULENAME"ItemsFilterout"
            #comm -13 $RECENT $SORTCOMPLETE > "/tmp"$MODULENAME"ItemsFilterout"
        fi
        #pass ownership to user
        chown $USR "/tmp"$chxzm
        chown $USR "/tmp"$chxzmnm      
        chown $USR "/tmp"$MODULENAME"Transferlog"
        chown $USR $FLTOUT
        test -e "/tmp"$moduledir && chown $USR "/tmp"$moduledir
    fi
fi                                                       
if [ ! -f "/tmp"$moduledir$MODULENAME"xSystemchanges"$argone ]; then # New to version 3.0   check for the most recent old search in MDY folders if one isnt in /tmp

	r=$(find . -type f -path "*/${MODULENAME}_MDY*/*" | wc -l)
	if (( r >= 1 )); then
		for folder in $(ls -d /tmp"${MODULENAME}"_MDY* | sort -r); do # most recent folder
			for file in $folder$MODULENAME"xSystemchanges"*; do
			    test -f $file && { OLDSORTED=$file ; nodiff="true"; break; }
			done
			[ -n "$OLDSORTED" ] && break  
		done
	fi
else
    OLDSORTED="/tmp"$moduledir$MODULENAME"xSystemchanges"$argone; nodiff="true"
fi
#test -f "/tmp"$moduledir$MODULENAME"xSystemchanges"$argone && { OLDSORTED="/tmp"$moduledir$MODULENAME"xSystemchanges"$argone; nodiff="true"; }
difffile="/tmp"$MODULENAME"xSystemDiffFromLastSearch"$argone

# The system search
# Is there a valid system search
if [ -s $SORTCOMPLETE ]; then
    #If an old search is valid we compare to our new search
    if [  -n "$OLDSORTED" ] && [ -s $OLDSORTED ]; then
    	sed -i '/^[[:space:]]*$/d' $OLDSORTED

        comm -23 $OLDSORTED $TMPOPT > $TMPCOMPLETE   
   		# Alternative to compare files
   		# awk 'NR==FNR{a[$0];next}{if($0 in a)print $0}' file1.txt file2.txt           <---  in both  
   		# awk 'NR==FNR{a[$0];next}{if(!($0 in a))print $0}' file1.txt file2.txt           <---  in file2 not file1    
   		# or   awk 'NR==FNR{a[$0];next}!($0 in a)' file1.txt file2.txt                       <---  " "    "   "
        # anything to compare?
        if [ -s $TMPCOMPLETE ]; then
            cp $TMPCOMPLETE "${difffile}"  

	        diffrlt="true"
	        #T=$(sed -e 's/\s//g' "${difffile}")
	        #if [ -n "$T" ]; then diffrlt="true"; fi
		    
            #Cut out irrelevant files
			cDATE=$( head -n1 $SORTCOMPLETE | awk '{print $1 " " $2}')          
            awk -v tme="$cDATE" '$0 >= tme' "$difffile" > $TMPCOMPLETE
             #cTIME=$( head -n1 $SORTCOMPLETE | awk '{print $2}')											<---- original used only the time not time and day
            #cat "${difffile}" | awk -F" " -v tme="$cTIME" '$2 >= tme' > $TMPCOMPLETE		<---- original "    "       as above
	        echo "          " >> "${difffile}"
	    

            while IFS="" read -r p || [ -n "$p" ]; do                          
		       	cFILE=$( echo "$p" | cut -d " " -f3-)  # no quotes in $TMPCOMPLETE        cFILE=$(echo "$p" | awk -F'"' '{print $2}')    # Version 3  grab the filename from quotes   "   spaces in file       "
				#dt=$(echo "$p" | cut -d " " -f1-2)
				#cFILE="{cFILE//$'\n'/\\n}"
		        #cFILE=$( echo $p | awk '{print $3}')
	
                grep -Fqs "$cFILE" $SORTCOMPLETE && { echo "Modified" "$p" >> $ABSENT; echo "Modified" "$p" >> $rout; } || { echo "Deleted" "$p" >> $ABSENT; echo "Deleted" "$p" >> $rout; } # record delete for stats
	        done < $TMPCOMPLETE
	        unset IFS

	        test -f $ABSENT  && { echo Applicable to your search ; cat $ABSENT ; } >> "${difffile}" || { diffrlt="false" ; echo "None of above is applicable to search. It is the previous search."; } >> "${difffile}"
            
        else
            samerlt="true"

        fi
    fi
    ofile=$atmp/tmpinfo
    tfile=$atmp/tmpd
    if [ -d /tmp/rc ] && [ "$ANALYTICS" == "true" ] && [ "$STATPST" == "false" ]; then   # TMP SRG
        for file in rc/*; do
            cat $file >> $ofile 2>/dev/null
        done
        if [ -s $ofile ]; then 
            sort -u -o $ofile $ofile # Built the previous search history
			cc=$(hanly $SORTCOMPLETE $ofile)  #hybrid analysis          New to version 3
			if [ -n "$cc" ]; then
				if [ "$cc" == "csum" ]; then
					#red "*** Checksum of file altered without a modified time."
					awk '{ print "\033[31m *** Checksum of file \033[0m" $0 "\033[31m altered without a modified time\033[0m" }' /tmp/cerr && rm /tmp/cerr
				else
					echo "Detected $cc CPU cores."
				fi
			fi
			[[ -s $difffile ]] && [[ -n "$( tail -n 1 $difffile)" ]] && green "Hybrid analysis on"
        fi        
    fi
    if [ "$STATPST" == "true" ]; then  # STATPST SRG
		# hybrid analysis Only if storing persistently
		if [ "$ANALYTICS" == "false" ]; then # process the hybrid anlys
			if [ -s $logpst ]; then
				# We decrypt here and pass a flag so encrypt knows it is already decrypted so we dont decrypt twice
				if decrypt $xdata2 $logpst; then 
					awk 'NF' $xdata2 > $ofile # Remove spaces and built the previous search history
		             if [ -s $ofile ]; then 
		                sort -u -o $ofile $ofile 
		           	   	cc=$(hanly $SORTCOMPLETE $ofile) #hybrid analysis		New to version 3
						if [ -n "$cc" ]; then
							if [ "$cc" == "csum" ]; then
								#red "*** Checksum of file altered without a modified time."
								awk '{ print "\033[31m *** Checksum of file \033[0m" $0 "\033[31m altered without a modified time\033[0m" }' /tmp/cerr && rm /tmp/cerr
							else
								echo "Detected $cc CPU cores."
							fi
						fi
						[[ -s $difffile ]] && [[ -n "$( tail -n 1 $difffile)" ]] && green "Hybrid analysis on"
		            fi				
				else
					echo "Failed to decrypt log file in hanalysis"
				fi
			fi
		fi                                                    											
		# Encrypt 				 New to version 3 ANALYTICS from $statpst											$rout has all statistic data   action dateandtime filename
        if [ -s $rout ]; then
            sort -u -o $rout $rout # remove anything already in written
			sed -i -E 's/^([^ ]+) ([^ ]+ [^ ]+) (.+)$/\1,"\2","\3"/' $rout #csv format
            #sed -i -E 's/^([^ ]+) ([^ ]+) ([^ ]+) (.+)$/\1,"\2 \3","\4"/' $rout 
            #save stats encrypt
            imsg=$(storeenc $rout $statpst) # func appends $COMPLETE formly $tout   <-----------
            ret=$?
            if [ $ret -ne 0 ]; then
                echo "$imsg"
            else
                if [ "$imsg" != "" ]; then green "Persistent stats created."; imsg=""; fi
            fi
        fi
        imsg=$(storeenc $SORTCOMPLETE $logpst "dcr") # save encrypt   dcr the file is already decrypted
        ret=$?
        if [ $ret -ne 0 ]; then
            echo "$imsg"
        else
            if [ "$imsg" -ge 0 ] 2>/dev/null; then 
                if (( imsg % 10 == 0 )); then  cyan "$imsg searches in gpg log"; fi # reduce feedback if (( $imsg % 10 == 0 )); then  
            elif [ "$imsg" != "" ]; then
                green "Persistent search log file created."
            fi
        fi      
    fi
	[ -s "$slog" ] && { [ "$cdiag" == "false" ] && cat $slog || echo >> "$difffile" && cat $slog >> "$difffile"; } 
	test -f $slog && rm $slog
    test -f $rout && rm $rout # incase pst off
	filterhits $TMPOPT $flth  # record hits  ruman readable unfiltered best chance at matching 
	postop $TMPOPT $0  # ie file doctrine  POSTOP var
    #Send the complete list of all changed files for convenience   and label accordingly
    cp $TMPOPT "/tmp"$MODULENAME"xSystemchanges"$argone  
	chown $USR "/tmp"$MODULENAME"xSystemchanges"$argone
	test -e "$difffile" && chown $USR "$difffile"
	#sed -E 's/^([^ ]+ [^ ]+ [^ ]+)( .*)$/\1/' "/tmp"$MODULENAME"xSystemchanges"$argone # Only show first 3 columns for viewing  Version 3     **** doesnt work with filename spaces
    #sed -i -E 's/^((([^ ]|\\ )+ +){3})[^ ]+( +)?/\1/' "/tmp"$MODULENAME"xSystemchanges"$argone      # remove 4th column for viewing Old version
fi
if [ "$ANALYTICS" == "true" ] && [ "$STATPST" == "false" ]; then   # feedBACK=="true"  also   More analytics 
    stmp $SORTCOMPLETE # save /tmp search
    if [ ! -f /tmp/rc/full ]; then cyan "Search saved in /tmp"; fi # save in /tmp but disable notification after full
fi #Logging complete
rm -rf $tmp #cleanup
rm -rf $atmp
if [ "$ANALYTICSECT" == "true" ]; then
    el=$(awk "BEGIN {print $end - $start}")
    printf "Search took %.3f seconds.\n" "$el"

	if [ "$checkSUM" == "true" ]; then
		el=$(awk "BEGIN {print $cend - $cstart}")
		printf "Checksum took %.3f seconds.\n" "$el"
	fi
fi
if [ "$validrlt" == "true" ]; then                                    
  	cyan "Your module has been created. in /tmp"
 	echo
    if [ "$SRCDIR" == "SRC" ]; then
  	    cyan "${filename}".xzm
  	    echo
    else
        cyan " Total pull range: ""${endtm}"
        cyan "$chxzm  including a file manifest"
        echo
    fi
else
   	cyan "There were no files to grab."
  	echo
fi
if [ "$THETIME" != "noarguser" ] && [ "$syschg" == "true" ]; then
	cyan "All system files in the last $THETIME seconds are included"
cyan ""$MODULENAME"xSystemchanges"$argone
	echo             
elif [ "$syschg" == "true" ]; then
	cyan "All system files in the last 5 minutes are included       "   
    cyan ""$MODULENAME"xSystemchanges"$argone
	echo             
fi
if [ "$syschg" == "false" ]; then
    cyan "No sys files to report."
fi
if [ "$samerlt" == "true" ] && [ "$syschg" == "true" ] && [ "$nodiff" == "true" ]; then
    cyan "The sys search was the same as before.                          "
fi
if [ "$diffrlt" == "false" ] && [ "$nodiff" == "true" ] && [ "$samerlt" == "false" ]; then
green " Nothing in the sys diff file. That is the results themselves are true" 
cyan "Refer to /rntfiles_MDY folder for the previous search"
fi
# We could test if featherpad is installed and open it
#test -e /usr/bin/featherpad && featherpad "/tmp"$MODULENAME"xSystemchanges"$argone
# Not necessary also outputting the system changes to terminal maybe too long
# all options explored and let user customize to their needs
