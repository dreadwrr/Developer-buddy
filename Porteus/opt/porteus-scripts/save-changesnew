#!/bin/bash
#                                               Developer Buddy v3.0  Rsync backup of changes folder  Porteus edition  08/11/2025
# rsync backup to /changes.bak minimal writes as the backup would already be in place. Files are logged and its accurate
# to system specs with --delete. Added drive to drive while this is fast the preferable way is to not use drive to drive
# as it freezes the file system at that point in time. But on shutdown that wait would be too long. So drive to drive provides
# a way to save on that condition. So both options are available depending on preference.
#
# module rollback is a possibility for porteus and could bring that disabled a few options as porteus has changes:EXIT/
#
# Hard drive changes commit   Save files via directory method    Final version 
#
# This script efficiently copies changes to a hard drive for systems with limited memory.
# it uses rsync and includes a log of all files saved. if files havent changed it simply 
# doesnt copy them. Automatically skip .wh.  files and  Direct to drive save.
#
# Result saves your changes to your Changes=EXIT:  folder
#
# This is a proposed change to changes commit with directory method. All original lines are commented out to work with script

# working off of base save-changes scripts by
# Author: fanthom <fanthom@porteus.org>
#
. /usr/share/porteus/porteus-functions
get_colors
. /usr/local/save-changesnew/save-changesnewfnts
# Notes
# Changes commit vars   line 149          this is the main script
# developer buddy  vars         111           this runs after changes commit if BACKUP  true
#


#CHANGABLE					# As changes exit uses changes-commit turn backup on to save a backup /changes.bak/
BACKUP="false"				# Turn on backup feature of Developer buddy 3.0 to hdd on/off           this will run after changes-commit

d2drive="true"                 # default is false   for systems with low memory save directly to drive 
                                        # default is save to memory for staging purposes and convenience of modifying
                                        # ect more versatle and efficient (less writes on hd)

                                        # but systems with low memory may want to use this to avoid any potential
                                        # exceedence 

#d2dmdl="false"					# default false  use harddrive for temp dir for modules
#Future release for Rollback
# But as this is changes=EXIT:/ maybe not as stick to one thing changes=EXIT


target=$BASEDIR                               # change this to specify the location of porteus install this passed from root call where porteus is installed via $BASEDIR
                                                # examples      "/mnt/sda1"
                                                #                   "/dev/sda1"
                                               # avoid trailing /

#Folders to include from changes      adjust if wanted            set tsave-changesnewfntso include changes-exit default folders
IFOLDERS="bin etc home lib lib64 opt root sbin usr var"      
#Folders to exclude from changes            
EXCLUDE="/var/run /var/tmp share/Trash"   #default changes-exit configuration
                                            # keep original format  /var/run    is the base directory var
                                            # seperate with space            anything else other than / will be a pattern *****



#Folders to exclude from changes                                         already set to exclude changes-exit default folders

chxzm="/changes.xzm"            #Module  name  change this if you want to customize the name     
                                 # retain leading / and ensure it ends in .xzm
                                 #avoid trailing / and any spaces
#em="/extramod"                      #change this to save a different folder       the extramod dirtory          disabled for porteus version not required
                                                # retain leading /
                                               # avoid trailing /

logSIZE=35            # Log size limit default 35 MB
                       # Will keep the original contents from when the changes.bak folder was made 
                         # if limit is exceeded. Just clears out old changes to make a new log file

logSPRF="delete"           # When log size limit reached what to do default delete just delete it and create a new one
                            #       with new updated master list.
                            # delete    delete the log to save space and make a new one with new master listi
                            # psv       preserve 25% of the last changes but take into account new changes so
                            #           we are not over 25% of the log max size limit thus we grab 10-15% of the
                            #           most recent changes append new ones to reach the 25% quota
                            #   
                            #           end result preserves the original format and any original master list
                            #
                            # stop      dont log anymore


# Terminal output / feedback
FEEDBACK="false"                # default false     New version 3 feature  scrolling terminal look
                                            # show more verbose feedback from rsync ect in terminal while saving

LOGGING="true"                  # default is true change if you dont want logging



ANALYTICS="true"            # logging must be set to true       default true     or set to false to turn off too much info       
                                        # if false will just output rsync changes
                                        # if it exceeded logSIZE then the original contents when the backup was made is preserved
                                        # and then a new logfile is made then rsync appends any changes during updates until
                                        # the limit is exceeded again.

                                      # If true Will give total space saved if making a complete new backup
                                        # more data in the log file and custom info by this script

                                        # extra stuff like if the log file exceeded logSIZE and a new one is made
                                        # it will list the contents of the ORIGINAL backup, the contents of the current backup
                                        # and list the file differences as well. Then rsync will continue to input changes.
                                        # you also get total MB saved if you had manually backed up the changes folder ect
# End Terminal output
# END CHANGABLE

# V3 core rsync backup on save-changesnew                 See   line  199     for original changes commit script
#VARS
mtmp=/tmp/mtmp$$   
tmp=/tmp/tmp$$                     #temporary directory  leave set
ch=/mnt/live/memory/changes # leave set
trsyncexl=/usr/local/save-changesnew/excld.ini  #  rsync exclude Cache     cache2/*    ect     see for details
exclfiles=/tmp/exfiles.log
UPDATE=/tmp/save.update.tmp

mbyte=1048576
osize=0   # the original size of changes folder to be captured before moving things to /tmp

#booleans
sentinal=""
rlt=""


## Changes commit
# Check if 'changes=EXIT' cheatcode is active and not run from rc.6:
if [[ "$1" != "6" ]]; then
	test -f /mnt/live/tmp/changes-exit || { echo "'changes=EXIT:' cheatcode is not active - exiting..."; exit; }
	# Run as root if not run from rc.6:
	if [[ $(whoami) != "root" ]]; then
		yellow "Please enter root's password below:"
		su - -c "/opt/porteus-scripts/save-changesnew $USER"
		exit
	fi
fi

#Get the username for saving the log file in their   /Downloads   directory
if [[ "$1" != "6" ]]; then # Handle root call
   # We know we are in root but what user is it?
   # Get the user from $1 passed from the user 
   USR=$1 # normal execution of script
else
   USR=$2 # its called from changes commit so just run the backup
fi
if [[ -z "$USR" ]]; then USR="guest"; fi # default user if called as actual root

## Variables:
DEST="$(cat /mnt/live/tmp/changes-exit)"	; NAME="$(basename $DEST)"
MNAME=/mnt/live/memory/images/changes   	; INAME=/mnt/live/memory/images
CHNEXIT_CONF=/etc/changes-exit.conf     	; EXCL=/tmp/save.excl.tmp
SFILES=/tmp/save.sfiles.tmp             	; UPDATE=/tmp/save.update.tmp

#NEW
SFOLDERS=/tmp/save.sfolders.tmp         	; EXFILES=/tmp/save.exfiles.tmp   #holds excluded file list for rsync non regex
EXCLUDED=/tmp/save.excluded.tmp

SVFILES=$MNAME/home/$USR/Downloads/save.sfiles.tmp            #log file
LOGDIR=/home/$USR/Downloads
LOGFILE="save.sfiles.tmp" 
#LOG
#NEW END
if [[ $(grep ".dat" /mnt/live/tmp/changes-exit 2>/dev/null) ]]; then
	Dest="Save.dat file"
else
	Dest="Save folder partition"
fi

if [[ "$1" != "6" ]]; then
	if [[ $(grep ".dat" /mnt/live/tmp/changes-exit 2>/dev/null) ]]; then
		Dest="Save.dat file"
	else
		Dest="Save folder partition"
	fi


	SDspace=$(df -BM -h --output=size,used,avail,pcent /mnt/live/memory/images/changes | tail -n1)
	read size used avail percent <<< "$SDspace"
	cyan "Checking for space in your $Dest .."
	if [[ ${percent%\%} -gt  85 ]]; then
	  echo
	  red "Warning! $Dest $percent full.  Used: $used  Free: $avail"
	  x=5
	  echo
	else
	  echo
	  green "$Dest $percent full.  Used: $used  Free: $avail"
	  echo
	fi

	# Folders to save: argument for `find' & check that they $changesexist.
	FOLDERS="$(grep ^/ $CHNEXIT_CONF | sed s/.//)"
    dycmb


	# Folders to exclude: argument for `egrep'
	grep ^!/ $CHNEXIT_CONF | fixdir > $EXCL  #  has a ^ for egrep

	# only run timeout on shutdown
	if [[ "$1" = "6" ]]; then
		[[ ! $x ]] && x=3
		cyan "Your session will be saved in [1;33m$x seconds[0m"
		yellow  "Press space/enter to start doing it now or any other key to skip."
		while [[ $x -gt 0 ]]; do read -s -t1 -n1 ans && break || sleep 1; let x=x-1; done
	else
		ans=""
	fi

	if [[ "$ans" = "" ]]; then  

		## Save session:
		cyan "Syncing what's left in buffers"
		sync

		# Remount aufs with 'udba=notify' flag:
		mount -o remount,udba=notify /
		cyan "Saving changes to $DEST - this may take a while..."
		cd /mnt/live/memory/changes || exit

	#NEW

		# Handle filenames with spaces.
		IFS="
		"
		
		#
		# file for rsync to read without regex
		#grep '^!/' $CHNEXIT_CONF | sed -e 's/^!//' > $EXFILES
		
		
		# Remove deleted files and non matching whiteouts
		for y in $(find $FOLDERS -name ".wh.*"); do
		  f="$(echo $y | sed 's@\.wh\.@@g')"
		  test -e "$MNAME/$f" && rm -rf "$MNAME/$f";
		  test -e "$INAME/*/$f" || { echo "$y" | fixwh >> $EXCL; echo "$y" >> $EXCLUDED; test -e "$MNAME/$y" && rm -f "$MNAME/$y"; }  
			    #                 ^   changed back to "$INAME/*/$f"       to prevent binary operator expected on empty sym link
		done      

		#  We have  EXCL  regex and        EXFILES   non regex to work with 
		#
		#  This routine can clean up EXCL to work with rsync tested
		#  works. The point of this version is to not have regex for
		#  rsync so all changes are for that reason
		#
		#  sed -i -e 's/\^//' -e 's|\\\.|.|g' -e 's|\]|\]\\|g' $EXCL
		#
		#> $EXFILES
		#cat $EXCL | fixexcl > $EXCLUDED   Original
		 
		# New 5.0 		  
		exldir $EXFILES # generate exclude dirs
	  

		# The purpose of this routine is so we have a file with all folders to save and can use it verify with rsync log that rsync is working
		# or captured all the directories
		# 
		# $EXCL will show all the .wh. files  and $SFOLDERS has all the folders can use to verify
		#
		# Create a manifest of what folders we are saving through EXCL regex
		# Copy new and modified folders -- skip excluded whiteouts and folders and create a folder manifest    
		test -s "$EXCL" && { find $FOLDERS -type d | egrep -vf $EXCL || find $FOLDERS -type d; } > $SFOLDERS   
		
		
		# Note changed from original  we dont need to exclude .wh. as rsync can exclude those 
		#
		# Copy new and modified files -- skip excluded whiteouts and folders
		# { test -s "$EXCL" && find $FOLDERS -not -type d | egrep -vf $EXCL || find $FOLDERS -not -type d; } > $SFILES
		#
		#
		
		#
		#  This routine can clean up EXCL to work with rsync tested
		#  works. The point of this version is to not have regex for
		#  rsync so all changes are for that reason
		#
		#  sed -i -e 's/\^//' -e 's|\\\.|.|g' -e 's|\]|\]\\|g' $EXCL
		#
		
		
		#Send files to drive and exclude from list of what to exclude  ie folders files etc
		#     
		# pattern '\.wh\.*'    excludes any file starting with   .wh.
		#
		
		#Reject old log file in session
		test -e home/$USR/Downloads/"$LOGFILE" && rm home/$USR/Downloads/"$LOGFILE"
		
	    test -s "$EXFILES" && { rsync -av --exclude-from=$EXFILES --exclude '\.wh\.*' $FOLDERS $MNAME; } > $UPDATE || rsync -av --exclude '\.wh\.*' $FOLDERS $MNAME > $UPDATE
		

		#Reject old log file   Depricated
		#test -e "$MNAME$LOGDIR/$LOGFILE" && rm "$MNAME$LOGDIR/$LOGFILE" 

		#Create a log
		BRAND=`date +"MDY_%m-%d-%y-TIME_%R"|tr ':' '_'`
		echo $BRAND >> $UPDATE

		#Do include a log file in case still in session
		cp "$UPDATE" "$MNAME$LOGDIR/$LOGFILE"
		
		
		# subroutine clean out any deleted files   a ..wh..  is a file you deleted and no longer exists
		#
		# the reasoning behind this routine is to clean a drive of any ..wh.. files
		#
		# 
		#find $MNAME -name ".wh.*" -exec rm -r {} \;
		
	#NEW END



	# ORIGINAL commented out to work with changes

		# Copy new and modified files -- skip excluded whiteouts and folders
		# { test -s "$EXCL" && find $FOLDERS -not -type d | egrep -vf $EXCL || find $FOLDERS -not -type d; } > $SFILES
		# cp -uafv --parents $(cat $SFILES) $MNAME > $UPDATE       
		
		   #  Alternative to above to prevent exceeding ARG_MAX  ie too long of command
		   #  > $UPDATE  
		   # cat $SFILES | xargs -I {} cp -aufv --parents {} $MNAME >> $UPDATE    #Can add instead of above

	# ORIGINAL END


		# Remove conflicting whiteouts
		for y in $(find $MNAME -name ".wh.*"); do
			f="$(echo $y | sed -e 's^$MNAME^^g' -e 's^\.wh\.^^g')";
			test -e "$f" && rm "$y";
		done

		# Reset IFS to default
		unset IFS

		#	green "Session saved"       ORIGINAL commented out to work with changes
		cyan "Your changes have been saved. and synced to your system"
		cyan "updates changes to hdd $DEST"
		cyan "A log file is available in Downloads"
		cyan "If you are still in session you wont see this"
		cyan "file until reboot. a copy is in /tmp"
		## End Changes commit
    else
		yellow "Skipping."
	fi
fi

# 
## Developer buddy 3 rsync backup on  changes=EXIT:/porteus    save-changesnew
if [[ "$3" == "yes" ]]; then ans=""; fi # called by changes-commit?
if [[ "$ans" = "" ]]; then
	if [[ "$BACKUP" == "true" ]]; then
		if [[ "$1" == "6" ]]; then  # changes-commit script is calling this script on shutdown so only BACKUP part of this entire script is called
									# as changes-commit has finished may have to renable certain things
			cyan "Backing up on shutdown..."
			target=$4 # the $BASEDIR manually set from changes-commit as blank vars
			FOLDERS="$(for x in $(grep ^/ $CHNEXIT_CONF | sed s/.//); do test -e /mnt/live/memory/changes/"$x" && echo "$x"; done)" 
            dycmb 


				# $EXCLUDE
		else # normal execution of this script

			# residual from above clearing...
			#rm $EXCL     isnt used as not using egrep -vf
			#rm $UPDATE     This is available as a tmp file
			rm $SFOLDERS
			#rm $EXFILES  # We need to reuse this as its already done
			test -e $EXCLUDED && rm $EXCLUDED
			# clear
		fi

		> $EXFILES
		exldir $exclfiles # generate exclude dirs

			
		if [ "$ANALYTICS" == "true" ]; then start=$(date +%s.%N); fi

		#MODULENM="$(echo $chxzm | sed s/.xzm//)"    # parse our module name
		MODULENM="${chxzm%.xzm}"
		mdlnm="${MODULENM#/}"                               # exact module name strips leading /
		emfld="${em#/}"

		#rlt=$( cat /proc/cmdline | sed -n 's/.*changes=\([^ ]*\).*/\1/p') #parse the commandline
		if [ ! -e $target ]; then #If user changed the target and doesnt exist
		    echo "Target does not exist" && exit 0
		fi
		rlt=$(cat /proc/cmdline | sed -n 's/.*changes=EXIT:\([^ ]*\).*/\1/p')
		thetgt=$target
		[[ "$rlt" == *"/dev/"* ]] && rlt=${rlt//dev/mnt}
		[[ "$rlt" == *"$target"* ]] && { rlt=${rlt%/} && target=""; }
		test -e $rlt && if [ "$rlt" != "" ]; then osize=$( du -sb "${target}${rlt}${MODULENM}/" | cut -f1); fi # original size
		if [ "$LOGGING" == "false" ] && [ "$ANALYTICS" == "true" ]; then
		    echo analystics requires logging to be true. && exit 0
		fi
		mkdir $tmp #setup directories     

		if [ "$d2drive" == "false" ]; then
			: > /tmp/incfilter.log
			green "Staging... "
			#copy the changes to /tmp  from developer buddy 3
			for x in $IFOLDERS; do cp -arv $ch/"$x" $tmp &> /dev/null ; done            # Copy what we have  

		else # using direct to drive saving
			#setup directories
			green "Direct to drive saving"

			# Disabled for now
			#if [ "$d2dmdl" == "true" ]; then
			#	test -d $target/tmp && { mkdir $target/tmp$$; tmp=$target/tmp$$; } || { mkdir $target/tmp; tmp=$target/tmp; }
			#	test -d $target/mtmp && mtmp=$target/mtmp$$ || mtmp=$target/mtmp
			#fi

			: > /tmp/incfilter.log
			for folder in $IFOLDERS; do
				echo "+ /$folder/" >> /tmp/incfilter.log
				echo "+ /$folder/***" >> /tmp/incfilter.log
			done
			echo "- /*" >> /tmp/incfilter.log
		fi
		#End temp directories

		# are we in changes mode?        changes=EXIT:/porteus
		if [ "$rlt" != "" ]; then
		    
		    # Disabled not using .zip
		    # we want a changes folder in the .zip
		    #mkdir "/tmp/changes"
		    #mv $tmp/* "/tmp/changes"
		    #cd /tmp
		    #  if [ -d "${target}${rlt}${MODULENM}.zip" ]; then

		    if [ "$rlt" == "/" ]; then
		        rlt=""
		    fi

    		if [ "$d2drive" == "true" ]; then
        		dirSRC="$target$rlt/changes" #using direct to drive our source changes
    		else
        		dirSRC=$tmp # were working in memory
    		fi
    		
		    # is there a changes backup already?
		    if [ -d "${target}${rlt}${MODULENM}.bak/" ]; then

		        # disabled for now as a changes .xzm cant be updated while mounted
		        # so we create new changes modules
		        #
		        #        

		        #chngDIR=$( echo $rlt | sed 

		        #Mount the changes with excluded directories and sync it to drive
		        #mkdir /mnt/loop                          
		        #mount -o loop $target$rlt$chxzm /mnt/loop       #mount changes

		        #rsync -av --delete $tmp /mnt/loop/       #sync changes to hdd --delete tag removes files that were deleted in session

		        #umount /mnt/loop
		        #rm -r /mnt/loop

		        green "Updating existing backup..."
		        if [ "$LOGGING" == "true" ]; then
		            if [ -f "${target}${rlt}${MODULENM}.bak.log" ]; then # There is a logfile
		                m=$(head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -c "STOP") # we dont want to do anything if STOP flag 
		                if (( m == 0 )); then
		                     adtCMD="--log-file=${target}${rlt}${MODULENM}.bak.log" # this comes into play below we log all changes and
		                                                                                                                # are not rebuilding a log
		                    #was paused at some point?    <----
		                    #checking original format first after the original file list
		                    if grep -B 1 'END ORIGINAL FILES' "${target}${rlt}${MODULENM}.bak.log" | tail -2 | head -1 | grep -q '^PAUSED$'; then
		                        
		                        #Resume from pausing
		                        glog # generate new master list. total byte count erased but original byte count kept if any

		                    #Logging as usual
		                    # it could still be original format or not just without PAUSED in that location
		                    #
		                    # but this only comes into play if reached max size limit
		                    else

		                         # Are we resuming from a pause?
		                        # is PAUSED on line 1?
		                        l=$(head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -c "PAUSED")
		                        size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")
		                        # then continue logging
		                        #Check if log filesize is exceeded
		                        # Also if it is exceeded nothing could have changed thus want preserve the original format.
		                        if [ "$size" -gt $((logSIZE * mbyte)) ]; then
		                            if [ "$ANALYTICS" == "true" ]; then
		                                cyan "Log file has hit the limit. Clearing..."
		                            fi

		                            # what mode are win        preserve, delete, or stop???

		                            if [ "$logSPRF" == "delete" ]; then

		                                # Is it original formatting?
		                                # then make a new one as we are deleting the old log
		                                #
		                                if grep -q "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log"; then
		                                   
		                                    # checked if one was already made after resuming from pausing and it wasnt
		                                    # Generate a new one
		                                    glog "true" # generate new master list. total byte count erased but original byte count kept if any
		                                # preserve any custom formatting                        
		                                else
		                                    > "${target}${rlt}${MODULENM}.bak.log" 
		                                fi

		                            #Preserve 25% of older logfile
		                            elif [ "$logSPRF" == "psv" ]; then

		                                # we want to grab the original contents so the new file has it then we make the new file replacing the old log
		                                ###we want to parse the original stats from the log

		                                # it could either have the original stats or not
		                                # so we need to check and then parse. We are clearing old change logs and are now continue as usual as nothing
		                                # has changed.

		                                c=$( wc -l < "${target}${rlt}${MODULENM}.bak.log") # total count
		                                q=$(awk "BEGIN {print $c * 0.85}")
		                    

		                                # may want to adjust this mode so comments left for convenience

		                                # the user wants a different style of log with only the changes
		                                if (( l == 1 )); then
		                                    # start at 85% to end of file most recent changes
		                                    sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE

		                                # original formatting                             
		                                else

		                                    # on the fly grabbing
		                                    #lc of END ORIGINAL FILES 
		                                    # grab the next 14 lines and append
		                                   # END on the fly grabbing

		                                    h=$( grep -m 1 -n "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log" | awk -F: '{print $1}') # what line is it on
		                                    b=$(( h + 16 ))
		                        
		                                    # we know it resembles original format
		                                    if [ "$h" !=  "" ]; then

		                                        # original format
		                                        if [[ $b -le $c ]]; then
		                                          
		                                                #What if we are reaching for something thats not therE?
		                                            if sed -n "$(( h + 16))p" "${target}${rlt}${MODULENM}.bak.log" | grep -q "total size is"; then
		                                                sed "${b}q" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE # grab up to line plus 16
		                                            # format has been changed
		                                            else
		                                                 sed '/END ORIGINAL FILES/q' "${target}${rlt}${MODULENM}.bak.log" > $UPDATE # grab everything up to END ORI..
		                                            fi

		                                        # not original format
		                                        else
		                                            # format could be slightly off grab up to END ORIGINAL ...
		                                            sed '/END ORIGINAL FILES/q' "${target}${rlt}${MODULENM}.bak.log" > $UPDATE # grab everything up to END ORI..
		                                        fi

		                                        # start at 85% to end of file most recent changes
		                                        sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" >> $UPDATE

		                                    # Not original formatting
		                                    else
		                                        # we would add our check here to delete paused from line 1 but since we are making a new log its taken care of
		                                        #if (( l >= 1 )); then
		                                            #sed '1s/PAUSED//g' "${target}${rlt}${MODULENM}.bak.log"
		                                            #sed -i '1{/^PAUSED$/d}' "${target}${rlt}${MODULENM}.bak.log" 
		                                            #sed -i '1{/^PAUSE/d}' "${target}${rlt}${MODULENM}.bak.log" # resuming logging so delete paused from line 1
		                                        #fi
		                                        # start at 85% to end of file most recent changes
		                                        sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
		                                    fi
		                                fi
		                                if [ "$ANALYTICS" == "true" ]; then
		                                    size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")
		                                    if (( size > logSIZE * mbyte )); then
		                                        cyan "Log size limit reached on preserve mode. Please adjust max limit or logging preference." 
		                                        cyan "This means the file list is greater than the limit or the limit is too small."
		                                    fi                                    
		                                fi
		                                # copy the preserved content 
		                                cp $UPDATE > "${target}${rlt}${MODULENM}.bak.log"
		                                rm $UPDATE
		                            elif [ "$logSPRF" == "stop" ]; then
		                                adtCMD="" # Dont log any further
		                                if [ "$ANALYTICS" == "true" ]; then
		                                    cyan "Log file hit max limit not logging..."
		                                fi
		                                # we have to stop it from repeatedly bouncing off max size limit
		                                if (( l >= 1 )); then
		                                    sed -i '1s/PAUSED/PAUSEDSTOP/g' "${target}${rlt}${MODULENM}.bak.log"
		                                else
		                                    sed -i '1i STOP' "${target}${rlt}${MODULENM}.bak.log"
		                                fi
		                            fi
		                        fi  
		                        # End log size check
		                    fi
		                    # done adtCMD is not null so continue logging as usual covering two possible formats so if its custom format remove first line with pause
		                    # on original format a new master list is generated and this removes the PAUSE above END ORIGINAL FILES
		                    # custom format removal
		                    # Resume logging on other format as STOP is not there and PAUSE is delete the line
		                    if (( l >= 1 )); then sed -i '0,/PAUSE/ { /PAUSE/ d }' "${target}${rlt}${MODULENM}.bak.log"; fi
		                fi
		                # its on stopped
		                # adtCMD is null so not logging any further
		            # No log file or the log file is missing
		            else
				        nsize=$osize # new original size (has changed from the original)
				        green "There was no logfile generating..." ; > "${target}${rlt}${MODULENM}.bak.log"
						dlog  # main log checks d2d ect
						echo >> "${target}${rlt}${MODULENM}.bak.log"
						echo "original size(source)=Unkown" >> "${target}${rlt}${MODULENM}.bak.log"
						echo "new size(source)=$nsize" >> "${target}${rlt}${MODULENM}.bak.log"
						echo  "END ORIGINAL FILES $(date +"%m-%d-%y_%R")" >> "${target}${rlt}${MODULENM}.bak.log"
						#echo >> "${target}${rlt}${MODULENM}.bak.log"
						nLOG="true"
		            fi
		            # user may have had this set to true and then turned this setting off thus we have to erase the total byte count if its in the logfile
		            #if [ "$ANALYTICS" == "false" ]; then
		                # remove the byte count
		            #    sed -i '/total count=[0-9]\+/d' "${target}${rlt}${MODULENM}.bak.log" # remove any count because we cant keep track of it further for now
		            #fi
		        else # Not logging  check if we need to update a flag in the log from a changed setting
		            # we dont want to delete any logs because thats valuable info
		            if [ -f "${target}${rlt}${MODULENM}.bak.log" ]; then
		                #Append PAUSE to log?
		                # not original format?
		                if ! grep -B 1 'END ORIGINAL FILES' "${target}${rlt}${MODULENM}.bak.log" | tail -2 | head -1 | grep -q '^PAUSED$'; then
		                    # has part of original format?
		                    if grep -q "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log"; then
		                        #insert it
		                        sed -i "/END ORIGINAL FILES/ i\PAUSED" "${target}${rlt}${MODULENM}.bak.log" # Put PAUSED above END OF ORIGINAL FILES
		                
		                        # first check if original count is there. Used if on resume pause generate a new master list ie delete mode to keep track of  bytes sent of all time for analytic purposes
		                        #if ! grep -q "original count=" "${target}${rlt}${MODULENM}.bak.log"; then sed '0,/total count=[0-9]\+/s//original count=&/' "${target}${rlt}${MODULENM}.bak.log"; fi

		                        # remove the byte count as we cant keep any track of further updates at this point
		                        #sed -i '/total count=[0-9]\+/d' "${target}${rlt}${MODULENM}.bak.log" # remove any count 

		                        
		                    else # has custom user format  
		                       
		                        if ! head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -q 'PAUSED'; then #put PAUSED on line 1 check if STOP is on there???
		                            if head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -q 'STOP'; then
		                                sed -i '1{/STOP/ s/^/PAUSED/}' "${target}${rlt}${MODULENM}.bak.log" # Put PAUSED before STOP
		                            else
		                                  sed -i '1i PAUSED' "${target}${rlt}${MODULENM}.bak.log" # Insert PAUSED on line 1
		                            fi
		                        fi
		                    fi
		                fi
		            fi
		        fi
		        # What if the user deleted files on the source rsync will not delete them from the destination
		        # while we could delete all non empty directories on the destination that are empty on the source
		        # ourselves. This is inheritly risky. A number of things could fail. Bad idea. The code to do this is below
		        #    src="/path/to/source"
		        #    dest="/path/to/destination"

		            # Safety check
		        #    if [[ -z "$src" || -z "$dest" ]]; then
		        #        echo "Source and destination must be set."
		        #        exit 1
		        #    fi
		       #     find "$src" -type d | while IFS= read -r srcdir; do
		                # Get relative path (handle case if src does not end with /)
		       #         relpath="${srcdir#$src}"
		       #         relpath="${relpath#/}"  # remove leading slash if present

		       #        destdir="$dest/$relpath"

		       #         if [ -d "$destdir" ]; then
		       #             if [ -z "$(ls -A "$srcdir")" ] && [ -n "$(ls -A "$destdir")" ]; then
		       #                 echo "Deleting: $destdir (empty in source, not empty in dest)"
		       #                 rm -rf "$destdir"
		       #             fi
		       #         fi
		       #     done
		        # we need rsync to log everything which appends to the log file
		        if [ "$adtCMD" != "" ]; then

		            # change var/run and var/tmp or add to it to exclude directories
		            if [ "$FEEDBACK" != "true" ]; then
		               	rsync -aH --delete --filter="merge /tmp/incfilter.log" --delete-excluded --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" $adtCMD  #sync changes to hdd --delete tag removes files that were deleted in session
		            else
		                rsync -aHv --delete --filter="merge /tmp/incfilter.log" --delete-excluded --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" | tee -a "${target}${rlt}${MODULENM}.bak.log"
		            fi
					exc=$?
				    if [ $exc -eq 1 ]; then
						# Remount aufs with 'udba=none' flag:
						mount -o remount,udba=none /
						red "rsync failed — check log at ${target}${rlt}${MODULENM}.bak.log"
						if [ "$d2drive" == "false" ]; then
							cyan "Files left in memory. Copy and paste the following to rsync again:"
							echo "rsync -aH --delete --filter=merge /tmp/incfilter.log --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/ --log-file=${target}${rlt}${MODULENM}.bak.log"
							if [ "$ANALYTICS" == "true" ]; then
								echo "Then check the logfile for any errors.Then take the last two bytes sent and add it to total count=  at the top of the file if you want to keep exact track."
								echo "Or"
								printf 'rsync -aHv "%s" newdirectory/\tto make a new backup\n' "${target}${rlt}${MODULENM}/"   
							fi
						else
				  		    if [ "$ANALYTICS" == "true" ]; then
								echo "Add up the last bytes sent values and add to total count=  at the top of the file before END ORIGINAL FILES.  if you want to keep exact track."
							fi
						fi                                                         
						#rm -rf $tmp      #delete temporary files
						exit 1
					elif [ $exc -eq 24 ]; then
						cyan "Some files have vanished. Check for excluding cache files"
						sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
					fi
		        else # we need rsync to log only essential stats and any errors which appends to the log file
		            # if we just created a logfile we need this data from --stat
		            if [ "$nLOG" != "" ]; then
		                if [ "$FEEDBACK" != "true" ]; then                                                                                                                                                                                                       # -v  2>&1 | tee "$UPDATE
		                    rsync -aH --stats --delete --filter="merge /tmp/incfilter.log" --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" > $UPDATE 2>&1  # capture the log in a sentinal
		                else
		                    rsync -aH --stats --delete --filter="merge /tmp/incfilter.log" --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" 2>&1 | tee $UPDATE
		                fi
		                #sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" >> "${target}${rlt}${MODULENM}.bak.log"
		                #sed '/END ORIGINAL FILES/q' "${target}${rlt}${MODULENM}.bak.log" > $UPDATE # grab everything up to END ORI..
		                # used to use this but we dont want any error messages messing up the formatting of out log                                                                                                                                             
		               #rsync -a --stats --delete --exclude-from=$exclfiles --exclude-from=$trsyncexl $tmp/ "${target}${rlt}${MODULENM}.bak/" >> "${target}${rlt}${MODULENM}.bak.log" 2>&1
		                #echo >> "${target}${rlt}${MODULENM}.bak.log"
		            # the user is not logging            
		            else
		                if [ "$FEEDBACK" != "true" ]; then
		                    rsync -aH --delete --filter="merge /tmp/incfilter.log" --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" > /dev/null
		                else
		                    rsync -aH --delete --filter="merge /tmp/incfilter.log" --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/"
		                fi
		            fi
					exc=$?
				    if [ $exc -eq 1 ]; then
						# Remount aufs with 'udba=none' flag:
						mount -o remount,udba=none /
						red "rsync failed — check log at ${target}${rlt}${MODULENM}.bak.log"
						if [ "$nLOG" != "" ]; then
							if [ "$d2drive" == "false" ]; then
								cyan "Files left in memory. Copy and paste the following to rsync again:"
						    	echo "rsync -aH --stats --delete --filter=merge /tmp/incfilter.log --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/ --log-file=${target}${rlt}${MODULENM}.bak.log"
							fi
							if [ "$ANALYTICS" == "true" ]; then
						       echo "Then check the logfile for any errors. Add up all the bytes sent values and put total count=  at the top of the file before END ORIGINAL FILES.  if you want to keep exact track."
						    fi
						else # Not logging
							echo "rsync -aH --delete --filter=merge /tmp/incfilter.log --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/"
						fi
						
						echo
						echo "Or failing that"
						printf 'rsync -aHv "%s" newdirectory/\tto make a new backup\n' "${target}${rlt}${MODULENM}/"  

						#rm -rf $tmp       #delete temporary files
						exit 1
				    elif [ $exc -eq 24 ]; then
						cyan "Some files have vanished. Check for excluding cache files"
						sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
					fi
		            if [ -s $UPDATE ]; then
		                c=$( wc -l < "$UPDATE") # total count
		                if (( c > 17)); then sentinal="true"; cp $UPDATE /tmp/parity.txt; fi
		                sed -n '/Number of files/,$p' $UPDATE >> "${target}${rlt}${MODULENM}.bak.log"
		            fi
		        fi

		        cyan "Changes backup has been updated."

		        if [ "$ANALYTICS" == "true" ]; then ## We could be logging or not so we need to find out which regardless we need to total bytes sent because analytics is true
		        

		            # We need to grab the original count if present
		            # then add to it with the most recent sent bytes
		            #

		            ## write analystic script here    #
		            # filesize=$(stat -c %s "$filename")
		            #osize=$(du -sb "${target}${rlt}${MODULENM}/" | cut -f1) #original size

		            # *** this could be different
		            ossize=$( sed -nE 's/.*original size\(source\)=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log) # the original bytes of changes folder
		            if [ "$ossize" == "" ]; then
		                oput="Unkown"
		            else   
		                oput="$(( ossize / mbyte )) MB"
		            fi

		            csize=$(du -sb "${target}${rlt}${MODULENM}.bak/" | cut -f1) # actual backup size
		            nsize=$osize       

		            # the user hasnt changed settings from when backup made   ie analytics were already in place so we can pull data
		            #if [ -z "${nOPT}" ]; then

		            c=$( sed -nE 's/.*total count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log) # the current saved bytes for the current backup
		            c="${c:-0}" #if c is not there set it to 0

		            # if a new log was generated we need to parse the new byte count
		            if [ "$adtCMD" != "" ]; then
		                z=$( tail -n1 ${target}${rlt}${MODULENM}.bak.log | grep -oP '(?<=sent\s)\d+(?=\s+bytes)' | head -n1) # parse from a current log with file changes
						if (( z == 0 )); then z=$(tail -n 20 ${target}${rlt}${MODULENM}.bak.log | grep -oP '(?<=sent\s)[\d,]+' | tail -n 1 | sed 's/,//g'); fi  # If on FEEDBACK
		            elif [ "$adtCMD" == "" ] && [ "$nLOG" == "true" ]; then
		                if [ "$ANALYTICS" ==  "true" ]; then                
		                    green "A new log file has been made."
		                fi
		                #we need to parse differently as the end of the file is different
		                ###z=$( grep "Total bytes sent:" "${target}${rlt}${MODULENM}.bak.log" | sed -E 's/[^0-9]*([0-9,]+).*/\1/' | tr -d ',')
		                z=$( tail -n2 ${target}${rlt}${MODULENM}.bak.log | head -n1 | grep -oP '(?<=sent\s)[\d,]+' | tr -d ',' )
		                #z=$( tac ${target}${rlt}${MODULENM}.bak.log | grep -m1 'sent' | grep -oP '(?<=sent )[\d,]+(?= bytes)') # parse from standard new log format
		            fi

		            r=$(( c + z ))  # our new count

		            # replace the total count with the new one or insert it
		            grep -q "total count=" "${target}${rlt}${MODULENM}.bak.log" && sed -i "s/total count=[0-9]\+/total count=$r/" ${target}${rlt}${MODULENM}.bak.log || sed -i "/END ORIGINAL FILES/ i\total count=$r" "${target}${rlt}${MODULENM}.bak.log"
		           

		            # If it was paused and logging as usual and original format
		            c=$( sed -nE 's/.*original count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log) # the original saved bytes over time for statistics
		            c="${c:-0}" #if c is not there set it to 0
		            if (( c != 0 )); then
		                cyan " Since the original backup was first made sent" $(( ( c + z ) / mbyte )) "MB worth of data"    # although not accurate as something could of been done with logging paused this keeps track of all bytes
		                                                                                                                                        # and is a usecase if the user is in preserve mode on max log size this holds true as well as resuming from
		                                                                                                                                        # from logging on original format as we generate a new master list and grab any original bytes. So we use cyan
		                                                                                                                                        # as its just stats.
		            fi

		            # if [ -z "${csize+set}" ]; then
		           

		            # if the new logfile is greater than the limit give a suggestion
		            if [ "$logSPRF" != "stop" ] && [ "$nLOG" == "true" ]; then
		                size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")
		                if (( size > logSIZE * mbyte )); then
		                red "New log file made is greater than the limit. adjust if needed to keep log data on next backup."
		                fi
		            fi
		    

		            cyan "You have sent $(( r / mbyte )) MB worth of data to the ${target}${rlt}${MODULENM}.bak/ backup" # green because its accurate
		            green "Sent $(( z / mbyte )) MB to backup. "

		            #fi
		            
		            # a setting was changed and a new logfile was made thus we have no total count and would error our analytics math above or it would be 0 and inaccurate
		            #else
		                # append before END ORIGINAL FILES
		                # see Line 214
		                #echo "total count=$csize" >> "${target}${rlt}${MODULENM}.bak.log"          #  <---------        but we dont know this yet

		                #sed -i "/END ORIGINAL FILES/ i\total count=$r" "${target}${rlt}${MODULENM}.bak.log"
		                #sed -i "/END ORIGINAL FILES/ {n; r /dev/stdin" -e '}' "${target}${rlt}${MODULENM}.bak.log" <<< "total count=$csize"
		                #echo
		            #fi
		            echo
		            if  [ "$adtCMD" != "" ] && [ "$nLOG" == "true" ]; then
		                cyan "Size of source when backup first made: $oput"
		                green "Current size of source: $(( osize / mbyte ))"
		            fi
		            

		            green "Current size of backup: $(( csize / mbyte )) MB"         #actual size of backup
		    
		            if [ "$nLOG" == "true" ]; then            
		                echo
		                cyan "You saved $(( (nsize - csize) / mbyte )) MB by generating this backup."
		            fi
		            end=$(date +%s.%N)
		            el=$(awk "BEGIN {print $end - $start}")
		            printf "Saving took %.3f seconds.\n" "$el"
		            if [ "$sentinal" == "true" ]; then
		                rm $UPDATE
		                echo -e "\nYou are seeing this message as you have most likely deleted an entire directory on the source."
		                echo "rsyan will not remove a non empty directory on the backup that is empty on the source for safety reasons."
		                echo " check parity.txt in /tmp to see what these directories are and delete them in the backup."
		            fi
		            ###Output the data saved creating the new source backup
		        fi

		        # Disabled for now
		        #zip -r -FS $target$rlt$MODULENM".zip" "/tmp/changes" -x "/tmp/changes/var/run/*" -x "/tmp/changes/var/tmp/*" > $target$rlt"/changeslog" 2>&1            #log everything
		        #zip -q -r -FS "$target$rlt$MODULENM.zip" "changes" -x "var/run/*" -x "var/tmp/*" > /dev/null 2>> "$target$rlt/changeslog"   #only errors

		        #if [ ! -s "$target$rlt/changeslog" ]; then
		        #    echo "no errors in changes.zip" >> "$target$rlt/changeslog"
		        #fi

		        # Check exit code
		        #exitcode=$?
		        #if [ $exitcode -ne 0 ]; then
		        #    echo "Error: zip failed with code $exitcode" >&2
		        #    echo "Check the log file for details: $target$rlt/changeslog" >&2
		          
		            #cleanup
		        #    rm -rf /tmp/changes
		        #    rm -rf $tmp       #delete temporary files
		        #    exit $exitcode
		        #fi

		        
		    # create new 
		    else
				mkdir ${target}${rlt}${MODULENM}.bak 
		        # Disabled for now as .xzm cant be altered in place 
		        #make the module    add to -e   adjust if wanted excluded directories
		        #mksquashfs $tmp $target$rlt$chxzm -e var/run var/tmp
		        #xzm2dir $target$chxzm $target/tmp        #extract xzm 
		        
		        cyan "Creating new backup this may take a few minutes."

		        if [ $LOGGING == "true" ]; then # generate log file  
						dlog
						# we need to get only the the included folders from the new source drive
						# the source drive may have more directories that arent in $FOLDERS
						echo "original size(source)=$osize" >> "${target}${rlt}${MODULENM}.bak.log"            
						echo "END ORIGINAL FILES" >> "${target}${rlt}${MODULENM}.bak.log"

				        # we need rsync to log which appens to the log file
				        #adtCMD="--log-file=${target}${rlt}${MODULENM}.bak.log" 
				        #adtCMD="--stats >> ${target}${rlt}${MODULENM}.bak.log" 2>&1
		        else
		            #add the PAUSED flag
		            #sed -i "/END ORIGINAL FILES/ i\PAUSED" "${target}${rlt}${MODULENM}.bak.log"
		            # remove any old log file 
		            #
		            test -f "${target}${rlt}${MODULENM}.bak.log" && rm "${target}${rlt}${MODULENM}.bak.log"

		        fi

		        # change var/run and var/tmp or add to it to exclude directories you dont want
		        if [ "$FEEDBACK" != "true" ]; then   
		            rsync -aH --stats --filter="merge /tmp/incfilter.log" --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" >> "${target}${rlt}${MODULENM}.bak.log" 2>&1
		        else
		            rsync -aHv --stats --delete --filter="merge /tmp/incfilter.log" --delete-excluded --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" | tee -a "${target}${rlt}${MODULENM}.bak.log"
		        fi
				exc=$?
				if [ $exc -eq 1 ]; then
				    # Remount aufs with 'udba=none' flag:
				    mount -o remount,udba=none /
				    red "rsync failed — check log at ${target}${rlt}${MODULENM}.bak.log"
				    cyan "Please check the logfile if its a valid backup or try again."
				    cyan "failing that delete the backup and try again."
				    rm -rf $tmp       #delete temporary files
				    exit 1
				elif [ $exc -eq 24 ]; then
					cyan "Some files have vanished. Check for excluding cache files"
					sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
				fi
		       
		        # Disabled for now
		        #zip -r $target$rlt$MODULENM".zip" "/tmp/changes" -x "/tmp/changes/var/run/*" -x "/tmp/changes/var/tmp/*" > $target$rlt"/changeslog" 2>&1                  #log everything
		        #zip -q -r "$target$rlt$MODULENM.zip" "changes" -x "var/run/*" -x "var/tmp/*" > /dev/null 2>> "$target$rlt/changeslog"    #log errors

		        #if [ ! -s "$target$rlt/changeslog" ]; then
		        #    echo "no errors in changes.zip" >> "$target$rlt/changeslog"
		        #fi

		        # Check exit code
		        #exitcode=$?
		        #if [ $exitcode -ne 0 ]; then
		        #    echo "Error: zip failed with code $exitcode" >&2
		        #    echo "Check the log file for details: $target$rlt/changeslog" >&2

		            #cleanup
		        #    rm -rf /tmp/changes
		        #    rm -rf $tmp       #delete temporary files
		        #    exit $exitcode
		        #fi

		        cyan "Your changes backup has been created! in ${target}${rlt}/"
		        cyan "${MODULENM}.bak/"        
		        #cyan $MODULENM".zip"
		        #cyan $chxzm

		        if [ "$ANALYTICS" == "true" ]; then
		             # filesize=$(stat -c %s "$filename")
		            #This is for terminal output on MB saved during creation of backup
		            csize=$( du -sb "${target}${rlt}${MODULENM}.bak/" | cut -f1) # backup size
		            tsize=$(( osize - csize ))
		            
		            # insert the total bytes sent
		            #z=$( tac ${target}${rlt}${MODULENM}.bak.log | grep -m1 'sent' | grep -oP '(?<=sent )[\d,]+(?= bytes)') # parse from standard new log format
		            z=$( grep "Total bytes sent:" "${target}${rlt}${MODULENM}.bak.log" | sed -E 's/[^0-9]*([0-9,]+).*/\1/' | tr -d ',')
		            sed -i "/END ORIGINAL FILES/ i\total count=$z" "${target}${rlt}${MODULENM}.bak.log" #insert the total byte count
		    
		            green "You have sent $(( z / mbyte )) MB worth of data so far to the ${target}${rlt}${MODULENM}.bak/ backup"
		            cyan "You saved $(( tsize / mbyte )) MB by creating this backup"
		        fi

		        echo
		        ## we need to make sure this is correct
		       # if [ ! -z "${csize}" ]; then
		        
		       # fi
		    fi
		fi
    	test -e $EXCLUDED && rm $EXCLUDED	# temporary holding  
		rm -rf $tmp	#delete temporary files   
			
	fi # backup true?
	if [[ "$1" != "6" && "$3" != "yes" ]]; then # normal execution of this script
		# Remount aufs with 'udba=none' flag:
		mount -o remount,udba=none /
		
		#cleanup
		#test -e $EXFILES && rm $EXFILES	# commit script
		test -e $UPDATE && rm $UPDATE	# temporary holding
		
		rm $EXCL		# parsing rsync 
		#rm $exclfiles	# rsync exclusion list	
		
		#Remove /mnt/live/tmp/changes-exit if called from rc.6 (temporary for legacy initrd where cleanup still has changes=EXIT: routine)
		[[ "$1" == "6" ]] && rm /mnt/live/tmp/changes-exit
	fi
fi # yes answer
