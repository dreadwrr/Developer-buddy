#!/bin/bash
#                                               Developer Buddy v3.0  Rsync backup of changes folder  Porteus edition  08/11/2025
# rsync backup to /changes.bak minimal writes as the backup would already be in place. Files are logged and its accurate
# to system specs with --delete. Added drive to drive while this is fast the preferable way is to not use drive to drive
# as it freezes the file system at that point in time. But on shutdown that wait would be too long. So drive to drive provides
# a way to save on that condition. So both options are available depending on preference.
#
# module rollback is a possibility for porteus and could bring that disabled a few options as porteus has changes:EXIT/
#
# Hard drive changes commit   Save files via directory method    Final version
#
# This script efficiently copies changes to a hard drive for systems with limited memory.
# it uses rsync and includes a log of all files saved. if files havent changed it simply
# doesnt copy them. Automatically skip .wh.  files and  Direct to drive save.
#
# Result saves your changes to your Changes=EXIT:  folder
#
# This is a proposed change to changes commit with directory method. All original lines are commented out to work with script

# working off of base save-changes scripts by
# Author: fanthom <fanthom@porteus.org>
#
. /usr/share/porteus/porteus-functions
get_colors
. /usr/local/save-changesnew/save-changesnewfnts
## Changes commit
# Check if 'changes=EXIT' cheatcode is active and not run from rc.6:
if [[ "$1" != "6" ]]; then if [[ $(whoami) != "root" ]]; then yellow "Please enter root's password below:" ; su - -c "/opt/porteus-scripts/save-changesnew $USER" ; exit ; fi ; fi
if [[ "$1" == "6" ]]; then theUSER="$2" ; thetgt="$4" ; else theUSER="$1" ; if [ -z "$theUSER" ]; then theUSER="guest" ; fi ; fi # Handle actual root call
if [ -z "$thetgt" ]; then thetgt=$BASEDIR; fi     # <----- ie   /mnt/sda3   some root environments are null 
# Notes
# Changes commit vars   line 173          this is the main script
# developer buddy  vars         160           this runs after changes commit if BACKUP  true
#


#CHANGABLE					# As changes exit uses changes-commit turn backup on to save a backup /changes.bak/
BACKUP="false"				# Turn on backup feature of Developer buddy 3.0 to hdd on/off           this will run after changes-commit

d2drive="true"                 # default is false   for systems with low memory save directly to drive
                                        # default is save to memory for staging purposes and convenience of modifying
                                        # ect more versatle and efficient (less writes on hd)

                                        # but systems with low memory may want to use this to avoid any potential
                                        # exceedence

d2dmdl="false"					# default false  use harddrive for temp dir for modules Not changes exit


grubln=""                                     # default null. Point to the line number linux /boot/syslinux/vmlinuz from=/dev/nvme0n1p4 root=UUID=... to automatically update grub for graphics extramod to boot with changes
bootdvc=""		                              # default null.  if booting from another harddrive for bootloader   ie   /mnt/sdc1   porteus bootloader        or      where grub2 is installed  example /mnt/nvme0n1p8

target=$thetgt                               # change this to specify the location of porteus install this passed from root call where porteus is installed via $BASEDIR
                                                # examples      "/mnt/sda1"
                                                #                   "/dev/sda1"
                                               # avoid trailing /

#Folders to include from changes      adjust if wanted            set tsave-changesnewfntso include changes-exit default folders
IFOLDERS="bin etc home lib lib64 opt root sbin usr var"
#Folders to exclude from changes
EXCLUDE="/var/run /var/tmp share/Trash"   #default changes-exit configuration
                                            # keep original format  /var/run    is the base directory var
                                            # seperate with space            anything else other than / will be a pattern *****



#Folders to exclude from changes                                         already set to exclude changes-exit default folders

chxzm="/changes.xzm"            #Module  name  change this if you want to customize the name
                                 # retain leading / and ensure it ends in .xzm
                                 #avoid trailing / and any spaces
em="/extramod"                      #change this to save a different folder       the extramod dirtory          disabled for porteus version not required
                                                # retain leading /
                                               # avoid trailing /

cmode="gzip"                            # default nothing. uses gzip compression level balanced
                                           # xz        best compression
                                           # zstd     faster bootup
                                            # lzo      faster bootup

logSIZE=35            # Log size limit default 35 MB
                       # Will keep the original contents from when the changes.bak folder was made
                         # if limit is exceeded. Just clears out old changes to make a new log file

logSPRF="delete"           # When log size limit reached what to do default delete just delete it and create a new one
                            #       with new updated master list.
                            # delete    delete the log to save space and make a new one with new master listi
                            # psv       preserve 25% of the last changes but take into account new changes so
                            #           we are not over 25% of the log max size limit thus we grab 10-15% of the
                            #           most recent changes append new ones to reach the 25% quota
                            #
                            #           end result preserves the original format and any original master list
                            #
                            # stop      dont log anymore

mdllmt=3                             # Auto Graphics mode module merging default 7
                                                # when reached will automatically merge if mrgMODULES is set to true below
                                                # see mrgMODULES boolean
linkedLOGPRF="incr"          # default incr  new log of only changes keeps log size down
                                            # full log from creation all files and then append changes
                                            # no      dont log the linked module

# CHANGABLE BOOLEANS
linkedSTATE="true"             #This is precendence for changes:EXIT only on graphics mode. Default false
                                           # This implies that you want changes made INCLUDING deletes to another
                                           # modules in /tmp for now. We do this to prove that its working so everything
                                           # is still done the same just you have a module with deletions included in /tmp
                                           #
                                           # linked state needs all changes modules to be created together thus you should
                                           # start with one that has linkedSTATE made. A byte count of this .xzm is made
                                           # and logged into a txt file by the modules.
                                           #
                                           # This text file will tell it are those candidates for Changes:EXIT/ and where to stop
                                           # ect.
keepLINKEDMRGED="false"  # default is false so delete the old ones after merging if they are not in sync with each other
                                           # it automatically renames the old one to .bak. ****
# Non linked state options
mrgMODULES="false"           # Automatically merge changes modules if over limit value
                                        #change this to automatically merge changes.xzm modules  ( applies to Graphics mode)
                                        # see $BASEDIR/extramod for mergemodule script to merge changes modules

keepMRGED="false"       # default is false so delete the old ones after merging
# End Non linked state options

# Terminal output / feedback
FEEDBACK="false"                # default false     New version 3 feature  scrolling terminal look
                                            # show more verbose feedback from rsync ect in terminal while saving

LOGGING="true"                  # default is true change if you dont want logging



ANALYTICS="true"            # logging must be set to true       default true     or set to false to turn off too much info
                                        # if false will just output rsync changes
                                        # if it exceeded logSIZE then the original contents when the backup was made is preserved
                                        # and then a new logfile is made then rsync appends any changes during updates until
                                        # the limit is exceeded again.

                                      # If true Will give total space saved if making a complete new backup
                                        # more data in the log file and custom info by this script

                                        # extra stuff like if the log file exceeded logSIZE and a new one is made
                                        # it will list the contents of the ORIGINAL backup, the contents of the current backup
                                        # and list the file differences as well. Then rsync will continue to input changes.
                                        # you also get total MB saved if you had manually backed up the changes folder ect
                                       
ANALYTICSECT="true"			# Show more info time ect.
# End Terminal output

# Backup mode Not changes exit
ROLLBCK="false"                       # backup module after merged to be able to "rollback" by loading any single module
 			 							# A module that has been merged is saved and moved to /archive/
										# takes up more space
ROLLSUMRY="false"           # default false    Include file manifest for archives
archLMT=4                        # how many unique roll backs to keep  both _uid_ and _uid_L seperately
# END CHANGABLE

# V3 core rsync backup on save-changesnew                 See   line  323    for original changes commit script
#VARS
mtmp=/tmp/mtmp$$                    							;	tmp=/tmp/tmp$$                     #temporary directory  leave set
ch=/mnt/live/memory/changes 								;	trsyncexl=/usr/local/save-changesnew/excld.ini  #  rsync exclude Cache     cache2/*    ect     see for details
UPDATE=/tmp/save.update.tmp								;	SFOLDERS=/tmp/save.sfolders.tmp
exclfiles=/tmp/exfiles.log										;	oMF=/tmp/flog.log	#original module name list used for merging
QEXCL=/tmp/squashexfiles.log								;	EXCLUDED=/tmp/save.excluded.tmp
mbyte=1048576													;	osize=0   # the original size of changes folder to be captured before moving things to /tmp
USR=$theUSER
rname=""														        ;	adtCMD=""	
sentinal=""														    ;	MODULENM=""
#booleans
rlt=""

## Variables:
DEST="$(cat /mnt/live/tmp/changes-exit >/dev/null 2>&1)"		; 	NAME="$(basename "${DEST:-}")"
MNAME=/mnt/live/memory/images/changes							; 	INAME=/mnt/live/memory/images
CHNEXIT_CONF=/etc/changes-exit.conf									; 	EXCL=/tmp/save.excl.tmp
SFILES=/tmp/save.sfiles.tmp													;	UPDATE=/tmp/save.update.tmp
LOGDIR=/home/$USR/Downloads											;	LOGFILE="save.sfiles.tmp"
SVFILES=$MNAME/home/$USR/Downloads/save.sfiles.tmp		;	EXFILES=/tmp/save.exfiles.tmp   #holds excluded file list for rsync non regex
#LOG
#NEW END
# Graphics Not changes=EXIT:/ mode  <---
MODULENM="${chxzm%.xzm}"
mdlnm="${MODULENM#/}"
emfld="${em#/}"
rlt=$(sed -n 's/.*changes=\([^ ]*\).*/\1/p' /proc/cmdline)
if [[ -z "$rlt" ]] && [[ "$1" != "6" ]]; then
	if [ "$ANALYTICS" == "true" ]; then start=$(date +%s.%N); fi
	IFOLDERS="$(for x in $(grep ^/ $CHNEXIT_CONF | sed s/.//); do test -e /mnt/live/memory/changes/"$x" && echo "$x"; done)"
	dycmb
	msr=${target}${em}"/lscheck"

	exldir $exclfiles
	sync
	mount -o remount,udba=notify /
	
	if [ "$d2drive" == "false" ] || { [ "$d2drive" == "true" ] && [ "$d2dmdl" == "false" ]; } ; then
		mkdir $tmp
    	green "Staging... "
	else
		green "Direct to drive saving on d2dmdl"
		test -d $thetgt/tmp && { mkdir $thetgt/tmp$$; tmp=$thetgt/tmp$$; } || { mkdir $thetgt/tmp; tmp=$thetgt/tmp; }
		test -d $thetgt/mtmp && mtmp=$thetgt/mtmp$$ || mtmp=$thetgt/mtmp
	fi
   for x in $FOLDERS; do cp -arv $ch/"$x" $tmp &> /dev/null ; done

	SERIAL=`date +"%m-%d-%y_%R"|tr ':' '_'`
	line=43 #Bootloader
	pth="/boot/syslinux/porteus.cfg"
    [[ -n "bootdvc" ]] && thetgt=$bootdvc && [[ -n "$grubln" ]] && { line=$grubln ; pth="/boot/grub/grub.cfg"; } 
    [[ -z "$grubln" ]]; then && rltt=$( sed -n "${line}p" "$thetgt$pth" | grep -oP 'changes=\K[^ ]*') && [[ -n "$rltt" ]] && insertmenu $thetgt$pth

	test -e "$thetgt$pth" && rlt=$( sed -n "${line}p" "$thetgt$pth" | grep -oP 'extramod=\K[^ ]*') # Is there an extramod on ln?  ## Notes returns the value grep 'extramod=[^ ]*')
	epath=$(printf '%s' "${target}${em}" | sed 's/[&|]/\\&/g')


	if [ "$rlt" != "" ]; then
		if [[ ! "${rlt}" == *$BASEDIR"/"$emfld* ]]; then

		    test -d "$target$em" || mkdir -p "$target$em"
			[[ -n "$grubln" ]] && test -e $thetgt$pth && cp $thetgt$pth $thetgt$pth$$.bak
		    #append to start of boot loader
		    sed -i "s|\(extramod=\)\([^ ]*\)|\1${epath};\2|" "$thetgt$pth"
		    loadermsg

		    IFS=';' read -ra parts <<< "${rlt}"
		    unset IFS
		    u=""

		    for part in "${parts[@]}"; do
		        erlt=$( sed -n "${line}p" "$thetgt$pth" | grep -oP 'extramod=\K[^ ]*')
		        testfile="${part}/.writetest_${$}"

		        if touch "$testfile" 2>/dev/null; then
		            rm -f "$testfile"

		            for file in "${part}"/*_uid_*; do [ -e "$file" ] || continue ; mv "$file" "${target}${em}" ; u="true" ; done
		        else
		            echo "$part was not writable some previous changes modules with _uid_ could not be moved"
		        fi
		        if [ "$u" == "true" ]; then
					test -d $part"/archive" && mv $part"/archive" "${target}${em}"
					test -e $part"/lscheck" && mv $part"/lscheck" "${target}${em}"
		            test -e $part"/mergemodules" && rm $part"/mergemodules"
		            test -e $part"/createlmodule" && rm $part"/createmodule"
		            test -e $part"/renameLbak" && rm $part"/renameLbak"
		            test -e $part"/renamebak" && rm $part"/renamebak"
		        fi
		        if [ "$u" == "true" ] && [ -d "$part" ] && [ -z "$(ls -A "$part")" ]; then
		            erlt="${erlt//;$part/}"
		            erlt="${erlt//$part;/}"
		            erlt="${erlt//$part/}"
		            erlt=$(printf '%s' "$erlt" | sed 's/[&|]/\\&/g')   #escape | and also & which may appear in a directory so doesnt break sed
		            sed -i "s|\(extramod=\)[^ ]*|\1${erlt}|" "$thetgt$pth"
		            cyan "bootloader updated"
		        fi
		    done
		    if [ "$u" != "" ]; then green "all previous changes modules in other extramod directories moved to new extramod dir" ; fi
		fi
	else
		cmd="sed -i \"0,/APPEND/ s|\\(APPEND\\)|\\1 extramod=${epath}|\" \"$thetgt$pth\""
		if [ -n "$grubln" ]; then test -e $thetgt$pth && cp $thetgt$pth $thetgt$pth$$.bak ; cmd="sed -i \"${line}s|\\\$| extramod=$epath/|\" \"$thetgt$pth\"" ; fi
		test -e "$thetgt$pth" && bash -c "$cmd" || echo "Using other bootloader append ${target}${em} to it with extramod="
	fi # END Bootloader

	if [ -s "${target}${em}${MODULENM}${SERIAL}_uid_$$.xzm" ]; then
		echo
		echo A changes .xzm was detected but nothing was done.
		cyan "${MODULENM}${SERIAL}_uid_$$.xzm already exists" && { sleep 5; exit 0; }
	else
		test -d "$target$em" || mkdir "$target$em"
		touch "$target$em/._test1" 2>/dev/null
		cyan "testing filesystem on ${target} for posix compatibility"
		ln -s "$target$em"/._test1 "$target$em"/._test2 2>/dev/null && chmod +x "$target$em"/._test1 2>/dev/null && [ -x "$target$em"/._test1 ] && chmod -x "$target$em"/._test1 2>/dev/null && [ ! -x "$target$em"/._test1 ] && rm -f "$target$em"/._test1 "$target$em"/._test2
		if [ $? -ne 0 ]; then
		    mount -o remount,udba=none /
		    rm -f "$target$em"/._test1 "$target$em"/._test2
			echo && echo -e "[1;33m""A Windows filesystem (FAT, NTFS) or other non-posix compatible filesystem\nhas been detected on $target.\nYour changes cannot be saved directly to the specified storage media with this\nsetup. Please use the '[1;36mPorteus save file manager[1;33m' to create a .dat container\nand use it for saving your changes after your next reboot.""[0m"
		    exit
		fi
		r=$(find "$target$em" -maxdepth 1 -type f -name '*_uid_*.xzm' | wc -l)
		if [ "$r" -eq 0 ]; then # if this is the first time running and there isnt a symlink to the merge script create it
		    if [ ! -e "$target$em"/mergemodules ]; then ln -s /usr/local/save-changesnew/mergemodules.sh "$target$em"/mergemodules; fi
			if [ ! -e "$target$em"/createlmodule ]; then ln -s /usr/local/save-changesnew/createlmdl.sh "$target$em"/createlmodule; fi
		    if [ ! -e "$target$em"/renamebak ]; then ln -s /usr/local/save-changesnew/renamebak "$target$em"/renamebak; fi
		    if [ ! -e "$target$em"/renameLbak ]; then ln -s /usr/local/save-changesnew/renameLbak "$target$em"/renameLbak; fi
		fi
		pst=$PWD
		if [ "$linkedSTATE" == "true" ]; then

		    f=$(find "$target$em" -maxdepth 1 -type f -name '*_uid_L*.xzm' | wc -l)
		    if [ "$f" -gt 1 ]; then
		        echo "Cannot have more than one _uid_L\.\*\.xzm file" && exit 0
		    # Good to go
		    elif [ "$f" -eq 1 ]; then
		        cd $tmp
		        : > $EXCL; : > $EXFILES ;  rlt=""
		        if [ -e $msr ]; then
		            content=$(awk -v RS= '{gsub(/\n+$/, "", $0); print $0}' "$msr")
		            k=$( echo "$content" | sed -n 's/.*bytes:[[:space:]]*\([0-9]\+\).*/\1/p')
		            if [ "$k" != "" ]; then
		                p=$( echo "$content" | sed -n 's/^file name:[[:space:]]*\(.*\)/\1/p')
		                if [ "$p" != "" ]; then
		                    if [ -f $target$em"/"$p ]; then

		                        c=$( du -sb "${target}${em}/${p}" | cut -f1)

		                        if [ "$c" -eq "$k" ]; then
		                            ssbn=$( echo $p | sed -n 's/.*_uid_L\(.*\)\.xzm$/\1/p')
		                            if [ "$ssbn" == "" ]; then cyan "failed to parse ssbn in msr"; fi
		                        else
		                            validrlt="false"
		                        fi
		                        fname=$p
		                        rlt="true"

		                    fi
		                fi
		            fi
		            if [ "$rlt" == "true" ]; then
		                createlmdl "msr"
		            else
		                cyan "Bad msr file. making new serial no. the previous one will be renamed to .bak"
		                createlmdl "badmsr"
		            fi
		        else
		            createlmdl "nomsr"
		        fi
		        cd $pst

		    elif [ "$f" -eq 0 ]; then
		        createlmdl "nolmdl"
		    fi

		else # End linked
		    rname="${MODULENM}${SERIAL}_uid_${$}.xzm"
			mksquashfs $tmp "$target$em$rname" -comp $cmode -ef $exclfiles
			if [ "$ANALYTICS" == "true" ]; then end=$(date +%s.%N) ; el=$(awk "BEGIN {print $end - $start}") ; fi
		fi
		chown $USR $target$em$rname
		if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then printf "Saving took %.3f seconds.\n" "$el" ; fi

		cyan "Your changes have been saved. in ${target}${em}/"
		cyan $rname
		test -e $EXCL && rm $EXCL; test -e $EXFILES && rm $EXFILES

		if [ "$mrgMODULES" == "true" ] && [ "$linkedSTATE" == "false" ]; then
			cd $target$em
		    r=$(find . -maxdepth 1 -type f -name '*_uid_*.xzm' ! -name '*_uid_L*' | wc -l)
		    if (( r > mdllmt)); then
		        green "Merging changes modules..."
		        sleep 5

		        if ! /usr/local/save-changesnew/mergemodules.sh $keepMRGED $ROLLBCK $ROLLSUMRY $archLMT; then
		            red "There was problem auto merging. see /tmp/error.log"
		            cyan "Everything preserved."
		        fi
		        cyan "Modules merged."
		    fi
			cd $pst
		fi
	fi
	mount -o remount,udba=none /
	rm $exclfiles
	#rm /tmp/incfilter.log
	rm -rf $tmp
	rm -rf $mtmp
	sleep 5 && exit
fi
# Not in changes exit?
test -f /mnt/live/tmp/changes-exit || { echo "'changes=EXIT:' cheatcode is not active - exiting..."; exit; }
if [[ $(grep ".dat" /mnt/live/tmp/changes-exit 2>/dev/null) ]]; then
	Dest="Save.dat file"
else
	Dest="Save folder partition"
fi

if [[ "$1" != "6" ]]; then
	if [ "$ANALYTICS" == "true" ] && [ "$BACKUP" == "false" ]; then start=$(date +%s.%N); fi
	if [[ $(grep ".dat" /mnt/live/tmp/changes-exit 2>/dev/null) ]]; then
		Dest="Save.dat file"
	else
		Dest="Save folder partition"
	fi

	SDspace=$(df -BM -h --output=size,used,avail,pcent /mnt/live/memory/images/changes | tail -n1)
	read size used avail percent <<< "$SDspace"
	cyan "Checking for space in your $Dest .."
	if [[ ${percent%\%} -gt  85 ]]; then
	  echo
	  red "Warning! $Dest $percent full.  Used: $used  Free: $avail"
	  x=5
	  echo
	else
	  echo
	  green "$Dest $percent full.  Used: $used  Free: $avail"
	  echo
	fi

	# Folders to save: argument for `find' & check that they $changesexist.
	FOLDERS="$(grep ^/ $CHNEXIT_CONF | sed s/.//)"
    dycmb

	# Folders to exclude: argument for `egrep'
	grep ^!/ $CHNEXIT_CONF | fixdir > $EXCL  #  has a ^ for egrep

	# only run timeout on shutdown
	if [[ "$1" = "6" ]]; then
		[[ ! $x ]] && x=3
		cyan "Your session will be saved in [1;33m$x seconds[0m"
		yellow  "Press space/enter to start doing it now or any other key to skip."
		while [[ $x -gt 0 ]]; do read -s -t1 -n1 ans && break || sleep 1; let x=x-1; done
	else
		ans=""
	fi

	if [[ "$ans" = "" ]]; then

		## Save session:
		cyan "Syncing what's left in buffers"
		sync

		# Remount aufs with 'udba=notify' flag:
		mount -o remount,udba=notify /
		cyan "Saving changes to $DEST - this may take a while..."
		cd /mnt/live/memory/changes || exit

	#NEW

		# Handle filenames with spaces.
		IFS="
		"

		#
		# file for rsync to read without regex
		#grep '^!/' $CHNEXIT_CONF | sed -e 's/^!//' > $EXFILES


		# Remove deleted files and non matching whiteouts
		for y in $(find $FOLDERS -name ".wh.*"); do
		  f="$(echo $y | sed 's@\.wh\.@@g')"
		  test -e "$MNAME/$f" && rm -rf "$MNAME/$f";
		  test -e "$INAME/*/$f" || { echo "$y" | fixwh >> $EXCL; echo "$y" >> $EXCLUDED; test -e "$MNAME/$y" && rm -f "$MNAME/$y"; }
			    #         ^   changed back to "$INAME/*/$f"       to prevent binary operator expected on empty sym link
		done

		#  We have  EXCL  regex and        EXFILES   non regex to work with
		#
		#  This routine can clean up EXCL to work with rsync tested
		#  works. The point of this version is to not have regex for
		#  rsync so all changes are for that reason
		#
		#  sed -i -e 's/\^//' -e 's|\\\.|.|g' -e 's|\]|\]\\|g' $EXCL
		#
		#> $EXFILES
		#cat $EXCL | fixexcl > $EXCLUDED   Original 

		# New 5.0
		exldir $EXFILES # generate exclude dirs


		# The purpose of this routine is so we have a file with all folders to save and can use it verify with rsync log that rsync is working
		# or captured all the directories
		#
		# $EXCL will show all the .wh. files  and $SFOLDERS has all the folders can use to verify
		#
		# Create a manifest of what folders we are saving through EXCL regex
		# Copy new and modified folders -- skip excluded whiteouts and folders and create a folder manifest
		test -s "$EXCL" && { find $FOLDERS -type d | egrep -vf $EXCL || find $FOLDERS -type d; } > $SFOLDERS


		# Note changed from original  we dont need to exclude .wh. as rsync can exclude those
		#
		# Copy new and modified files -- skip excluded whiteouts and folders
		# { test -s "$EXCL" && find $FOLDERS -not -type d | egrep -vf $EXCL || find $FOLDERS -not -type d; } > $SFILES
		#
		#

		#
		#  This routine can clean up EXCL to work with rsync tested
		#  works. The point of this version is to not have regex for
		#  rsync so all changes are for that reason
		#
		#  sed -i -e 's/\^//' -e 's|\\\.|.|g' -e 's|\]|\]\\|g' $EXCL
		#


		#Send files to drive and exclude from list of what to exclude  ie folders files etc
		#
		# pattern '\.wh\.*'    excludes any file starting with   .wh.
		#

		#Reject old log file in session
		test -e home/$USR/Downloads/"$LOGFILE" && rm home/$USR/Downloads/"$LOGFILE"
	    test -s "$EXFILES" && { rsync -aHv --exclude-from=$EXFILES --exclude '\.wh\.*' $FOLDERS $MNAME; } > $UPDATE || rsync -aHv --exclude '\.wh\.*' $FOLDERS $MNAME > $UPDATE
		end=$(date +%s.%N)     
		if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ] && [ "$BACKUP" == "false" ] ; then el=$(awk "BEGIN {print $end - $start}") ; printf "Saving took %.3f seconds.\n" "$el" ; fi

		#Reject old log file   Depricated
		#test -e "$MNAME$LOGDIR/$LOGFILE" && rm "$MNAME$LOGDIR/$LOGFILE"

		#Create a log
		BRAND=`date +"MDY_%m-%d-%y-TIME_%R"|tr ':' '_'`
		echo $BRAND >> $UPDATE

		#Do include a log file in case still in session
		cp "$UPDATE" "$MNAME$LOGDIR/$LOGFILE"


		# subroutine clean out any deleted files   a ..wh..  is a file you deleted and no longer exists
		#
		# the reasoning behind this routine is to clean a drive of any ..wh.. files
		#
		#
		#find $MNAME -name ".wh.*" -exec rm -r {} \;

	#NEW END



	# ORIGINAL commented out to work with changes

		# Copy new and modified files -- skip excluded whiteouts and folders
		# { test -s "$EXCL" && find $FOLDERS -not -type d | egrep -vf $EXCL || find $FOLDERS -not -type d; } > $SFILES
		# cp -uafv --parents $(cat $SFILES) $MNAME > $UPDATE

		   #  Alternative to above to prevent exceeding ARG_MAX  ie too long of command
		   #  > $UPDATE
		   # cat $SFILES | xargs -I {} cp -aufv --parents {} $MNAME >> $UPDATE    #Can add instead of above

	# ORIGINAL END


		# Remove conflicting whiteouts
		for y in $(find $MNAME -name ".wh.*"); do
			f="$(echo $y | sed -e 's^$MNAME^^g' -e 's^\.wh\.^^g')";
			test -e "$f" && rm "$y";
		done

		# Reset IFS to default
		unset IFS

		#	green "Session saved"       ORIGINAL commented out to work with changes
		cyan "Your changes have been saved. and synced to your system"
		cyan "updates changes to hdd $DEST"
		cyan "A log file is available in Downloads"
		cyan "If you are still in session you wont see this"
		cyan "file until reboot. a copy is in /tmp"
		## End Changes commit
    else
		yellow "Skipping."
	fi
fi

## Developer buddy 3 rsync backup on  changes=EXIT:/porteus    save-changesnew
if [[ "$3" == "yes" ]]; then ans=""; fi # called by changes-commit?
if [[ "$ans" = "" ]]; then
	if [[ "$BACKUP" == "true" ]]; then
		if [[ "$1" == "6" ]]; then  
			cyan "Backing up on shutdown..."
			target=$4
			FOLDERS="$(for x in $(grep ^/ $CHNEXIT_CONF | sed s/.//); do test -e /mnt/live/memory/changes/"$x" && echo "$x"; done)"
            dycmb

		#else # normal execution of this script

		fi
		#rm $EXCL     isnt used as not using egrep -vf
		#rm $UPDATE     This is available as a tmp file
		#rm $EXFILES  # We need to reuse this as its already done
		test -e $SFOLDERS && rm $SFOLDERS 
		test -e $EXCLUDED && rm $EXCLUDED
		> $UPDATE ; > $exclfiles
		exldir $exclfiles

		if [ "$ANALYTICS" == "true" ]; then start=$(date +%s.%N); fi
		if [ ! -e $target ]; then echo "Target does not exist" && exit 0 ; fi

		rlt=$(cat /proc/cmdline | sed -n 's/.*changes=EXIT:\([^ ]*\).*/\1/p')
		[[ "$rlt" == *"/dev/"* ]] && rlt=${rlt//dev/mnt}
		[[ "$rlt" == *"$target"* ]] && { rlt=${rlt%/} && target=""; }
		
		test -e $target$rlt && if [ "$rlt" != "" ]; then osize=$( du -sb "${target}${rlt}${MODULENM}/" | tail -n1 | awk '{print $1}'); fi # original size

		if [ "$LOGGING" == "false" ] && [ "$ANALYTICS" == "true" ]; then echo analystics requires logging to be true. && exit 0 ; fi

		mkdir $tmp
		if [ "$d2drive" == "false" ]; then
			: > /tmp/incfilter.log
			green "Staging... "
			for x in $IFOLDERS; do cp -arv $ch/"$x" $tmp &> /dev/null ; done
		else 
			green "Direct to drive saving"
			: > /tmp/incfilter.log
			for folder in $IFOLDERS; do echo "+ /$folder/" >> /tmp/incfilter.log ; done
			for fld in $EXCLUDE; do if [[ "${fld:0:1}" == "/" ]]; then fld="${fld#/}" ; else fld="*${fld}*" ; fi ; echo "- /$fld/" >> /tmp/incfilter.log ; done
			echo "- /*" >> /tmp/incfilter.log
		fi
		if [ "$rlt" != "" ]; then
		    if [ "$rlt" == "/" ]; then rlt="" ; fi
    		if [ "$d2drive" == "true" ]; then
        		dirSRC="$target$rlt/changes"
    		else
        		dirSRC=$tmp
    		fi
			pst=$PWD
			cd $dirSRC
		    if [ -d "${target}${rlt}${MODULENM}.bak/" ]; then
		        green "Updating existing backup..."
		        if [ "$LOGGING" == "true" ]; then
		            if [ -f "${target}${rlt}${MODULENM}.bak.log" ]; then
		                m=$(head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -c "STOP")
		                if (( m == 0 )); then
		                     adtCMD="--log-file=${target}${rlt}${MODULENM}.bak.log"

		                    if grep -B 1 'END ORIGINAL FILES' "${target}${rlt}${MODULENM}.bak.log" | tail -2 | head -1 | grep -q '^PAUSED$'; then

		                        glog

		                    else

		                        l=$(head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -c "PAUSED")
		                        size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")

		                        if [ "$size" -gt $((logSIZE * mbyte)) ]; then
		                        
		                            if [ "$ANALYTICS" == "true" ]; then
		                                cyan "Log file has hit the limit. Clearing..."
		                            fi

		                            if [ "$logSPRF" == "delete" ]; then

		                                if grep -q "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log"; then

		                                    glog "true"

		                                else
		                                    > "${target}${rlt}${MODULENM}.bak.log"
		                                fi

		                            elif [ "$logSPRF" == "psv" ]; then

		                                c=$( wc -l < "${target}${rlt}${MODULENM}.bak.log") # total count
		                                q=$(awk "BEGIN {print $c * 0.85}")

		                                if (( l == 1 )); then

		                                    sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE

		                                else

		                                    h=$( grep -m 1 -n "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log" | awk -F: '{print $1}') # what line is it on
		                                    b=$(( h + 16 ))

		                                    if [ "$h" !=  "" ]; then

		                                        if [[ $b -le $c ]]; then

		                                            if sed -n "$(( h + 16))p" "${target}${rlt}${MODULENM}.bak.log" | grep -q "total size is"; then
		                                                sed "${b}q" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE

		                                            else
		                                                 sed '/END ORIGINAL FILES/q' "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
		                                            fi

		                                        else

		                                            sed '/END ORIGINAL FILES/q' "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
		                                        fi

		                                        sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" >> $UPDATE

		                                    else

		                                        sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
		                                    fi
		                                fi
		                                
		                                if [ "$ANALYTICS" == "true" ]; then
		                                    size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")
		                                    
		                                    if (( size > logSIZE * mbyte )); then
		                                        cyan "Log size limit reached on preserve mode. Please adjust max limit or logging preference."
		                                        cyan "This means the file list is greater than the limit or the limit is too small."
		                                    fi
		                                fi

		                                cp $UPDATE > "${target}${rlt}${MODULENM}.bak.log"
		                                rm $UPDATE
		                            elif [ "$logSPRF" == "stop" ]; then
		                                adtCMD=""
		                                if [ "$ANALYTICS" == "true" ]; then
		                                    cyan "Log file hit max limit not logging..."
		                                fi

		                                if (( l >= 1 )); then
		                                    sed -i '1s/PAUSED/PAUSEDSTOP/g' "${target}${rlt}${MODULENM}.bak.log"
		                                else
		                                    sed -i '1i STOP' "${target}${rlt}${MODULENM}.bak.log"
		                                fi
		                            fi
		                        fi
		                    fi

		                    if (( l >= 1 )); then sed -i '0,/PAUSE/ { /PAUSE/ d }' "${target}${rlt}${MODULENM}.bak.log"; fi
		                fi

		            else
				        nsize=$osize
				        green "There was no logfile generating..." ; > "${target}${rlt}${MODULENM}.bak.log"
						dlog
						echo >> "${target}${rlt}${MODULENM}.bak.log"
						echo "original size(source)=Unkown" >> "${target}${rlt}${MODULENM}.bak.log"
						echo "new size(source)=$nsize" >> "${target}${rlt}${MODULENM}.bak.log"
						echo  "END ORIGINAL FILES $(date +"%m-%d-%y_%R")" >> "${target}${rlt}${MODULENM}.bak.log"
						nLOG="true"
		            fi

		        else 
		        
		            if [ -f "${target}${rlt}${MODULENM}.bak.log" ]; then

		                if ! grep -B 1 'END ORIGINAL FILES' "${target}${rlt}${MODULENM}.bak.log" | tail -2 | head -1 | grep -q '^PAUSED$'; then

		                    if grep -q "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log"; then
		               
		                        sed -i "/END ORIGINAL FILES/ i\PAUSED" "${target}${rlt}${MODULENM}.bak.log"

		                    else 

		                        if ! head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -q 'PAUSED'; then
		                            if head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -q 'STOP'; then
		                                sed -i '1{/STOP/ s/^/PAUSED/}' "${target}${rlt}${MODULENM}.bak.log"
		                            else
		                                  sed -i '1i PAUSED' "${target}${rlt}${MODULENM}.bak.log"
		                            fi
		                        fi
		                    fi
		                fi
		            fi
		        fi

		        if [ "$adtCMD" != "" ]; then

		            if [ "$FEEDBACK" != "true" ]; then
		               	rsync -aH --delete --filter="merge /tmp/incfilter.log" --delete-excluded --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" $adtCMD
		            else
		                rsync -aHv --delete --filter="merge /tmp/incfilter.log" --delete-excluded --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" | tee -a "${target}${rlt}${MODULENM}.bak.log"
		            fi
					exc=$?
				    if [ $exc -eq 1 ]; then
						mount -o remount,udba=none /
						red "rsync failed â€” check log at ${target}${rlt}${MODULENM}.bak.log"
						if [ "$d2drive" == "false" ]; then
							cyan "Files left in memory. Copy and paste the following to rsync again:"
							echo "rsync -aH --delete --filter=merge /tmp/incfilter.log --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/ --log-file=${target}${rlt}${MODULENM}.bak.log"
							if [ "$ANALYTICS" == "true" ]; then
								echo "Then check the logfile for any errors.Then take the last two bytes sent and add it to total count=  at the top of the file if you want to keep exact track."
								echo "Or"
								printf 'rsync -aHv "%s" newdirectory/\tto make a new backup\n' "${target}${rlt}${MODULENM}/"
							fi
						else
				  		    if [ "$ANALYTICS" == "true" ]; then
								echo "Add up the last bytes sent values and add to total count=  at the top of the file before END ORIGINAL FILES.  if you want to keep exact track."
							fi
						fi

						exit 1
					elif [ $exc -eq 24 ]; then
						cyan "Some files have vanished. Check for excluding cache files"
						sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
					fi
		        else
		          
		            if [ "$nLOG" != "" ]; then
		                if [ "$FEEDBACK" != "true" ]; then
		                    rsync -aH --stats --delete --filter="merge /tmp/incfilter.log" --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" > $UPDATE 2>&1  # capture the log in a sentinal
		                else
		                    rsync -aH --stats --delete --filter="merge /tmp/incfilter.log" --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" 2>&1 | tee $UPDATE
		                fi

		            else
		                if [ "$FEEDBACK" != "true" ]; then
		                    rsync -aH --delete --filter="merge /tmp/incfilter.log" --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" > /dev/null
		                else
		                    rsync -aH --delete --filter="merge /tmp/incfilter.log" --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/"
		                fi
		            fi
					exc=$?
				    if [ $exc -eq 1 ]; then
						mount -o remount,udba=none /
						red "rsync failed â€” check log at ${target}${rlt}${MODULENM}.bak.log"
						if [ "$nLOG" != "" ]; then
							if [ "$d2drive" == "false" ]; then
								cyan "Files left in memory. Copy and paste the following to rsync again:"
						    	echo "rsync -aH --stats --delete --filter=merge /tmp/incfilter.log --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/ --log-file=${target}${rlt}${MODULENM}.bak.log"
							fi
							if [ "$ANALYTICS" == "true" ]; then
						       echo "Then check the logfile for any errors. Add up all the bytes sent values and put total count=  at the top of the file before END ORIGINAL FILES.  if you want to keep exact track."
						    fi
						else
							echo "rsync -aH --delete --filter=merge /tmp/incfilter.log --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/"
						fi

						echo
						echo "Or failing that"
						printf 'rsync -aHv "%s" newdirectory/\tto make a new backup\n' "${target}${rlt}${MODULENM}/"

						exit 1
				    elif [ $exc -eq 24 ]; then
						cyan "Some files have vanished. Check for excluding cache files"
						sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
					fi
		            if [ -s $UPDATE ]; then
		                c=$( wc -l < "$UPDATE")
		                if (( c > 17)); then sentinal="true"; cp $UPDATE /tmp/parity.txt; fi
		                sed -n '/Number of files/,$p' $UPDATE >> "${target}${rlt}${MODULENM}.bak.log"
		            fi
		        fi
				end=$(date +%s.%N)

		        cyan "Changes backup has been updated."

		        if [ "$ANALYTICS" == "true" ]; then
		            ossize=$( sed -nE 's/.*original size\(source\)=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n 1)
		            if [ "$ossize" == "" ]; then
		                oput="Unkown"
		            else
		                oput="$(( ossize / mbyte )) MB"
		            fi

		            csize=$(du -sb "${target}${rlt}${MODULENM}.bak/" | cut -f1)
		            nsize=$osize
		            c=$( sed -nE 's/.*total count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n 1)
		            c="${c:-0}"
		            
		            if [ "$adtCMD" != "" ]; then
		                z=$( tail -n1 ${target}${rlt}${MODULENM}.bak.log | grep -oP '(?<=sent\s)\d+(?=\s+bytes)' | head -n 1)
						if (( z == 0 )); then z=$(tail -n 20 ${target}${rlt}${MODULENM}.bak.log | grep -oP '(?<=sent\s)[\d,]+' | tail -n 1 | sed 's/,//g'); fi
		            elif [ "$adtCMD" == "" ] && [ "$nLOG" == "true" ]; then
		                if [ "$ANALYTICS" ==  "true" ]; then
		                    green "A new log file has been made."
		                fi
		                z=$( tail -n2 ${target}${rlt}${MODULENM}.bak.log | head -n1 | grep -oP '(?<=sent\s)[\d,]+' | tr -d ',' )
		            fi

		            r=$(( c + z ))
		            grep -q "total count=" "${target}${rlt}${MODULENM}.bak.log" && sed -i "s/total count=[0-9]\+/total count=$r/" ${target}${rlt}${MODULENM}.bak.log || sed -i "/END ORIGINAL FILES/ i\total count=$r" "${target}${rlt}${MODULENM}.bak.log"

		            c=$( sed -nE 's/.*original count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n 1)
		            c="${c:-0}"
		            if (( c != 0 )); then
		                cyan " Since the original backup was first made sent" $(( ( c + z ) / mbyte )) "MB worth of data"
		            fi

		            if [ "$logSPRF" != "stop" ] && [ "$nLOG" == "true" ]; then
		                size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")
		                if (( size > logSIZE * mbyte )); then
		                red "New log file made is greater than the limit. adjust if needed to keep log data on next backup."
		                fi
		            fi
		            cyan "You have sent $(( r / mbyte )) MB worth of data to the ${target}${rlt}${MODULENM}.bak/ backup"
		            green "Sent $(( z / mbyte )) MB to backup. "

		            echo
		            if  [ "$adtCMD" != "" ] && [ "$nLOG" == "true" ]; then
		                cyan "Size of source when backup first made: $oput"
		                green "Current size of source: $(( osize / mbyte ))"
		            fi

		            green "Current size of backup: $(( csize / mbyte )) MB"

		            if [ "$nLOG" == "true" ]; then
		                echo
		                cyan "You saved $(( (nsize - csize) / mbyte )) MB by generating this backup."
		            fi
		            if [ "$ANALYTICSECT" == "true" ] ; then el=$(awk "BEGIN {print $end - $start}") ; printf "Backup took %.3f seconds.\n" "$el" ; fi
		            if [ "$sentinal" == "true" ]; then
		                rm $UPDATE
		                echo -e "\nYou are seeing this message as you have most likely deleted an entire directory on the source."
		                echo "rsyan will not remove a non empty directory on the backup that is empty on the source for safety reasons."
		                echo " check parity.txt in /tmp to see what these directories are and delete them in the backup."
		            fi
		        fi
		    else
				if [ "$ANALYTICS" == "true" ]; then start=$(date +%s.%N); fi
				mkdir ${target}${rlt}${MODULENM}.bak

				if [ -f "${target}${rlt}${MODULENM}.bak.log" ]; then
					glog "true"
				else
					dlog
					if [ "$LOGGING" == "true" ]; then
						echo "original size(source)=$osize" >> "${target}${rlt}${MODULENM}.bak.log"
						echo "END ORIGINAL FILES" >> "${target}${rlt}${MODULENM}.bak.log"
		        	fi
				fi
				if [ "$LOGGING" == "false" ]; then
					test -f "${target}${rlt}${MODULENM}.bak.log" && rm "${target}${rlt}${MODULENM}.bak.log"
				fi

		        cyan "Creating new backup this may take a few minutes."


		        if [ "$FEEDBACK" != "true" ]; then
		            rsync -aH --stats --filter="merge /tmp/incfilter.log" --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" >> "${target}${rlt}${MODULENM}.bak.log" 2>&1
		        else
		            rsync -aHv --stats --delete --filter="merge /tmp/incfilter.log" --delete-excluded --exclude-from=$exclfiles --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" | tee -a "${target}${rlt}${MODULENM}.bak.log"
		        fi
				exc=$?
				if [ $exc -eq 1 ]; then
				    mount -o remount,udba=none /
				    red "rsync failed â€” check log at ${target}${rlt}${MODULENM}.bak.log"
				    cyan "Please check the logfile if its a valid backup or try again."
				    cyan "failing that delete the backup and try again."
				    rm -rf $tmp
				    exit 1
				elif [ $exc -eq 24 ]; then
					cyan "Some files have vanished. Check for excluding cache files"
					sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
				fi
				end=$(date +%s.%N)
		        cyan "Your changes backup has been created! in ${target}${rlt}/"
		        cyan "${MODULENM}.bak/"

		        if [ "$ANALYTICS" == "true" ]; then
					if [ "$ANALYTICSECT" == "true" ] ; then el=$(awk "BEGIN {print $end - $start}") ; printf "Backup took %.3f seconds.\n" "$el" ; echo ; fi
		            csize=$( du -sb "${target}${rlt}${MODULENM}.bak/" | cut -f1)
		            tsize=$(( osize - csize ))
		            z=$( grep "Total bytes sent:" "${target}${rlt}${MODULENM}.bak.log" | tail -n 1 | sed -E 's/[^0-9]*([0-9,]+).*/\1/' | tr -d ',')	            
		            sed -i "/END ORIGINAL FILES/ i\total count=$z" "${target}${rlt}${MODULENM}.bak.log" #insert the total byte count
		            green "You have sent $(( z / mbyte )) MB worth of data so far to the ${target}${rlt}${MODULENM}.bak/ backup"
		            cyan "You saved $(( tsize / mbyte )) MB by creating this backup"
		        fi
		        echo
		    fi
			cd $pst
		fi
    	test -e $EXCLUDED && rm $EXCLUDED
		rm -rf $tmp
	fi
	if [[ "$1" != "6" && "$3" != "yes" ]]; then
		# Remount aufs with 'udba=none' flag:
		mount -o remount,udba=none /
		#test -e $EXFILES && rm $EXFILES	# commit script
		test -e $UPDATE && rm $UPDATE	# temporary holding
		test -e /tmp/incfilter.log && rm /tmp/incfilter.log
		rm $EXCL		# parsing rsync
		#rm $exclfiles	# rsync exclusion list
		#Remove /mnt/live/tmp/changes-exit if called from rc.6 (temporary for legacy initrd where cleanup still has changes=EXIT: routine)
		[[ "$1" == "6" ]] && rm /mnt/live/tmp/changes-exit
	fi
fi # yes answer
