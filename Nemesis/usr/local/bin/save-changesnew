#!/bin/bash
#                                               Developer Buddy v3.0                Aug 22, 2025
#   this script works for two modes porteus nemesis graphics and changes.
# # Author: fanthom <fanthom@porteus.org>
. /usr/share/porteus/porteus-functions
get_colors
. /usr/local/save-changesnew/save-changesnewfnts
if [ `whoami` != "root" ]; then echo "Please enter your root password below" ; su - -c "/usr/local/bin/save-changesnew '${BASEDIR}' '${USER}' $1 " ; exit ; else [ "$2" == "" ] && theUSER="guest" || theUSER=$2 ; fi
thetgt="$1" ; if [ "$thetgt" == "" ]; then thetgt=$BASEDIR; fi     # <----- for autosaving change to "/mnt/sda"  ie   /mnt/sda3          /etc/rc.d/rc.local_shutdown
if  ! id $2 >/dev/null 2>&1; then echo "user:" ${2} "not found"; exit 0 ; fi # quick user check we test the target directory $1 after VARS
if ! grep -iq "Artix" /etc/os-release; then echo "Wrong version of developer buddy. Please use porteus version." && exit 0 ; fi
# CHANGABLE
autosave="true"                # changes=EXIT: only ie automatic append changes-commit to call this script if false sets .. to -x


d2drive="true"                 # default is false   for systems with low memory save directly to drive
                                        # default is save to memory for staging purposes and convenience of modifying
                                        # ect more versatle and efficient (less writes on hd)
                                        # but systems with low memory may want to use this to avoid any potential
                                        # exceedence

d2dmdl="false"					# default false  use harddrive for temp dir for modules
mdldvc=""                        # default null. if not enough memory use this device.       ie /mnt/sda3

grubln=""                                     # default null.  Point to Line number ie  linux /boot/syslinux/vmlinuz from=/dev/nvme0n1p4 root= ...   to automatically update grub for graphics extramod to boot with changes
bootdvc=""		                              # default null. Point to the line number linux /boot/syslinux/vmlinuz from=/dev/nvme0n1p4 root=UUID=... to automatically update grub for graphics extramod to boot with changes

target=$thetgt                               # change this to specify the location of porteus install this passed from root call where porteus is installed via $BASEDIR
                                                # examples      "/mnt/sdx"   ie /mnt/sda3
                                                #                   "/dev/sdx"
                                               # avoid trailing /


#Folders to include from changes      adjust if wanted            set to include changes-exit default folders
FOLDERS="bin etc home lib lib64 opt root sbin usr var"

#Folders to exclude from changes
EXCLUDE="/var/run /var/tmp share/Trash"   #default changes-exit configuration
                                            # keep original format  /var/run    is the base directory var
                                            # seperate with space            anything else other than / will be a pattern *****  ie share/Trash

#Folders to exclude from changes                                         already set to exclude changes-exit default folders
# If you want to exclude directories see Line 153, 191 for Graphics changes mode and 307 for Graphics mode

chxzm="/changes.xzm"            #Module  name  change this if you want to customize the name
                                                # retain leading / and ensure it ends in .xzm
                                               #avoid trailing / and any spaces

em="/extramod"                      #change this to save a different folder       the extramod dirtory
                                                # retain leading /
                                               # avoid trailing /

cmode="gzip"                            # default nothing. uses gzip compression level balanced
                                           # xz        best compression
                                           # zstd     faster bootup
                                            # lzo      faster bootup

logSIZE=35                             # Log size limit default 35 MB
                                            # Will keep the original contents from when the changes.bak folder was made
                                            # if limit is exceeded. Just clears out old changes to make a new log file

logSPRF="delete"                         # When log size limit reached what to do default delete just delete it and create a new one
                                            #       with new updated master list.
                                            # delete    delete the log to save space and make a new one with new master listi
                                            # psv       preserve 25% of the last changes but take into account new changes so
                                            #           we are not over 25% of the log max size limit thus we grab 10-15% of the
                                            #           most recent changes append new ones to reach the 25% quota
                                            #
                                            #           end result preserves the original format and any original master list
                                            #
                                            # stop      dont log anymore

mdllmt=5                             # Auto Graphics mode module merging default 7
                                                # when reached will automatically merge if mrgMODULES is set to true below
                                                # see mrgMODULES boolean

linkedLOGPRF="incr"          # default incr  new log of only changes keeps log size down
                                            # full log from creation all files and then append changes
                                            # no      dont log the linked module

# CHANGABLE BOOLEANS
linkedSTATE="true"             #This is precendence for changes:EXIT only on graphics mode. Default false
                                           # This implies that you want changes made INCLUDING deletes to another
                                           # modules in /tmp for now. We do this to prove that its working so everything
                                           # is still done the same just you have a module with deletions included in /tmp
                                           #
                                           # linked state needs all changes modules to be created together thus you should
                                           # start with one that has linkedSTATE made. A byte count of this .xzm is made
                                           # and logged into a txt file by the modules.
                                           #
                                           # This text file will tell it are those candidates for Changes:EXIT/ and where to stop
                                           # ect.
keepLINKEDMRGED="false"  # default is false so delete the old ones after merging if they are not in sync with each other
                                           # it automatically renames the old one to .bak. ****

# Non linked state options
mrgMODULES="true"           # Automatically merge changes modules if over limit value
                                        #change this to automatically merge changes.xzm modules  ( applies to Graphics mode)
                                        # see $BASEDIR/extramod for mergemodule script to merge changes modules

keepMRGED="false"       # default is false so delete the old ones after merging
# End Non linked state options





# Terminal output / feedback
FEEDBACK="false"                # default false     New version 3 feature
                                            # show more verbose feedback from rsync ect in terminal while saving

LOGGING="true"                  # default is true change if you dont want logging

ANALYTICS="true"            # logging must be set to true       default true     or set to false to turn off too much info
                                        # if false will just output rsync changes
                                        # if it exceeded logSIZE then the original contents when the backup was made is preserved
                                        # and then a new logfile is made then rsync appends any changes during updates until
                                        # the limit is exceeded again.
                                      # If true Will give total space saved if making a complete new backup
                                        # more data in the log file and custom info by this script
                                        # extra stuff like if the log file exceeded logSIZE and a new one is made
                                        # it will list the contents of the ORIGINAL backup, the contents of the current backup
                                        # and list the file differences as well. Then rsync will continue to input changes.
                                        # you also get total MB saved if you had manually backed up the changes folder ect

ANALYTICSECT="true"		# disable metric saving time. ect.
# End Terminal output

# Backup mode for Graphics modules
ROLLBCK="false"				# backup module after merged to be able to "rollback" by loading any single module
 			 							# A module that has been merged is saved and moved to /archive/
										# takes up more space

ROLLSUMRY="false"            # default false    Include file manifest for archives

archLMT=4						# how many unique roll backs to keep  both _uid_ and _uid_L seperately
# End Backup mode
# END CHANGABLE BOOLEANS
# END CHANGABLE
tmp=/mnt/live/tmp/work$$											; 			mtmp=/tmp/mtmp$$
ch=/mnt/live/memory/changes									;			INAME=/mnt/live/memory/images #system changes   and images    leave set
SFOLDERS=/tmp/save.sfolders.tmp								;			trsyncexl=/usr/local/save-changesnew/excld.ini
EXFILES=/tmp/exfiles.log											;			EXCL=/tmp/save.excl.tmp	 # for egrep regrex
QEXCL=/tmp/squashexfiles.log									;			EXCLUDED=/tmp/save.excluded.tmp
EXFILES=/tmp/save.exfiles.tmp									;			exclfiles=/tmp/save.squashregex.tmp  #spare tmp
UPDATE=/tmp/save.update.tmp									;			oMF=/tmp/flog.log
CHNEXIT_CONF=/etc/changes-exit.conf						;			chc=/etc/rc.d/rc.local_shutdown
USR=$theUSER															;			LOGDIR=/home/$USR/Downloads
LOGFILE="save.sfiles.tmp"										#	;			SVFILES=$MNAME/home/$USR/Downloads/save.sfiles.tmp            # wait until changes exit for nemesis #log file
mbyte=1048576														;			osize=0
IFOLDERS=""																;			rname=""
adtCMD=""																;			MODULENM=""
sentinal=""
#booleans
rlt=""
autosave $3
if [ "$LOGGING" == "false" ] && [ "$ANALYTICS" == "true" ]; then echo analystics requires logging to be true. && exit 0 ; fi
if [ ! -e $target ]; then echo "Target does not exist" && exit 0 ; fi
msr=${target}${em}"/lscheck"
IFOLDERS="$(for x in $(grep ^/ $CHNEXIT_CONF | sed s/.//); do test -e /mnt/live/memory/changes/"$x" && echo "$x"; done)"
dycmb ; exldir $EXFILES ; cyan "Syncing what's left in buffers" && sync
if [ "$ANALYTICS" == "true" ]; then start=$(date +%s.%N); fi
mount -o remount,udba=notify /
MODULENM="${chxzm%.xzm}" ; mdlnm="${MODULENM#/}" ; emfld="${em#/}"
rlt=$(sed -n 's/.*changes=\([^ ]*\).*/\1/p' /proc/cmdline)
if [ "$d2drive" == "false" ] || { [ "$d2drive" == "true" ] && [ "$d2dmdl" == "false" ] ; } ; then green "Staging... " ; else green "Direct to drive saving" ; fi
if [ "$rlt" != "" ]; then
    if [ "$rlt" == "/" ]; then rlt="" ; fi
	[[ "$rlt" == *"/dev/"* ]] && rlt=${rlt//dev/mnt}
	[[ "$rlt" == *"$target"* ]] && rlt=${rlt%/} && target=""
	osize=$( du -sb "${target}${rlt}${MODULENM}/" | cut -f1)
    : > /tmp/incfilter.log
    if [ "$d2drive" == "true" ]; then
        dirSRC="$target$rlt/changes"
		for folder in $FOLDERS; do echo "+ /$folder/" >> /tmp/incfilter.log ; done
		for fld in $EXCLUDE; do if [[ "${fld:0:1}" == "/" ]]; then fld="${fld#/}" ; else fld="*${fld}*" ; fi ; echo "- /$fld/" >> /tmp/incfilter.log ; done
		echo "- /*" >> /tmp/incfilter.log
    else
		mkdir $tmp ; dirSRC=$tmp
		for x in $FOLDERS; do cp -arv $ch/"$x" $tmp &> /dev/null ; done
    fi
	pst=$pwd ; cd $dirSRC

    if [ -d "${target}${rlt}${MODULENM}.bak/" ]; then
        green "Updating existing backup..."
        if [ "$LOGGING" == "true" ]; then
            if [ -s "${target}${rlt}${MODULENM}.bak.log" ]; then
                m=$(head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -c "STOP")
                if (( m == 0 )); then
                    adtCMD="--log-file=${target}${rlt}${MODULENM}.bak.log"
                    if grep -B 1 'END ORIGINAL FILES' "${target}${rlt}${MODULENM}.bak.log" | tail -2 | head -1 | grep -q '^PAUSED$'; then
                        glog
                    else

                        l=$(head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -c "PAUSED")
                        size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")

                        if [ "$size" -gt $((logSIZE * mbyte)) ]; then
                            if [ "$ANALYTICS" == "true" ]; then
                                cyan "Log file has hit the limit. Clearing..."
                            fi

                            if [ "$logSPRF" == "delete" ]; then

                                if grep -q "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log"; then
                                    glog "true"
                                else
                                    : > "${target}${rlt}${MODULENM}.bak.log"
								fi

                            elif [ "$logSPRF" == "psv" ]; then

                                c=$( wc -l < "${target}${rlt}${MODULENM}.bak.log") # total count
                                q=$(awk "BEGIN {print $c * 0.85}")
                                if (( l == 1 )); then
                                    sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE

                                else

                                    h=$( grep -m 1 -n "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log" | awk -F: '{print $1}') # what line is it on
                                    b=$(( h + 16 ))

                                    if [ "$h" !=  "" ]; then

                                        if [[ $b -le $c ]]; then

                                            if sed -n "$(( h + 16))p" "${target}${rlt}${MODULENM}.bak.log" | grep -q "total size is"; then
                                                sed "${b}q" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
                                            else
                                                 sed '/END ORIGINAL FILES/q' "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
                                            fi

                                        else
                                            sed '/END ORIGINAL FILES/q' "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
                                        fi

                                        sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" >> $UPDATE

                                    else
                                        sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
                                    fi
                                fi
                                if [ "$ANALYTICS" == "true" ]; then
                                    size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")
                                    if (( size > logSIZE * mbyte )); then
                                        cyan "Log size limit reached on preserve mode. Please adjust max limit or logging preference."
                                        cyan "This means the file list is greater than the limit or the limit is too small."
                                    fi
                                fi

                                mv $UPDATE "${target}${rlt}${MODULENM}.bak.log"
                                
                            elif [ "$logSPRF" == "stop" ]; then
                                adtCMD=""
                                if [ "$ANALYTICS" == "true" ]; then
                                    cyan "Log file hit max limit not logging..."
                                fi
                                if (( l >= 1 )); then
                                    sed -i '1s/PAUSED/PAUSEDSTOP/g' "${target}${rlt}${MODULENM}.bak.log"
                                else
                                    sed -i '1i STOP' "${target}${rlt}${MODULENM}.bak.log"
                                fi
                            fi
                        fi
                    fi
                    if (( l >= 1 )); then sed -i '0,/PAUSE/ { /PAUSE/ d }' "${target}${rlt}${MODULENM}.bak.log"; fi
                fi
            else
                nsize=$osize
                green "There was no logfile generating..." ; > "${target}${rlt}${MODULENM}.bak.log" ; dlog
                { echo ;  echo "original size(source)=Unkown" ; echo "new size(source)=$nsize" ; echo  "END ORIGINAL FILES $(date +"%m-%d-%y_%R")"; } >> "${target}${rlt}${MODULENM}.bak.log"
		        nLOG="true"
			fi

        else

            if [ -f "${target}${rlt}${MODULENM}.bak.log" ]; then

                if ! grep -B 1 'END ORIGINAL FILES' "${target}${rlt}${MODULENM}.bak.log" | tail -2 | head -1 | grep -q '^PAUSED$'; then

                    if grep -q "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log"; then

                        sed -i "/END ORIGINAL FILES/ i\PAUSED" "${target}${rlt}${MODULENM}.bak.log" # Put PAUSED above END OF ORIGINAL FILES

                    else

                        if ! head -n 1 "${target}${rlt}${MODULENM&> /dev/null}.bak.log" | grep -q 'PAUSED'; then
                            if head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -q ' if [ "$ANALYTICS" == "true" ]; then end=$(date +%s.%N) ; el=$(awk "BEGIN {print $end - $start}") ; fiSTOP'; then
                                sed -i '1{/STOP/ s/^/PAUSED/}' "${target}${rlt}${MODULENM}.bak.log"
                            else
                                  sed -i '1i PAUSED' "${target}${rlt}${MODULENM}.bak.log"
                            fi
                        fi
                    fi
                fi
            fi
        fi

        if [ "$adtCMD" != "" ]; then
            if [ "$FEEDBACK" != "true" ]; then
                rsync -aH --delete --filter="merge /tmp/incfilter.log" --delete-excluded --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" $adtCMD
            else
				rsync -aHv --delete --filter="merge /tmp/incfilter.log" --delete-excluded --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" | tee -a "${target}${rlt}${MODULENM}.bak.log"
            fi
			exc=$?
            if [ $exc -eq 1 ]; then
		        mount -o remount,udba=none /
		        red "rsync failed — check log at ${target}${rlt}${MODULENM}.bak.log"
		        if [ "$d2drive" == "false" ]; then
		        	cyan "Files left in memory. Copy and paste the following to rsync again:"
		        	echo "rsync -aH --delete --filter=merge /tmp/incfilter.log --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/ --log-file=${target}${rlt}${MODULENM}.bak.log"
		        	if [ "$ANALYTICS" == "true" ]; then
		        		echo "Then check the logfile for any errors.Then take the last two bytes sent and add it to total count=  at the top of the file if you want to keep exact track."
		        		echo "Or"
		        		printf 'rsync -aHv "%s" newdirectory/\tto make a new backup\n' "${target}${rlt}${MODULENM}/"
		        	fi
		        else
		  		    if [ "$ANALYTICS" == "true" ]; then
		        		echo "Add up the last bytes sent values and add to total count=  at the top of the file before END ORIGINAL FILES.  if you want to keep exact track."
		        	fi
		        fi
		        exit 1
			elif [ $exc -eq 24 ]; then
				cyan "Some files have vanished. Check for excluding cache files"
				sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
			fi
        else
            if [ "$nLOG" != "" ]; then
                if [ "$FEEDBACK" != "true" ]; then
                   rsync -aH --stats --delete --filter="merge /tmp/incfilter.log" --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" > $UPDATE 2>&1

                else
                    rsync -aH --stats --delete --filter="merge /tmp/incfilter.log" --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" 2>&1 | tee $UPDATE
                fi
            else
                if [ "$FEEDBACK" != "true" ]; then
                    rsync -aH --delete --filter="merge /tmp/incfilter.log" --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" > /dev/null
                else
                    rsync -aH --delete --filter="merge /tmp/incfilter.log" --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/"
                fi
            fi
			exc=$?
            if [ $exc -eq 1 ]; then if [ "$ANALYTICS" == "true" ]; then end=$(date +%s.%N) ; el=$(awk "BEGIN {print $end - $start}") ; fi
		        mount -o remount,udba=none /
		        red "rsync failed — check log at ${target}${rlt}${MODULENM}.bak.log"
		        if [ "$nLOG" != "" ]; then
		        	if [ "$d2drive" == "false" ]; then
		        		cyan "Files left in memory. Copy and paste the following to rsync again:"
		            	echo "rsync -aH --stats --delete --filter=merge /tmp/incfilter.log --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/ --log-file=${target}${rlt}${MODULENM}.bak.log"
		        	fi
		        	if [ "$ANALYTICS" == "true" ]; then
		               echo "Then check the logfile for any errors. Add up all the bytes sent values and put total count=  at the top of the file before END ORIGINAL FILES.  if you want to keep exact track."
		            fi
		        else
		        	echo "rsync -aH --delete --filter=merge /tmp/incfilter.log --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/"
		        fi
		        echo
		        echo "Or failing that"
		        printf 'rsync -aHv "%s" newdirectory/\tto make a new backup\n' "${target}${rlt}${MODULENM}/"
		        exit 1
            elif [ $exc -eq 24 ]; then
				cyan "Some files have vanished. Check for excluding cache files"
				sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
			fi
            if [ -s $UPDATE ]; then
                c=$( wc -l < "$UPDATE") # total count
                if (( c > 17)); then sentinal="true"; cp $UPDATE /tmp/parity.txt; fi
                sed -n '/Number of files/,$p' $UPDATE >> "${target}${rlt}${MODULENM}.bak.log"
            fi
        fi
		end=$(date +%s.%N)
        cyan "Changes backup has been updated."

        if [ "$ANALYTICS" == "true" ]; then
			ossize=$( sed -nE 's/.*original size\(source\)=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n 1)
            if [ "$ossize" == "" ]; then oput="Unkown" ; else oput="$(( ossize / mbyte )) MB" ; fi

            csize=$(du -sb "${target}${rlt}${MODULENM}.bak/" | cut -f1)
            nsize=$osize
            c=$( sed -nE 's/.*total count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n 1)
            c="${c:-0}"

            if [ "$adtCMD" != "" ]; then
                z=$( tail -n1 ${target}${rlt}${MODULENM}.bak.log | grep -oP '(?<=sent\s)\d+(?=\s+bytes)' | head -n1)
				if (( z == 0 )); then z=$(tail -n 20 ${target}${rlt}${MODULENM}.bak.log | grep -oP '(?<=sent\s)[\d,]+' | tail -n 1 | sed 's/,//g'); fi
            elif [ "$adtCMD" == "" ] && [ "$nLOG" == "true" ]; then
                if [ "$ANALYTICS" ==  "true" ]; then
                    green "A new log file has been made."
                fi
                z=$( tail -n2 ${target}${rlt}${MODULENM}.bak.log | head -n1 | grep -oP '(?<=sent\s)[\d,]+' | tr -d ',' )
            fi

            r=$(( c + z ))  # our new count
            grep -q "total count=" "${target}${rlt}${MODULENM}.bak.log" && sed -i "s/total count=[0-9]\+/total count=$r/" ${target}${rlt}${MODULENM}.bak.log || sed -i "/END ORIGINAL FILES/ i\total count=$r" "${target}${rlt}${MODULENM}.bak.log"

            c=$( sed -nE 's/.*original count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n 1)
            c="${c:-0}"
            if (( c != 0 )); then cyan " Since the original backup was first made sent" $(( ( c + z ) / mbyte )) "MB worth of data" ; fi
              
            if [ "$logSPRF" != "stop" ] && [ "$nLOG" == "true" ]; then
                size=$( stat -c %s "${target}${sfilesrlt}${MODULENM}.bak.log")
                if (( size > logSIZE * mbyte )); then
                red "New log file made is greater than the limit. adjust if needed to keep log data on next backup."
                fi
            fi
            cyan "You have sent $(( r / mbyte )) MB worth of data to the ${target}${rlt}${MODULENM}.bak/ backup"
            green "Sent $(( z / mbyte )) MB to backup. " ; echo
            if  [ "$adtCMD" != "" ] && [ "$nLOG" == "true" ]; then cyan "Size of source when backup first made: $oput" ; green "Current size of source: $(( osize / mbyte ))" ; fi
            green "Current size of backup: $(( csize / mbyte )) MB"         #actual size of backup

            if [ "$nLOG" == "true" ]; then echo ; cyan "You saved $(( (nsize - csize) / mbyte )) MB by generating this backup." ; fi
            
            if [ "$ANALYTICSECT" == "true" ] ; then el=$(awk "BEGIN {print $end - $start}") ; printf "Saving took %.3f seconds.\n" "$el" ; fi
            if [ "$sentinal" == "true" ]; then
                rm $UPDATE
                echo -e "\nYou are seeing this message as you have most likely deleted an entire directory on the source."
                echo "rsyan will not remove a non empty directory on the backup that is empty on the source for safety reasons."
                echo " check parity.txt in /tmp to see what these directories are and delete them in the backup."
            fi
        fi
    else
		if [ "$ANALYTICS" == "true" ]; then start=$(date +%s.%N); fi
		mkdir ${target}${rlt}${MODULENM}.bak
		if [ -f "${target}${rlt}${MODULENM}.bak.log" ]; then
			glog "true"
		else
			dlog
			if [ "$LOGGING" == "true" ]; then
					echo "original size(source)=$osize" >> "${target}${rlt}${MODULENM}.bak.log"
					echo "END ORIGINAL FILES" >> "${target}${rlt}${MODULENM}.bak.log"
        	fi
		fi
		if [ "$LOGGING" == "false" ]; then test -f "${target}${rlt}${MODULENM}.bak.log" && rm "${target}${rlt}${MODULENM}.bak.log" ; fi
        cyan "Creating new backup this may take a few minutes."

        if [ "$FEEDBACK" != "true" ]; then
            rsync -aH --stats --filter="merge /tmp/incfilter.log" --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" >> "${target}${rlt}${MODULENM}.bak.log" 2>&1
        else
			rsync -aHv --stats --delete --filter="merge /tmp/incfilter.log" --delete-excluded --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" | tee -a "${target}${rlt}${MODULENM}.bak.log"
        fi
		exc=$?
        if [ $exc -eq 1 ]; then
            mount -o remount,udba=none /
            red "rsync failed — check log at ${target}${rlt}${MODULENM}.bak.log"
            cyan "Please check the logfile if its a valid backup or try again."
            cyan "failing that delete the backup and try again."
            rm -rf $tmp       #delete temporary files
            exit 1
        elif [ $exc -eq 24 ]; then
			cyan "Some files have vanished. Check for excluding cache files"
			sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
		fi
		end=$(date +%s.%N)
        cyan "Your changes backup has been created! in ${target}${rlt}/" ; cyan "${MODULENM}.bak/"
        
        if [ "$ANALYTICS" == "true" ]; then
			if [ "$ANALYTICSECT" == "true" ] ; then el=$(awk "BEGIN {print $end - $start}") ; printf "Saving took %.3f seconds.\n" "$el" ; echo ; fi
            csize=$( du -sb "${target}${rlt}${MODULENM}.bak/" | cut -f1)
            tsize=$(( osize - csize ))
            z=$( grep "Total bytes sent:" "${target}${rlt}${MODULENM}.bak.log" | tail -n 1 | sed -E 's/[^0-9]*([0-9,]+).*/\1/' | tr -d ',')
            sed -i "/END ORIGINAL FILES/ i\total count=$z" "${target}${rlt}${MODULENM}.bak.log" #insert the total byte count
            green "You have sent $(( z / mbyte )) MB worth of data so far to the ${target}${rlt}${MODULENM}.bak/ backup"
            cyan "You saved $(( tsize / mbyte )) MB by creating this backup"
        fi
        echo
    fi
	cd $pst
else # Graphics mode
	if [ "$ANALYTICS" == "true" ]; then start=$(date +%s.%N); fi
    if [ "$d2drive" == "true" ] && [ "$d2dmdl" == "true" ]; then
		if [ -z "$mdldvc" ]; then xtgt="$thetgt" ; else xtgt="$mdldvc" ; fi
		#test -d $thetgt/tmp && { mkdir $thetgt/tmp$$; tmp=$thetgt/tmp$$; } || { mkdir $thetgt/tmp; tmp=$thetgt/tmp; }
		test -d $xtgt/mtmp && mtmp=$xtgt/mtmp$$ || mtmp=$xtgt/mtmp
		green "Staging xzm to local hdd on d2dmdl..."
    	#for x in $FOLDERS; do cp -arv $ch/"$x" $tmp &> /dev/null ; done
    fi
    SERIAL=`date +"%m-%d-%y_%R"|tr ':' '_'`
	line=43 #Bootloader
	pth="/boot/syslinux/porteus.cfg"
 	
    [[ -n "$bootdvc" ]] && thetgt=$bootdvc && [[ -n "$grubln" ]] && { line=$grubln ; pth="/boot/grub/grub.cfg"; }  
    test -e "$thetgt$pth" && rltt=$( sed -n "${line}p" "$thetgt$pth" | grep -oP 'extramod=\K[^ ]*') # Avoid confusion we initially stored rlt and can reference it. so use rltt
    epath=$(printf '%s' "${target}${em}" | sed 's/[&|]/\\&/g')
    if [ "$rltt" != "" ]; then  
        if [[ ! "${rltt}" == *$BASEDIR"/"$emfld* ]]; then
            test -d "$target$em" || mkdir -p "$target$em"
			[[ -n "$grubln" ]] && test -e $thetgt$pth && cp $thetgt$pth $thetgt$pth$$.bak
            sed -i "s|\(extramod=\)\([^ ]*\)|\1${epath};\2|" "$thetgt$pth"
            loadermsg
            IFS=';' read -ra parts <<< "${rltt}"
            unset IFS ; u=""
            for part in "${parts[@]}"; do
                erlt=$( sed -n "${line}p" "$thetgt$pth" | grep -oP 'extramod=\K[^ ]*')
                testfile="${part}/.writetest_${$}"
                if touch "$testfile" 2>/dev/null; then
                    rm -f "$testfile"
                    for file in "${part}"/*_uid_*; do [ -e "$file" ] || continue ; mv "$file" "${target}${em}" ; u="true" ; done
                else
                    echo "$part was not writable some previous changes modules with _uid_ could not be moved"
                fi
                if [ "$u" == "true" ]; then
					test -d $part"/archive" && mv $part"/archive" "${target}${em}" ; test -e $part"/lscheck" && mv $part"/lscheck" "${target}${em}" ; test -e $part"/mergemodules" && rm $part"/mergemodules"  
                    test -e $part"/createlmodule" && rm $part"/createmodule" ; test -e $part"/renameLbak" && rm $part"/renameLbak" ; test -e $part"/renamebak" && rm $part"/renamebak"
                fi
                if [ "$u" == "true" ] && [ -d "$part" ] && [ -z "$(ls -A "$part")" ]; then
                    erlt="${erlt//;$part/}"
                    erlt="${erlt//$part;/}"
                    erlt="${erlt//$part/}"
                    erlt=$(printf '%s' "$erlt" | sed 's/[&|]/\\&/g')   #escape | and also & which may appear in a directory so doesnt break sed
                    sed -i "s|\(extramod=\)[^ ]*|\1${erlt}|" "$thetgt$pth"
                    cyan "bootloader updated"
                fi
            done
            if [ "$u" != "" ]; then green "all previous changes modules in other extramod directories moved to new extramod dir" ; fi
        fi
    else
		cmd="sed -i \"0,/APPEND/ s|\\(APPEND\\)|\\1 extramod=${epath}|\" \"$thetgt$pth\""
		if [ -n "$grubln" ]; then test -e $thetgt$pth && cp $thetgt$pth $thetgt$pth$$.bak ; cmd="sed -i \"${line}s|\\\$| extramod=$epath/|\" \"$thetgt$pth\"" ; fi
		test -e "$thetgt$pth" && bash -c "$cmd" || echo "Using other bootloader append ${target}${em} to it with extramod="
    fi # END Bootloader

    if [ -s "${target}${em}${MODULENM}${SERIAL}_uid_$$.xzm" ]; then
		echo ; echo A changes .xzm was detected but nothing was done. ; cyan "${MODULENM}${SERIAL}_uid_$$.xzm already exists" && { sleep 5; exit 0; }
    else
        test -d "$target$em" || mkdir "$target$em"+
        touch "$target$em/._test1" 2>/dev/null
        cyan "testing filesystem on ${target} for posix compatibility"
        ln -s "$target$em"/._test1 "$target$em"/._test2 2>/dev/null && chmod +x "$target$em"/._test1 2>/dev/null && [ -x "$target$em"/._test1 ] && chmod -x "$target$em"/._test1 2>/dev/null && [ ! -x "$target$em"/._test1 ] && rm -f "$target$em"/._test1 "$target$em"/._test2
		if [ $? -ne 0 ]; then
            mount -o remount,udba=none /
            rm -f "$target$em"/._test1 "$target$em"/._test2
			echo && echo -e "[1;33m""A Windows filesystem (FAT, NTFS) or other non-posix compatible filesystem\nhas been detected on $target.\nYour changes cannot be saved directly to the specified storage media with this\nsetup. Please use the '[1;36mPorteus save file manager[1;33m' to create a .dat container\nand use it for saving your changes after your next reboot.""[0m"
            exit
        fi
        r=$(find "$target$em" -maxdepth 1 -type f -name '*_uid_*.xzm' | wc -l)
        if [ "$r" -eq 0 ]; then # if this is the first time running and there isnt a symlink to the merge script create it
            if [ ! -e "$target$em"/mergemodules ]; then ln -s /usr/local/save-changesnew/mergemodules.sh "$target$em"/mergemodules; fi
			if [ ! -e "$target$em"/createlmodule ]; then ln -s /usr/local/save-changesnew/createlmdl.sh "$target$em"/createlmodule; fi
            if [ ! -e "$target$em"/renamebak ]; then ln -s /usr/local/save-changesnew/renamebak "$target$em"/renamebak; fi
            if [ ! -e "$target$em"/renameLbak ]; then ln -s /usr/local/save-changesnew/renameLbak "$target$em"/renameLbak; fi
        fi
        pst=$PWD
        if [ "$linkedSTATE" == "true" ]; then
            f=$(find "$target$em" -maxdepth 1 -type f -name '*_uid_L*.xzm' | wc -l)
            if [ "$f" -gt 1 ]; then
                echo "Cannot have more than one _uid_L\.\*\.xzm file" && exit 0
            elif [ "$f" -eq 1 ]; then  # Good to go
                rlt=""
                if [ -e $msr ]; then
                    content=$(awk -v RS= '{gsub(/\n+$/, "", $0); print $0}' "$msr")
                    k=$( echo "$content" | sed -n 's/.*bytes:[[:space:]]*\([0-9]\+\).*/\1/p')
                    if [ "$k" != "" ]; then
                        p=$( echo "$content" | sed -n 's/^file name:[[:space:]]*\(.*\)/\1/p')
                        if [ "$p" != "" ]; then
                            if [ -f $target$em"/"$p ]; then
                                c=$( du -sb "${target}${em}/${p}" | cut -f1)
                                if [ "$c" -eq "$k" ]; then
                                    ssbn=$( echo $p | sed -n 's/.*_uid_L\(.*\)\.xzm$/\1/p')
                                    if [ "$ssbn" == "" ]; then cyan "failed to parse ssbn in msr"; fi
                                else
                                    validrlt="false"
                                fi
                                fname=$p ; rlt="true"
                            fi
                        fi
                    fi
                    if [ "$rlt" == "true" ]; then
                        createlmdl "msr"
                    else
                        cyan "Bad msr file. making new serial no. the previous one will be renamed to .bak" ; createlmdl "badmsr" 
                    fi
                else
                    createlmdl "nomsr"
                fi
                cd $pst
            elif [ "$f" -eq 0 ]; then
                createlmdl "nolmdl"
            fi
        else # End linked
            rname="${MODULENM}${SERIAL}_uid_${$}.xzm" ; newxzm "uid"
        fi
        chown $USR $target$em$rname
		if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then printf "Saving took %.3f seconds.\n" "$el" ; fi
        cyan "Your changes have been saved. in ${target}${em}/" ;  cyan $rname
        if [ "$mrgMODULES" == "true" ] && [ "$linkedSTATE" == "false" ]; then
        	cd $target$em ; r=$(find . -maxdepth 1 -type f -name '*_uid_*.xzm' ! -name '*_uid_L*' | wc -l)
            if (( r > mdllmt)); then
                green "Merging changes modules..." ; sleep 5
                if ! /usr/local/save-changesnew/mergemodules.sh $keepMRGED $ROLLBCK $ROLLSUMRY $archLMT; then red "There was problem auto merging. see /tmp/error.log" ; cyan "Everything preserved." ; fi
                cyan "Modules merged."
            fi
        	cd $pst
        fi
    fi
fi
mount -o remount,udba=none /
test -e $EXCL && rm $EXCL
test -e $UPDATE && rm $UPDATE
#test -e $SFOLDERS && rm $SFOLDERS
test -e /tmp/incfilter.log && rm /tmp/incfilter.log
test -e $tmp && rm -rf $tmp ; sleep 5 && exit

