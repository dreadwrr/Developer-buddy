#!/bin/bash
#                                               Developer Buddy v5.0                Jan 13, 2026
#   this script works for two modes porteus nemesis graphics and changes.
# borrowed script items source
# # Author: fanthom <fanthom@porteus.org>
. /usr/share/porteus/porteus-functions
get_colors
. /usr/local/save-changesnew/save-changesnewfnts
if [ `whoami` != "root" ]; then echo "Please enter your root password below" ; su - -c "/usr/local/bin/save-changesnew '${BASEDIR}' '${USER}' $1 " ; exit ; else [[ -z "$2" ]] && theUSER="guest" || { theUSER=$2 ; thetgt=$1 ; } ; fi
[[ -n "$3" ]] && bck=$3 && thetgt=$1 # <----- for autosaving change to "/mnt/sda"  ie   /mnt/sda3          /etc/rc.d/rc.local_shutdown
[[ -z "$2" ]] && bck=$1 
[[ -z "$thetgt" ]] && thetgt=$BASEDIR 
[[ -z "$thetgt" ]] && "\$BASEDIR not set and is null. please set thetgt\target in $0" && exit 0

if ! id $2 >/dev/null 2>&1; then echo "user:" ${2} "not found"; exit 0 ; fi # quick user check we test the target directory $1 after VARS
if ! grep -iq "Artix" /etc/os-release; then echo "Wrong version of developer buddy. Please use porteus version." && exit 0 ; fi
# CHANGABLE
autobackup="true"           # Graphics changes only /etc/rc.d/rc.local_shutdown will be called to sync the backup on shutdown. Once run it will set itself to -x
										# so there is no accidental saving if forgetting to turn off. Useful if doing something important. save-changesnew y  or save-changesnew yes   to enable


d2drive="true"                 # default is true   also for systems with low memory save directly to drive
                                          # false. save to memory for staging purposes and convenience of modifying the script ect
                                           # more versatle to do any work or processing exclusions before saving. Also freezes
											# the filesystem so can ensure better safety. d2drive has been stable so far
                                           # but systems with low memory may want to use d2drive to avoid any potential
                                           # exceedence

d2dmdl="false"					# default false  use $target or $thetgt the harddrive for temp files/work.  if not enough memory use this
mdldvc=""                        # default null. This device rather than porteus install drive for temp files/work.      ie /mnt/sda3
										# avoid trailing /

grubln=""								# default null.  Point to Line number ie  linux /boot/syslinux/vmlinuz from=/dev/nvme0n1p4 root= ...   to automatically update grub for graphics extramod to boot with changes
											# example grub entry from current system.  set to "435" . if extramod is not there it is appended to end of line as below. If extramod is there its inserted with a ;
												#menuentry "Nemesis graphics" {
												#    set root='hd3,gpt6'
												#    linux /boot/syslinux/vmlinuz from=/dev/nvme0n1p6 root=UUID=aeb00f60-ff73-4318-80ca-c647ea08a619 extramod=/mnt/nvme0n1p6/extramod/                  ln435
												#    initrd /boot/syslinux/initrd.xz
												#}

bootdvc=""		                     # default null. required for above device where grub is installed. ie /mnt/nvme0n1p5 from current system
												# avoid trailing /


target=$thetgt                               # change this to specify the location of porteus install this is passed from root call where porteus is installed via $BASEDIR
													# in some root environments $BASEDIR is null so set either here or at the top of script ln11 if having problems
                                                # examples      "/mnt/sdx"   ie /mnt/sda3
                                                #                   "/dev/sdx"
                                               # avoid trailing /


#Folders to include from changes      adjust if wanted            set to include changes-exit default folders
FOLDERS="bin etc home lib lib64 opt root sbin usr var"


#Folders to exclude from changes
EXCLUDE="/var/cache /var/run /var/tmp share/Trash"   #default changes-exit configuration
                                            # keep original format  /var/run    is the base directory var
                                            # seperate with space            anything else other than starting / will be a pattern *****  ie share/Trash



chxzm="/changes.xzm"            #Module  name  change this if you want to customize the name
                                                # retain leading / and ensure it ends in .xzm
                                               #avoid trailing / and any spaces

em="/extramod"                      #change this to save a different folder       the extramod dirtory
                                                # retain leading /
												# avoid trailing /


cmode="gzip"                            # default nothing. uses gzip compression level balanced
                                           # xz        best compression
                                           # zstd     faster bootup
                                            # lzo      faster bootup

logSIZE=35                             # Log size limit default 35 MB
                                            # Will keep the original contents from when the changes.bak folder was made
                                            # if limit is exceeded. Just clears out old changes to make a new log file

logSPRF="delete"                         # When log size limit reached 
                                            # delete    delete the log to save space and make a new one with new master list
                                            # psv       preserve 25% of the last changes but take into account new changes so
                                            #           we are not over 25% of the log max size limit thus we grab 10-15% of the
                                            #           most recent changes append new ones to reach the 25% quota
                                            #
                                            #           end result preserves the original format and any original master list
                                            #
                                            # stop      dont log anymore

mdlMRGPRF="forward"		# forward   dynamic merging first on mdllmt to save a write and time. implements logic or guardian system  default forward
										# 			to do everything in one step.
										# back    merge the modules afterwards if exceeding mdlmt. original with no extra logic

mdllmt=12                           # Auto Graphics mode module merging default 7
                                                # when reached will automatically merge if mrgMODULES is set to true below
                                                # see mrgMODULES boolean


mdlLOGPRF="incr"          # default incr  new log of only changes keeps log size down
                                            # full log from creation all files and then append changes
                                            # false      dont log the linked module


namingPRF="alpha"				# default alpha 
												# numeric


# CHANGABLE BOOLEANS
mrgAEX="true"				# the changes are copied to the merge with the exclusions. Then this setting would apply to whether to apply 
									# those exclusions for the final module.  the exclusions could have changed and this can reduce the final module size
									# which is why its default

										# true - apply the exclusions like usual
										# false 		keep the modules and files as they were at the time those exclusions were set for those modules.

# Linked state options
linkedSTATE="false"             #This is precendence for changes:EXIT only on graphics mode. Default false
                                           # This implies that you want changes made INCLUDING deletes to the module.
											# If you dont do frequent saving this mode is useful as all deletions are applied
                                           # and there will be only one changes module if a _uid_L prefix
                                           # linked state needs all changes modules to be created together thus you should
                                           # start with one that has linkedSTATE made. A byte count of this .xzm is made
                                           # and logged into a txt file by the modules. see extramod/ folder for createlmodule script
											# to convert to an l module.
                                           #
                                           # This text file will tell it that it is a linked state module.

keepLINKEDMRGED="false"  # default is false so delete the old ones after merging if they are not in sync with each other
                                           # it automatically renames the old one to .bak. ****

# Non linked state options
mrgMODULES="true"           # Automatically merge changes modules if over limit value
                                        #change this to automatically merge changes.xzm modules  ( applies to Graphics mode)
                                        # see $BASEDIR/extramod for mergemodule script to merge changes modules

keepMRGED="true"       	# default is false so delete the old ones after merging
# End Non linked state options





# Terminal output / feedback
FEEDBACK="false"                # default false     New version 3 feature
                                            # show more verbose feedback from rsync ect in terminal while saving

LOGGING="true"                  # default is true change if you dont want logging

ANALYTICS="true"            # logging must be set to true       default true     or set to false to turn off too much info
                                        # if false will just output rsync changes
                                        # if it exceeded logSIZE then the original contents when the backup was made is preserved
                                        # and then a new logfile is made then rsync appends any changes during updates until
                                        # the limit is exceeded again.
                                      # If true Will give total space saved if making a complete new backup
                                        # more data in the log file and custom info by this script
                                        # extra stuff like if the log file exceeded logSIZE and a new one is made
                                        # it will list the contents of the ORIGINAL backup, the contents of the current backup
                                        # and list the file differences as well. Then rsync will continue to input changes.
                                        # you also get total MB saved if you had manually backed up the changes folder ect

ANALYTICSECT="true"		# disable metric saving time. ect.
# End Terminal output

# Backup mode for Graphics modules
ROLLBCK="false"				# backup module after merged to be able to "rollback" by loading any single module
 			 							# When modules have been merged a copy is made and moved to /archive/
										# takes up more space. but the single module has all changes at a point in time.

ROLLSUMRY="false"            # default false    Include file manifest for archives

archLMT=4						# how many unique roll backs to keep  both _uid_ and _uid_L seperately
# End Backup mode
# END CHANGABLE BOOLEANS
# END CHANGABLE

#VARS
tmp=/mnt/live/tmp/work$$									; 			mtmp=/mnt/live/mtmp$$ # mtmp=/tmp/mtmp$$
ch=/mnt/live/memory/changes							;			INAME=/mnt/live/memory/images
SFOLDERS=/tmp/save.sfolders.tmp						;			trsyncexl=/usr/local/save-changesnew/excld.ini
EXFILES=/tmp/exfiles.log									;			EXCL=/tmp/save.excl.tmp	 # for egrep regrex
QEXCL=/tmp/squashexfiles.log							;			EXCLUDED=/tmp/save.excluded.tmp
EXFILES=/tmp/save.exfiles.tmp							;			exclfiles=/tmp/save.squashregex.tmp  #spare tmp
UPDATE=/tmp/save.update.tmp							;			oMF=/tmp/flog.log
CHNEXIT_CONF=/etc/changes-exit.conf				;			chc=/etc/rc.d/rc.local_shutdown
USR=$theUSER													;			LOGDIR=/home/$USR/Downloads
SFILES=/tmp/save.sfiles.tmp								;			elog=/tmp/error.log
LOGFILE=save.sfiles.tmp									;			SVFILES=$tmp/save.rncfilesmanifest.tmp  # spare tmp file
elog=/tmp/error.log  #debug file \ errors
elapse=0
mbyte=1048576												;			osize=0
IFOLDERS=""														;			rname=""
adtCMD=""														;			MODULENM=""
sentinal=""														;			rlt=""

is_routine="true"												;			goahead="true"
dirtybit="false"													;			is_moved="false"

autosave $3
[[ "$mdllmt" -eq 0 ]] && echo "mdllmt > 0 current value $mdllmt" && exit 0
if [ "$mdlMRGPRF" != "forward" ] && [ "$mdlMRGPRF" != "back" ]; then echo "invalid mdfMRGPRF: $mdlMRGPRF , forward or back" && exit 0 ; fi
if [ "$namingPRF" != "alpha" ] && [ "$namingPRF" != "numeric" ]; then echo "invalid setting namingPRF: $namingPRF" && exit 0 ; fi
if [ "$LOGGING" == "false" ] && [ "$ANALYTICS" == "true" ]; then echo analystics requires logging to be true. && exit 0 ; fi
if [ ! -e $target ]; then echo "Target does not exist" && exit 0 ; fi
msr=${target}${em}"/lscheck"

IFOLDERS="$(for x in $(grep ^/ $CHNEXIT_CONF | sed s/.//); do test -e $ch/"$x" && echo "$x"; done)"

dycmb ; exldir $EXFILES ; cyan "Syncing what's left in buffers" && sync
if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then start=$(date +%s.%N); fi
mount -o remount,udba=notify /
MODULENM="${chxzm%.xzm}" ; mdlnm="${MODULENM#/}" ; bootdvc="${bootdvc%/}" ; mdldvc="${mdldvc%/}"  #normalize
rlt=$(sed -n 's/.*changes=\([^ ]*\).*/\1/p' /proc/cmdline)
if [ "$d2drive" == "false" ] || { [ "$d2drive" == "true" ] && [ "$d2dmdl" == "false" ] ; } ; then green "Staging... " ; else green "Direct to drive saving" ; fi
if [ "$rlt" != "" ]; then
    if [ "$rlt" == "/" ]; then rlt="" ; fi
	[[ "$rlt" == *"/dev/"* ]] && rlt=${rlt//dev/mnt}
	[[ "$rlt" == *"$target"* ]] && rlt=${rlt%/} && target=""
	osize=$( du -sb "${target}${rlt}${MODULENM}/" | cut -f1)
    : > /tmp/incfilter.log
    if [ "$d2drive" == "true" ]; then
        dirSRC="$target$rlt/changes"
		for folder in $FOLDERS; do echo "+ /$folder/" >> /tmp/incfilter.log ; done
		for fld in $EXCLUDE; do if [[ "${fld:0:1}" == "/" ]]; then fld="${fld#/}" ; else fld="*${fld}*" ; fi ; echo "- /$fld/" >> /tmp/incfilter.log ; done
		echo "- /*" >> /tmp/incfilter.log
    else
		mkdir $tmp ; dirSRC=$tmp
		for x in $FOLDERS; do cp -arv $ch/"$x" $tmp &> /dev/null ; done
    fi
	pst=$PWD ; cd $dirSRC

    if [ -d "${target}${rlt}${MODULENM}.bak/" ]; then
        green "Updating existing backup..."
        if [ "$LOGGING" == "true" ]; then
            if [ -s "${target}${rlt}${MODULENM}.bak.log" ]; then
                m=$(head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -c "STOP")
                if (( m == 0 )); then
                    adtCMD="--log-file=${target}${rlt}${MODULENM}.bak.log"
                    if grep -B 1 'END ORIGINAL FILES' "${target}${rlt}${MODULENM}.bak.log" | tail -2 | head -1 | grep -q '^PAUSED$'; then
                        glog
                    else

                        l=$(head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -c "PAUSED")
                        size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")

                        if [ "$size" -gt $((logSIZE * mbyte)) ]; then
                            if [ "$ANALYTICS" == "true" ]; then
                                cyan "Log file has hit the limit. Clearing..."
                            fi

                            if [ "$logSPRF" == "delete" ]; then

                                if grep -q "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log"; then
                                    glog "true"
                                else
                                    : > "${target}${rlt}${MODULENM}.bak.log"
								fi

                            elif [ "$logSPRF" == "psv" ]; then

                                c=$( wc -l < "${target}${rlt}${MODULENM}.bak.log") # total count
                                q=$(awk "BEGIN {print $c * 0.85}")
                                if (( l == 1 )); then
                                    sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE

                                else

                                    h=$( grep -m 1 -n "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log" | awk -F: '{print $1}') # what line is it on
                                    b=$(( h + 16 ))

                                    if [ "$h" !=  "" ]; then

                                        if [[ $b -le $c ]]; then

                                            if sed -n "$(( h + 16))p" "${target}${rlt}${MODULENM}.bak.log" | grep -q "total size is"; then
                                                sed "${b}q" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
                                            else
                                                 sed '/END ORIGINAL FILES/q' "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
                                            fi

                                        else
                                            sed '/END ORIGINAL FILES/q' "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
                                        fi

                                        sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" >> $UPDATE

                                    else
                                        sed -n "${q}, \$p" "${target}${rlt}${MODULENM}.bak.log" > $UPDATE
                                    fi
                                fi
                                if [ "$ANALYTICS" == "true" ]; then
                                    size=$( stat -c %s "${target}${rlt}${MODULENM}.bak.log")
                                    if (( size > logSIZE * mbyte )); then
                                        cyan "Log size limit reached on preserve mode. Please adjust max limit or logging preference."
                                        cyan "This means the file list is greater than the limit or the limit is too small."
                                    fi
                                fi

                                mv $UPDATE "${target}${rlt}${MODULENM}.bak.log"

                            elif [ "$logSPRF" == "stop" ]; then
                                adtCMD=""
                                if [ "$ANALYTICS" == "true" ]; then
                                    cyan "Log file hit max limit not logging..."
                                fi
                                if (( l >= 1 )); then
                                    sed -i '1s/PAUSED/PAUSEDSTOP/g' "${target}${rlt}${MODULENM}.bak.log"
                                else
                                    sed -i '1i STOP' "${target}${rlt}${MODULENM}.bak.log"
                                fi
                            fi
                        fi
                    fi
                    if (( l >= 1 )); then sed -i '0,/PAUSE/ { /PAUSE/ d }' "${target}${rlt}${MODULENM}.bak.log"; fi
                fi
            else
                nsize=$osize
                green "There was no logfile generating..." ; > "${target}${rlt}${MODULENM}.bak.log" ; dlog
                { echo ;  echo "original size(source)=Unkown" ; echo "new size(source)=$nsize" ; echo  "END ORIGINAL FILES $(date +"%m-%d-%y_%R")"; } >> "${target}${rlt}${MODULENM}.bak.log"
		        nLOG="true"
			fi

        else

            if [ -f "${target}${rlt}${MODULENM}.bak.log" ]; then

                if ! grep -B 1 'END ORIGINAL FILES' "${target}${rlt}${MODULENM}.bak.log" | tail -2 | head -1 | grep -q '^PAUSED$'; then

                    if grep -q "END ORIGINAL FILES" "${target}${rlt}${MODULENM}.bak.log"; then

                        sed -i "/END ORIGINAL FILES/ i\PAUSED" "${target}${rlt}${MODULENM}.bak.log" # Put PAUSED above END OF ORIGINAL FILES

                    else

                        if ! head -n 1 "${target}${rlt}${MODULENM&> /dev/null}.bak.log" | grep -q 'PAUSED'; then
                            if head -n 1 "${target}${rlt}${MODULENM}.bak.log" | grep -q 'STOP'; then
                                sed -i '1{/STOP/ s/^/PAUSED/}' "${target}${rlt}${MODULENM}.bak.log"
                            else
                                  sed -i '1i PAUSED' "${target}${rlt}${MODULENM}.bak.log"
                            fi
                        fi
                    fi
                fi
            fi
        fi

        if [ "$adtCMD" != "" ]; then
            if [ "$FEEDBACK" != "true" ]; then
                rsync -aH --delete --filter="merge /tmp/incfilter.log" --delete-excluded --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" $adtCMD
            else
				rsync -aHv --delete --filter="merge /tmp/incfilter.log" --delete-excluded --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" | tee -a "${target}${rlt}${MODULENM}.bak.log"
            fi
			exc=$?
            if [ $exc -eq 1 ]; then
		        mount -o remount,udba=none /
		        red "rsync failed â€” check log at ${target}${rlt}${MODULENM}.bak.log"
		        if [ "$d2drive" == "false" ]; then
		        	cyan "Files left in memory. Copy and paste the following to rsync again:"
		        	echo "rsync -aH --delete --filter=merge /tmp/incfilter.log --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/ --log-file=${target}${rlt}${MODULENM}.bak.log"
		        	if [ "$ANALYTICS" == "true" ]; then
		        		echo "Then check the logfile for any errors.Then take the last two bytes sent and add it to total count=  at the top of the file if you want to keep exact track."
		        		echo "Or"
		        		printf 'rsync -aHv "%s" newdirectory/\tto make a new backup\n' "${target}${rlt}${MODULENM}/"
		        	fi
		        else
		  		    if [ "$ANALYTICS" == "true" ]; then
		        		echo "Add up the last bytes sent values and add to total count=  at the top of the file before END ORIGINAL FILES.  if you want to keep exact track."
		        	fi
		        fi
		        exit 1
			elif [ $exc -eq 24 ]; then
				cyan "Some files have vanished. Check for excluding cache files"
				sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
			fi
        else
            if [ "$nLOG" != "" ]; then
                if [ "$FEEDBACK" != "true" ]; then
                   rsync -aH --stats --delete --filter="merge /tmp/incfilter.log" --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" > $UPDATE 2>&1

                else
                    rsync -aH --stats --delete --filter="merge /tmp/incfilter.log" --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" 2>&1 | tee $UPDATE
                fi
            else
                if [ "$FEEDBACK" != "true" ]; then
                    rsync -aH --delete --filter="merge /tmp/incfilter.log" --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" > /dev/null
                else
                    rsync -aH --delete --filter="merge /tmp/incfilter.log" --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/"
                fi
            fi
			exc=$?
            if [ $exc -eq 1 ]; then if [ "$ANALYTICS" == "true" ]; then end=$(date +%s.%N) ; el=$(awk "BEGIN {print $end - $start}") ; fi
		        mount -o remount,udba=none /
		        red "rsync failed â€” check log at ${target}${rlt}${MODULENM}.bak.log"
		        if [ "$nLOG" != "" ]; then
		        	if [ "$d2drive" == "false" ]; then
		        		cyan "Files left in memory. Copy and paste the following to rsync again:"
		            	echo "rsync -aH --stats --delete --filter=merge /tmp/incfilter.log --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/ --log-file=${target}${rlt}${MODULENM}.bak.log"
		        	fi
		        	if [ "$ANALYTICS" == "true" ]; then
		               echo "Then check the logfile for any errors. Add up all the bytes sent values and put total count=  at the top of the file before END ORIGINAL FILES.  if you want to keep exact track."
		            fi
		        else
		        	echo "rsync -aH --delete --filter=merge /tmp/incfilter.log --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ ${target}${rlt}${MODULENM}.bak/"
		        fi
		        echo
		        echo "Or failing that"
		        printf 'rsync -aHv "%s" newdirectory/\tto make a new backup\n' "${target}${rlt}${MODULENM}/"
		        exit 1
            elif [ $exc -eq 24 ]; then
				cyan "Some files have vanished. Check for excluding cache files"
				sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
			fi
            if [ -s $UPDATE ]; then
                c=$( wc -l < "$UPDATE") # total count
                if (( c > 17)); then sentinal="true"; cp $UPDATE /tmp/parity.txt; fi
                sed -n '/Number of files/,$p' $UPDATE >> "${target}${rlt}${MODULENM}.bak.log"
            fi
        fi
		end=$(date +%s.%N)
        cyan "Changes backup has been updated."

        if [ "$ANALYTICS" == "true" ]; then
			ossize=$( sed -nE 's/.*original size\(source\)=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n 1)
            if [ "$ossize" == "" ]; then oput="Unkown" ; else oput="$(( ossize / mbyte )) MB" ; fi

            csize=$(du -sb "${target}${rlt}${MODULENM}.bak/" | cut -f1)
            nsize=$osize
            c=$( sed -nE 's/.*total count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n 1)
            c="${c:-0}"

            if [ "$adtCMD" != "" ]; then
                z=$( tail -n1 ${target}${rlt}${MODULENM}.bak.log | grep -oP '(?<=sent\s)\d+(?=\s+bytes)' | head -n1)
				if (( z == 0 )); then z=$(tail -n 20 ${target}${rlt}${MODULENM}.bak.log | grep -oP '(?<=sent\s)[\d,]+' | tail -n 1 | sed 's/,//g'); fi
            elif [ "$adtCMD" == "" ] && [ "$nLOG" == "true" ]; then
                if [ "$ANALYTICS" ==  "true" ]; then
                    green "A new log file has been made."
                fi
                z=$( tail -n2 ${target}${rlt}${MODULENM}.bak.log | head -n1 | grep -oP '(?<=sent\s)[\d,]+' | tr -d ',' )
            fi

            r=$(( c + z ))  # our new count
            grep -q "total count=" "${target}${rlt}${MODULENM}.bak.log" && sed -i "s/total count=[0-9]\+/total count=$r/" ${target}${rlt}${MODULENM}.bak.log || sed -i "/END ORIGINAL FILES/ i\total count=$r" "${target}${rlt}${MODULENM}.bak.log"

            c=$( sed -nE 's/.*original count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log | head -n 1)
            c="${c:-0}"
            if (( c != 0 )); then cyan " Since the original backup was first made sent" $(( ( c + z ) / mbyte )) "MB worth of data" ; fi

            if [ "$logSPRF" != "stop" ] && [ "$nLOG" == "true" ]; then
                size=$( stat -c %s "${target}${sfilesrlt}${MODULENM}.bak.log")
                if (( size > logSIZE * mbyte )); then
                red "New log file made is greater than the limit. adjust if needed to keep log data on next backup."
                fi
            fi
            cyan "You have sent $(( r / mbyte )) MB worth of data to the ${target}${rlt}${MODULENM}.bak/ backup"
            green "Sent $(( z / mbyte )) MB to backup. " ; echo
            if  [ "$adtCMD" != "" ] && [ "$nLOG" == "true" ]; then cyan "Size of source when backup first made: $oput" ; green "Current size of source: $(( osize / mbyte ))" ; fi
            green "Current size of backup: $(( csize / mbyte )) MB"         #actual size of backup

            if [ "$nLOG" == "true" ]; then echo ; cyan "You saved $(( (nsize - csize) / mbyte )) MB by generating this backup." ; fi

            if [ "$ANALYTICSECT" == "true" ] ; then el=$(awk "BEGIN {print $end - $start}") ; printf "Saving took %.3f seconds.\n" "$el" ; fi
            if [ "$sentinal" == "true" ]; then
                rm $UPDATE
                echo -e "\nYou are seeing this message as you have most likely deleted an entire directory on the source."
                echo "rsyan will not remove a non empty directory on the backup that is empty on the source for safety reasons."
                echo " check parity.txt in /tmp to see what these directories are and delete them in the backup."
            fi
        fi
    else
		if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then start=$(date +%s.%N); fi
		mkdir ${target}${rlt}${MODULENM}.bak
		if [ -f "${target}${rlt}${MODULENM}.bak.log" ]; then
			glog "true"
		else
			dlog
			if [ "$LOGGING" == "true" ]; then
					echo "original size(source)=$osize" >> "${target}${rlt}${MODULENM}.bak.log"
					echo "END ORIGINAL FILES" >> "${target}${rlt}${MODULENM}.bak.log"
        	fi
		fi
		if [ "$LOGGING" == "false" ]; then test -f "${target}${rlt}${MODULENM}.bak.log" && rm "${target}${rlt}${MODULENM}.bak.log" ; fi
        cyan "Creating new backup this may take a few minutes."

        if [ "$FEEDBACK" != "true" ]; then
            rsync -aH --stats --filter="merge /tmp/incfilter.log" --exclude '.wh.*' --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" >> "${target}${rlt}${MODULENM}.bak.log" 2>&1
        else
			rsync -aHv --stats --delete --filter="merge /tmp/incfilter.log" --exclude '.wh.*' --delete-excluded --exclude-from=$EXFILES --exclude-from=$trsyncexl $dirSRC/ "${target}${rlt}${MODULENM}.bak/" | tee -a "${target}${rlt}${MODULENM}.bak.log"
        fi
		exc=$?
        if [ $exc -eq 1 ]; then
            mount -o remount,udba=none /
            red "rsync failed â€” check log at ${target}${rlt}${MODULENM}.bak.log"
            cyan "Please check the logfile if its a valid backup or try again."
            cyan "failing that delete the backup and try again."
            rm -rf $tmp       #delete temporary files
            exit 1
        elif [ $exc -eq 24 ]; then
			cyan "Some files have vanished. Check for excluding cache files"
			sed -i '/some files vanished/d' "${target}${rlt}${MODULENM}.bak.log"
		fi
		end=$(date +%s.%N)
        cyan "Your changes backup has been created! in ${target}${rlt}/" ; cyan "${MODULENM}.bak/"

        if [ "$ANALYTICS" == "true" ]; then
			if [ "$ANALYTICSECT" == "true" ] ; then el=$(awk "BEGIN {print $end - $start}") ; printf "Saving took %.3f seconds.\n" "$el" ; echo ; fi
            csize=$( du -sb "${target}${rlt}${MODULENM}.bak/" | cut -f1)
            tsize=$(( osize - csize ))
            z=$( grep "Total bytes sent:" "${target}${rlt}${MODULENM}.bak.log" | tail -n 1 | sed -E 's/[^0-9]*([0-9,]+).*/\1/' | tr -d ',')
            sed -i "/END ORIGINAL FILES/ i\total count=$z" "${target}${rlt}${MODULENM}.bak.log" #insert the total byte count
            green "You have sent $(( z / mbyte )) MB worth of data so far to the ${target}${rlt}${MODULENM}.bak/ backup"
            cyan "You saved $(( tsize / mbyte )) MB by creating this backup"
        fi
        echo
    fi
	cd $pst
else # Graphics mode
	if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then start=$(date +%s.%N); fi
    if [ "$d2drive" == "true" ] && [ "$d2dmdl" == "true" ]; then
		if [ -z "$mdldvc" ]; then xtgt="$thetgt" ; else xtgt="$mdldvc" ; fi
		test -d $xtgt/mtmp && mtmp=$xtgt/mtmp$$ || mtmp=$xtgt/mtmp
		green "Staging xzm to local hdd on d2dmdl..."
    fi
    SERIAL=`date +"%m-%d-%y_%R"|tr ':' '_'`
	line=43 #Bootloader
	pth="/boot/syslinux/porteus.cfg"
    [[ -n "$bootdvc" ]] && thetgt=$bootdvc && [[ -n "$grubln" ]] && { line=$grubln ; pth="/boot/grub/grub.cfg"; }  
    test -e "$thetgt$pth" && fnd=$( sed -n "${line}p" "$thetgt$pth" | grep -oP 'extramod=\K[^ ]*')
    epath=$(printf '%s' $target$em | sed 's/[&|]/\\&/g')  #escape | and also & which may appear in a directory so doesnt break sed
    if [ "$fnd" != "" ]; then  
        if [[ ! "$fnd" == *$target${em%/}* ]]; then
            test -d $target$em || mkdir -p $target$em
			[[ -n "$grubln" ]] && test -e $thetgt$pth && cp $thetgt$pth $thetgt$pth$$.bak
            sed -i "${line}s|\(extramod=\)\([^ ]*\)|\1${epath};\2|" "$thetgt$pth"
            loadermsg
            IFS=';' read -ra parts <<< "${fnd}"
            unset IFS ; u=""
            for part in "${parts[@]}"; do
                erlt=$( sed -n "${line}p" "$thetgt$pth" | grep -oP 'extramod=\K[^ ]*')
                testfile="${part}/.writetest_$$"
                if touch "$testfile" 2>/dev/null; then
                    rm -f "$testfile"
                    for file in "${part}"/*_uid_*; do [ -e "$file" ] || continue ; mv "$file" "${target}${em}" ; u="true" ; done
                else
                    echo "$part was not writable some previous changes modules with _uid_ could not be moved"
                fi
                if [ "$u" == "true" ]; then
					test -d $part"/archive" && mv $part"/archive" "$target$em" ; test -e $part"/lscheck" && mv $part"/lscheck" "$target$em" ; test -e $part"/mergemodules" && rm $part"/mergemodules"  
                    test -e $part"/mergemodulesod" && rm $part"/mergemodulesod" ; test -e $part"/createlmodule" && rm $part"/createmodule" ; test -e $part"/renameLbak" && rm $part"/renameLbak" 
					test -e $part"/renamebak" && rm $part"/renamebak"
                fi
                if [ "$u" == "true" ] && [ -d "$part" ] && [ -z "$(ls -A "$part")" ]; then
                    erlt="${erlt//;$part/}"
                    erlt="${erlt//$part;/}"
                    erlt="${erlt//$part/}"
                    erlt=$(printf '%s' "$erlt" | sed 's/[&|]/\\&/g')   
                    sed -i "s|\(extramod=\)[^ ]*|\1${erlt}|" "$thetgt$pth"
                    cyan "bootloader updated"
                fi
            done
            if [ "$u" != "" ]; then green "all previous changes modules in other extramod directories moved to new extramod dir" ; fi
        fi
    else
		cmd="sed -i \"0,/APPEND/ s|\\(APPEND\\)|\\1 extramod=${epath}|\" \"$thetgt$pth\""  # first occurence of APPEND in syslinux bootloader for nemesis
		if [ -n "$grubln" ]; then test -e $thetgt$pth && cp $thetgt$pth $thetgt$pth$$.bak ; cmd="sed -i \"${line}s|\\\$| extramod=$epath/|\" \"$thetgt$pth\"" ; fi  # append to end of line.
		test -e "$thetgt$pth" && bash -c "$cmd" || echo "Using other bootloader append ${target}${em} to it with extramod="
    fi # END Bootloader
    if [ -s "${target}${em}${MODULENM}${SERIAL}_uid_$$.xzm" ]; then
		echo ; echo A changes .xzm was detected but nothing was done. ; cyan "${MODULENM}${SERIAL}_uid_$$.xzm already exists" && { sleep 5; exit 0; }
    else
        test -d "$target$em" || mkdir "$target$em"
        touch "$target$em/._test1" 2>/dev/null
        cyan "testing filesystem on ${target} for posix compatibility"
        ln -s "$target$em"/._test1 "$target$em"/._test2 2>/dev/null && chmod +x "$target$em"/._test1 2>/dev/null && [ -x "$target$em"/._test1 ] && chmod -x "$target$em"/._test1 2>/dev/null && [ ! -x "$target$em"/._test1 ] && rm -f "$target$em"/._test1 "$target$em"/._test2
        res=$?
		if [ "$res" -ne 0 ]; then
            mount -o remount,udba=none /
            rm -f "$target$em"/._test1 "$target$em"/._test2
			echo && echo -e "[1;33m""A Windows filesystem (FAT, NTFS) or other non-posix compatible filesystem\nhas been detected on $target.\nYour changes cannot be saved directly to the specified storage media with this\nsetup. Please use the '[1;36mPorteus save file manager[1;33m' to create a .dat container\nand use it for saving your changes after your next reboot.""[0m"
            exit
        fi
        r=$(find "$target$em" -maxdepth 1 -type f -name '*_uid_*.xzm' | wc -l)
        if [ "$r" -eq 0 ]; then # if this is the first time running and there isnt a symlink to the merge script create it
            if [ ! -e "$target$em"/mergemodules ]; then ln -s /usr/local/save-changesnew/mergemodules.sh "$target$em"/mergemodules; fi
			if [ ! -e "$target$em"/mergemodulesod ]; then ln -s /usr/local/save-changesnew/mergemodulesod.sh "$target$em"/mergemodulesod; fi
			if [ ! -e "$target$em"/createlmodule ]; then ln -s /usr/local/save-changesnew/createlmdl.sh "$target$em"/createlmodule; fi
            if [ ! -e "$target$em"/renamebak ]; then ln -s /usr/local/save-changesnew/renamebak "$target$em"/renamebak; fi
            if [ ! -e "$target$em"/renameLbak ]; then ln -s /usr/local/save-changesnew/renameLbak "$target$em"/renameLbak; fi
        fi
        pst=$PWD
        if [ "$linkedSTATE" == "true" ]; then
            f=$(find "$target$em" -maxdepth 1 -type f -name '*_uid_L*.xzm' | wc -l)
            if [ "$f" -gt 1 ]; then
                echo "Cannot have more than one _uid_L\.\*\.xzm file" && exit 0
            elif [ "$f" -eq 1 ]; then  # Good to go
                rlt=""
                if [ -e $msr ]; then
                    content=$(awk -v RS= '{gsub(/\n+$/, "", $0); print $0}' "$msr")
                    k=$( echo "$content" | sed -n 's/.*bytes:[[:space:]]*\([0-9]\+\).*/\1/p')
                    if [ "$k" != "" ]; then
                        p=$( echo "$content" | sed -n 's/^file name:[[:space:]]*\(.*\)/\1/p')
                        if [ "$p" != "" ]; then
                            if [ -f $target$em"/"$p ]; then
                                c=$( du -sb "${target}${em}/${p}" | cut -f1)
                                if [ "$c" -eq "$k" ]; then
                                    ssbn=$( echo $p | sed -n 's/.*_uid_L\(.*\)\.xzm$/\1/p')
                                    if [ "$ssbn" == "" ]; then cyan "failed to parse ssbn in msr"; fi
                                else
                                    validrlt="false"
                                fi
                                fname=$p ; rlt="true"
                            fi
                        fi
                    fi
                    if [ "$rlt" == "true" ]; then
                        createlmdl "msr"
                    else
                        cyan "Bad msr file. making new serial no. the previous one will be renamed to .bak" ; createlmdl "badmsr" 
                    fi
                else
                    createlmdl "nomsr"
                fi
            elif [ "$f" -eq 0 ]; then
                createlmdl "nolmdl"
            fi
        else # End linked
			cd $target$em
			[[ "$namingPRF" == "numeric" ]] && rname="${mdlnm}${SERIAL}_uid_$(rand_num)$$.xzm"
			[[ "$namingPRF" == "alpha" ]] && rname="${mdlnm}${SERIAL}_uid_$(rand_alphauid)$$.xzm" 
			newxzm "uid"
        fi
		if [ "$goahead" == "true" ]; then  # dont display the time if error
            if [ -s "${target}${em}/${rname}" ]; then
                chown $USR "${target}${em}/${rname}"
	     		if [ "$ANALYTICS" == "true" ] && [ "$ANALYTICSECT" == "true" ]; then 
				    el=$(awk "BEGIN {print $end - $start}")
				    tt=$el
					qtn=0
				    [[ -n "$elapse" ]] && qtn=$elapse
				    smp=$el

					#[[ -n "$elapse" ]] && qtn=${elapse/.} ; smp=${el/.} # fails on octal > 7 use awk

				    if awk "BEGIN {exit !($qtn != 0 && $qtn < $smp)}"; then
					    #el=$(awk "BEGIN {print $el - $elapse}")  better to show the times than the difference
		                if [ "$dirtybit" !=  "true" ]; then
		                    mtd="Extract time"
		                else
		                    mtd="Time to merge"
		                fi
		                printf "Total save time %.3f seconds. ( %s %.3f )\n" "$el" "$mtd" "$elapse"
                    elif (( qtn == 0 )); then
                        printf "Total save time %.3f seconds.\n" "$el"
                    fi
			    fi
			    cyan "Your changes have been saved. in ${target}${em}/" && cyan $rname
		        if [ "$mdlMRGPRF" = "back" ] && [ "$mrgMODULES" == "true" ] && [ "$linkedSTATE" == "false" ]; then
		        	cd $target$em ; r=$(find . -maxdepth 1 -type f -name '*_uid_*.xzm' ! -name '*_uid_L*' | wc -l)
		            if (( r > mdllmt)); then
		                green "Merging changes modules..." ; sleep 5
		                /usr/local/save-changesnew/mergemodules.sh $keepMRGED $ROLLBCK $ROLLSUMRY $archLMT
					    rel=$?
					    if [ "$rel" -ne 0 ]; then
				            if [ "$rel" -eq 1 ]; then
				                red "There was problem auto merging. see $elog" ; cyan "Everything preserved."
				            else
				                echo "mergemodules.sh err: $rel"
				            fi
		                else
		                    cyan "Modules merged."
		                fi
		            fi
		        fi
            fi
		fi
		cd $pst
    fi
fi
mount -o remount,udba=none /
test -e $oMF && rm $oMF
test -e $EXCL && rm $EXCL
test -e $QEXCL && rm $QEXCL
test -e $UPDATE && rm $UPDATE
#test -e $SFOLDERS && rm $SFOLDERS
test -e /tmp/incfilter.log && rm /tmp/incfilter.log
test -e $tmp && rm -rf ${tmp:?} 
test -e $mtmp && rm -rf ${mtmp:?}
sleep 5 && exit
