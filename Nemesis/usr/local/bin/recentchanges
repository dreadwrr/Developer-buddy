#!/bin/bash
#   NMS5                                                                            01/09/2026  v5.0
# entry point for recentchanges.
#
#   recentchanges. aka Developer buddy      recentchanges / recentchanges search
#   Provide ease of pattern finding ie what files to block we can do this a number of ways
#   1) if a file was there (many as in more than a few) and another search lists them as deleted its either a sys file or not but unwanted nontheless
#   2) Is a system file inherent to the specifc platform
#   3) intangibles ie trashed items that may pop up infrequently and are not known about
#
#   recentchanges
#           Searches are saved in /tmp and also makes rntfiles.xzm
#
#           1. Search results are unfiltered and copied files for the .xzm are from a filter.
#           2. No /tmp files displayed for clear easy to read results. Too much information makes it more difficult to interpret
#           3. 'rnt' shortcut for the same command. Unlike recentchanges search command does not inverse
#
#           The purpose of this script is to save files ideally less than 5 minutes old. So when compiling or you dont know where some files are
#   or what changed on your system. So if you compiled something you call this script to build a module of it for distribution. If not using for developing
#   call it a file change snapshot
#   We use the find command to list all files 5 minutes or newer. Filter it and then get to copying the files in a temporary staging directory.
#   Then take those files and make an .xzm. It will be placed in   /tmp  along with a transfer log to staging directory and file manifest of the xzm
#
#   recentchanges search
#           Searches are saved in /home/{user}/Downloads includes /tmp files in a seperate file
#
#           1. The search is unfiltered and a filesearch is filtered.
#           2. `rnt search` is a shortcut and inverses the results. For search it will filter the results instead of being unfiltered. For a file search it removes the filter instead as its normally filtered.
#
# Old searches can be grabbed from /Downloads, /tmp or /tmp/{MODULENAME}_MDY_*. the limit is set by archivesrh in config.toml. This is  for convenience if there is no previous search  it displays the
# old search for specified search criteria. all searches are stored in the database before applying filter.py so all data is captured
#
#  Also borred script features from various scripts on porteus forums
# working off of base save-changes script by
# Author: Brokenman <brokenman@porteus.org>
# Author: fanthom <fanthom@porteus.org>
. /usr/share/porteus/porteus-functions
get_colors
. /usr/local/save-changesnew/versionquery
. /usr/local/save-changesnew/validprogram.sh
. /usr/local/save-changesnew/rntchangesfunctions
. /usr/local/save-changesnew/comp
# If you want xed or featherpad to open uncomment at bottom of script
# CHANGEABLE       New to version 3


export backend="database" 	# default   bash 2 gpg and queries text based stable tested  
											# database   binary database faster queries 1 gpg and python (easier ha)

export email="john.doe@email.com" # default for asymmetrical gpg auth for STATPST
                                                        # asks for paraphrase and caches for 15 minutes
                                                        # leave default

export logSIZE=50 # default 50mb for persistent storage pst

export logCT=300 # Max searches to store in pst storage before removing one

export logPRF="del" # del delete and stop    what to do on max logSIZE
                                # stop leave in place
                                # rfh refresh clear and log again


export compLVL=200  # default 200mb to disable compression on logpst size

#this script
cmode="gzip"                   # default nothing. uses gzip compression level balanced. This is for recentchanges .xzm and SRC tag
                                           # xz        best compression
                                           # zstd     faster bootup
                                            # lzo      faster bootup
archivesrh=5						# How many old searches to save and rnt.xzm in /tmp(all filtered files) pulled. These can be grabbed by recentchanges search and recentchanges 
#
#SRC options
#this script
xzmname="Application$$" # What to name .xzm when using SRC and create the .xzm automatically without selecting or entering a name. mutually depedent on autooutput
autooutput="false"
#
# end this script

export tmpSRHS=7 # Default 7. for ANALYTICS. store most recent searches in /tmp try 30 and then run recentchanges query with STATPST false
                                # for hybrid analysis in diff file
                                 # also queries ie recentchanges query stats



export mMODE="mc"  #  default. regular search
								   		# mc      turbo mode run the search in parallel or multiple cores.


export ANALYTICS="false" # store recent searches in /tmp       default false
                                        # gives hybrid analysis in diff file more files to compare no overhead as only checks modified
                                        # makes more sense to work off of /tmp than to decrypt everytime
                                        # for that reason you can choose /tmp or STATPST or both and recentchanges query
                                        # if you want your searches to be encrypted just use STATPST

                                        # if you start decrypting here searching there running post ops and everything else its a bad idea
                                        # for that reason I put protections in place for POSTOP

                                        # useful for quickly checking system filess
                                        # not as secure but still owned by root in /tmp but its temporary anyway and can be turned off


export STATPST="true" # persistent storage searches encrypted in /usr/local/save-changesnew for recentchanges query see logSIZE / logCT
                                    # Only overhead is gpg compression set compression to off. At large size speeds can increase by as much as 50%.
                                    # if you prefer security turn ANALYTICS false and use this

export xRC="false"	# false - default. run inotifywait for one hour to look for new files where ctime > mtime in /changes.
									# this is for downloads or copies with preserved metadata pacman slackpkg ect.
									# if false the files will still show up keep in mind the /tmp file search results are in a seperate file in /Downloads use `recentchanges search`
									# With this setting If true can bypass 1 of 2 search loops and reduce process overhead as the search is already there effectively increasing the overall speed

#Display
export ANALYTICSECT="true" # provides more feedback
                                            # total search time ect
                                            # we dont want too much output on the terminal just a slight bit more
                                            # others stats

export FEEDBACK="true"  # include find output in terminal as well ie scrolling terminal look


export dspEDITOR="xed" # false.  default dont display text editor. launch text editor?
										# featherpad
										# xed  


## Diagnostics
export checkSUM="true"	# compare file checksums for slight changes
										# slower useful if you want to check deeper level of stats
export cdiag="true"       # add extra detail like filesize in output and critical events. Also check for hash collisions.
export supbrwr="true"   # supress cache warnings on terminal from known browsers? Mozilla... ect list top of rntfuncions see rntchangesfunctions
export suppress="false"  # ..      all cdiag output to terminal except critical events

export POSTOP="false" # Diagnostics. Create file doctrine. Runs post search operation that can only be done at this time as search is relevant
                                    # more overhead so recommend off unless one off. output /Downloads
                                    #
                                    # if it is run again and a file is still there it will not run the POSTOP and the script will set POSTOP to false to itself

export proteusSHIELD="false"	# take initial hash of base modules 001-core.. ect database mode
## End Diagnostics

export MODULENAME="rntfiles"    # prefix for search result file
export logpst="/usr/local/save-changesnew/logs.gpg"
export statpst="/usr/local/save-changesnew/stats.gpg"
export pydbpst="/usr/local/save-changesnew/recent.gpg"

# END CHANGEABLE
[[ "$mMODE" != "default" ]] && [[ "$mMODE" != "mc" ]] && echo incorrect mMODE && exit 
[[ "$STATPST" == "true" ]] && [[ "$ANALYTICS" == "true" ]] && { echo With STATPST cant run with ANALYTICS. for security reasons as its stored in gpg. ; echo you can modify to run both if wanted. ; } && exit
[[ "$STATPST" == "false" ]] && [[ "$backend" == "database" ]] && echo cant run database with ANALYTICS. && exit
if [ "$1" = "-v" ]; then get_vrn $1 ; elif [ "$1" = "--help" ] || [ "$1" = "-h" ] || [ "$1" = "help" ] || [ "$1" = "-help" ]; then get_vrn $1; fi # If inquery tag no need to call root. pass to other function and exit.
argf=$5
if [ `whoami` != "root" ]; then #if [[ $(whoami) != "root" ]]; su -c "$0"; exit fi  if [[ $(id -u) -ne 0 ]]; then sudo "$0" "$@"; exit 0; fi
    echo "Please enter your root password below"
	if [ "$1" == "inv" ]; then argone="noarguser" ; argtwo="noarguser" ; argf="filtered" ; else argone="$1" ; argtwo="$2"  ; fi
	argthree=`whoami`
    if [ -z "$argone" ]; then argone="noarguser" ; fi
    if [ -z "$argtwo" ]; then argtwo="noarguser" ; fi
	if [ "$2" == "inv" ]; then argtwo="noarguser" ; argf="filtered" ; fi
	if [ "$3" == "inv" ]; then argf="filtered" ; fi
	#if [ "$XDG_SESSION_TYPE" = "wayland" ]; then/root/somefile\\\"quote.txt
	su - -c "/usr/local/bin/recentchanges $argone '$argtwo' $argthree '$PWD' $argf"
	#else
	#	sudo -k
	#	exec sudo "$0" $argone "$argtwo" $argthree "$PWD" $argf
	#fi
    exit
fi
# Handle rnt inverse switching
arge=()
for item in "$@"; do if [ "$item" != "inv" ]; then arge+=("$item") ; else arge+=("") ; argf="filtered" ; fi ;done
p=${#arge[@]} ; while (( p < 5 )); do arge+=("") ; ((p++)) ; done
# Handle root call
THETIME="${arge[1]}"
USR="${arge[2]}"
passdir="${arge[3]}"
if [ -z "$argf" ]; then argf="bnk"; fi #Default
export DISPLAY=:0 # for tkl and root xed featherpad
export XAUTHORITY=/home/$USR/.Xauthority
if [ "${arge[1]}" == "" ]; then THETIME="noarguser" ; fi
if [ "${arge[2]}" == "" ] || [ "${arge[3]}" == "" ]; then USR="guest" ; passdir=$PWD ; fi #Default user
if [ "${arge[2]}" == "SRC" ]; then echo "Incorrect usage please use recentchanges SRC s , s SRC or SRC" && exit 1; fi
if  ! id $USR>/dev/null 2>&1; then echo "user: $USR not found"; exit 1; fi
#Fork
if [ "${arge[0]}" == "search" ]; then
   	test -d "${passdir}" || { echo  "not a valid directory. usage recentchanges search time."; exit 1; }
   	source /usr/local/save-changesnew/recentchangessearch.sh "${arge[0]}" "$THETIME" $USR "$passdir" $argf "$0"
   	exit
elif [ "${arge[0]}" == "query" ]; then
	if [ "$backend" == "default" ]; then  
        /usr/local/save-changesnew/query "$THETIME" $USR "$passdir"
        exit
    else 
        python3 /usr/local/save-changesnew/query.py "$0" $pydbpst $USR $email $mMODE $compLVL $checkSUM
        exit
    fi
fi

#VARS
# temp files
# tfile, tout, TMPCOMPLETE main tmp files. spare tmp file tfile2, xdata3
# xopt aux tmp dir
# $tmp  main search tmp files from original
# $atmp  secondary tmp files from upgrade
# $atmpwork   multiprocessing tmp files so not messy
# $atmp$workdir   restricted decrypted pst file for ha. & ha multiprocessing related files
workdir=/hablk															; 	workfld=/fsearch$$
tmp=/tmp/work$$														;	chxzm=/$MODULENAME.xzm
ABSENT=$tmp/tmp_absent.txt									;	atmp=/tmp/atmp$$ 
UPDATE=$tmp/save.transferlog.tmp							;	rout=$atmp/routput.tmp
RECENT=$tmp/list_recentchanges_filtered.txt				;	xdata=/logs_stats.log # dcryp log file     
RECENTAPP=$tmp/list_recentapp_filtered.txt				;	xdata2=/logs.log.log
COMPLETE=$tmp/list_complete.txt								;	xdata3=$atmp$workdir/temp_log.log 
RECENTNUL=$tmp/list_recentchanges_filterednul.txt	;	tfile=$atmp$xdata
TMPCOMPLETE=$tmp/tmp_complete.txt						;	tfile2=$atmp$xdata2
RSYNCEXCL=$tmp/list_filesexclude.txt						;	tout=$atmp/toutput.tmp 
TMPOPT=$tmp/tmp_holding										;	toutnul=$atmp/toutputnul.tmp
REJECTLOG=$tmp/list_rejectsrc.txt								;	xopt=/mnt/live/tmp # spare tmp dir
FOLDERLOG=$tmp/save.totalfolders.tmp					;	flth=/usr/local/save-changesnew/flth.csv
SORTCOMPLETE=$tmp/list_complete_sorted.txt			;	log_file=/tmp/file_creation_log.txt
SVFOLDERS=$tmp/save.rncfoldersmanifest.tmp 			;	slog=/tmp/scr # feedback
SVFILES=$tmp/save.rncfilesmanifest.tmp 					;   cerr=/tmp/cerr # priority
LCLMODULENAME=${chxzm:1:8}								;	THETIME="${arge[0]}" # shift for this script
USRDIR=/home/$USR/Downloads

SRCDIR=""																	;	csm=""
cores=0																	;   max_jobs=0

cached=/tmp/dbctimecache/
CACHE_F="${cached}ctimecache"
BRAND=$(date +"MDY_%m-%d-%y-TIME_%R" | tr ':' '_')
FLBRAND=$(date +"MDY_%m-%d-%y-TIME_%R_%S" | tr ':' '_')
fmt="%Y-%m-%d %H:%M:%S"

diffrlt="false"															;	pstc="false"
nodiff="false"															;   samerlt="false"
syschg="false"															;	validrlt="false"
approval="true"														;	nc="false"
csum="false"

F=( /bin /etc /home /lib /lib64 /opt /root /sbin /usr /var )
TAIL=( -not -type d -printf '%T@ %A@ %C@ %i %M %n %s %u %g %m %p\0' )

mkdir $tmp
mkdir $tmp$workdir
mkdir $atmp
mkdir $atmp$workfld
mkdir $atmp$workdir

if [ "$ANALYTICSECT" == "true" ]; then start=$(date +%s.%N); fi
if [ "${arge[0]}" == "" ]; then THETIME="noarguser" ; fi # root call
[ "$THETIME" == "SRC" ] &&{ SRCDIR=$THETIME; THETIME="${2:-noarguser}"; } # shift
[ "${arge[1]}" == "SRC" ] && SRCDIR=${arge[1]} || { [ "${arge[1]}" == "SEARCH" ] || [ "${arge[1]}" == "search" ]; } && echo "The SRC tag is for recentchanges only" && exit
intst
if [ "$THETIME" != "noarguser" ] && [ "$THETIME" != "" ]; then
    if [ "$THETIME" -ge 0 ] 2>/dev/null; then argone=$THETIME ; else echo argument specified not a valid integer or valid flag && exit; fi
	cyan "Grabbing files (filtered) and searching for total sys files ${arge[0]} seconds old or newer"
	comp $argone
else
    cyan "Grabbing files (filtered) and searching for total sys files 5 minutes old or newer"
	argone="5" ; qtn="5"
fi
CMIN=( -cmin "-${qtn}" )
MMIN=( -mmin "-${qtn}" )

[[ ! -d "$cached" ]] && mkdir $cached && chmod 700 $cached
[[ "$checkSUM" = "true" ]] && [[ "$ANALYTICS" = "true" || "$STATPST" = "true" ]] && cyan "Running checksum." || checkSUM="false"
if [ ! -s "$tout" ]; then
	find "${F[@]}" "${MMIN[@]}" "${TAIL[@]}" 2>/dev/null | tee "$RECENTNUL" > /dev/null 2>&1
	find "${F[@]}" "${CMIN[@]}" "${TAIL[@]}" 2>/dev/null | tee "$toutnul" > /dev/null 2>&1
	end=$(date +%s.%N) ; [[ "$checkSUM" == "true" ]] && [[ "$ANALYTICSECT" ]] && cstart=$(date +%s.%N)
	ctimeloop $RECENTNUL $RECENT # pacman slackpkg downloads ctime > mtime
else
	find "${F[@]}" "${MMIN[@]}" "${TAIL[@]}" 2>/dev/null | tee "$RECENTNUL" > /dev/null 2>&1
	end=$(date +%s.%N) ; [[ "$checkSUM" == "true" ]] && [[ "$ANALYTICSECT" ]] && cstart=$(date +%s.%N)
fi

if [ "$FEEDBACK" == "true" ]; then tr '\0' '\n' < "$RECENTNUL" | awk '{ $1=$2=$3=$4=$5=$6=$7=$8=$9=$10=""; sub(/^ +/, ""); print }' ; fi #scrolling look  #tr '\0' '\n' < "$toutnul" | awk '{ $1=$2=$3=$4=$5=$6=$7=$8=$9=$10=""; sub(/^ +/, ""); print }'


while IFS= read -r -d '' y; do x="$(printf '%s' "$y" | cut -d' ' -f11-)";  x="$(escf "$x")"; printf '%s\n' "$x" ; done < $RECENTNUL > $RECENT # Used to copy files \n delimited it is the filtered list

search $RECENTNUL $SORTCOMPLETE $COMPLETE $checkSUM "main"  # mtime append ctimeloop in range later
cend=$(date +%s.%N)
isoutput mainloop1* mainloop2* $SORTCOMPLETE $COMPLETE
isoutput cache1* $CACHE_F
[[ -f "$CACHE_F" ]] && chmod 600 "$CACHE_F"

if [ -s $SORTCOMPLETE ]; then
	syschg="true"
	sort -u -o  $SORTCOMPLETE $SORTCOMPLETE ; SRTTIME=$( head -n1 $SORTCOMPLETE | awk '{print $1 " " $2}') ; PRD=$SRTTIME
	merge_ctime $SORTCOMPLETE $tout $PRD
	inclusions $SORTCOMPLETE
	s=$(date -d "$SRTTIME" "+%s")
	if [ "$THETIME" == "noarguser" ]; then RANGE=$(( s + 300 )) ; else RANGE=$(( s + argone )) ; fi # filter out non existant files ect
	PRD=$(date -d "@$RANGE" +"$fmt")
	awk -v tme="$PRD" '{ ts = $1 " " $2; if (ts <= tme) print }' $SORTCOMPLETE > $tout ; mv $tout $SORTCOMPLETE
	sort -u -o $SORTCOMPLETE $SORTCOMPLETE
	process_sort $SORTCOMPLETE $TMPOPT
	sort -o $TMPOPT $TMPOPT
fi

inclusions $RECENT
/usr/local/save-changesnew/filter $RECENT $USR

# Copy files
while IFS= read -r x; do y="$( unescf "$x")" ; if cp -a --parents "$y" "$tmp$workdir" > /dev/null 2>> $tfile; then printf '%s \n' "$x success" >> $UPDATE; else echo "Failed to copy: $x" >&2; echo "ERROR: $x" >> $UPDATE; fi; done < $RECENT
unset IFS

if [ -s $tfile ]; then echo >> $UPDATE ; cat $tfile >> $UPDATE; fi
test -e $tfile && rm $tfile
echo $BRAND >> $UPDATE

find $tmp$workdir -not -type d -print0 > $SVFILES

:> $tout
while IFS= read -r -d '' x; do x="$( escf "$x")"; echo "$x" ; done < $SVFILES >> $tout
mv $tout $SVFILES

sed -i -e "s|$tmp$workdir||g" $SVFILES
cat $SVFILES | sed -e 's![^/]*$!!g' > $SVFOLDERS

# make .xzm from root folder
if [ "$SRCDIR" == "SRC" ]; then
    arrfiles=()
    arrreject=()
    appname=$xzmname
    FLTOUT="/tmp/${appname}ItemsFilteredout"
    test -e "/tmp/${appname}.xzm" && rm "/tmp/${appname}.xzm"
    rm "/tmp/"*"_xdata" 2> /dev/null
    rlt=$( validprogram $SVFOLDERS)
 	if [ "$rlt" == "/" ]; then echo Fatal error. exiting. && exit 1 ; fi
    if [ "$rlt" != "" ]; then
        cat $SVFILES | grep "${rlt}" > $RECENTAPP ; cat $SVFILES | grep -v "${rlt}" > $RSYNCEXCL
		find $tmp$workdir -type d -empty -delete  # skip any file with new lines for exclude file
		while IFS= read -r p || [ -n "$p" ]; do p="${p#/}" ; p="${p//\\\"/\"}" ; p="${p//\\\$/\$}" ; p="${p//\\\\/\\}" ; echo "$p" >> $tfile ; done < $RSYNCEXCL  # This is for our SRC files after finding root
        test -s $tfile && mksquashfs $tmp$workdir "/tmp/${appname}.xzm" -comp $cmode -ef $tfile || { [[ ! -s "$tfile" ]] && mksquashfs $tmp$workdir "/tmp/${appname}.xzm" -comp $cmode ; }
        cp $RECENTAPP "/tmp/${appname}_xdata" ; echo $BRAND >> "/tmp/${appname}_xdata"
        sort -o $RECENTAPP $RECENTAPP
        cat $SORTCOMPLETE | grep -Ff $RECENTAPP | grep -v 'NOTA-FI-LE 77:77:77' | tee $TMPCOMPLETE > /dev/null
        endtm=$( gettime "$TMPCOMPLETE" "/tmp/${appname}_xdata")
        printf "\n\n" >> "/tmp/${appname}_xdata"
        cat $TMPOPT  | grep -Fvf $RECENTAPP > $TMPCOMPLETE
	    cd $tmp$workdir || exit
	    srcpath="${rlt#?}"
		> $tfile
		r=$( find "${rlt}" -type f | wc -l)  # system
		s=$(grep -n 'MDY' "/tmp/${appname}_xdata" | head -n 1 | cut -d: -f1)
		if [[ -n "$s" ]]; then s=$(( s - 1 )) ; else s=0 ; fi
		x=0
		y=$( wc -l < $RECENTAPP) # copied
		while IFS= read -r -d '' f ; do p="$( escf "$f")" ; printf '%s\n' "$p" >> $tfile;  x=$(( x + 1 )) ; done < <(find "${srcpath}" \( -type f -o -type l \) -print0)  # Our system files is what we should be comparing		
		{ echo Root:"${rlt}" ; echo "File count: "$x "of ${y}" ; echo "System count: "$r ; echo ; echo ; } >> "/tmp/${appname}_xdata"   
		if (( x < y )); then  #Default
			sort -o $tfile $tfile
			sort $RECENT > $tfile2
			comm -23 $tfile $tfile2 > $tout
			{ echo ; echo "Transfer: File transfer failed. " ; echo ; echo "Following file(s) were not transfered:" ; cat $tout ;} >> "/tmp/${appname}_xdata"
		elif (( x == y)); then
			{ echo "Transfer: File transfer verified " ; echo ; } >> "/tmp/${appname}_xdata"
		else
			{ echo "SRC mode failed. use recentchanges to package application." ; } >> "/tmp/${appname}_xdata"
		fi
		if (( r > s )); then echo "Status: Possibly missed base directory. Confirm files or use recentchanges for rntfiles.xzm." >> "/tmp/${appname}_xdata" ; fi

        if [ -s $TMPCOMPLETE ]; then { echo ; echo "Items filterout from filtered files."; echo ; cat $TMPCOMPLETE; } >> "/tmp/${appname}_xdata" ; else echo "No items filtered out from filter." >>"/tmp/${appname}_xdata" ; fi
        # original 
        #find "$tmp$workdir$rlt" -type f -print0 > $TMPCOMPLETE
        #while IFS= read -r -d '' f; do  f="$( escf "$f")" ; arrfiles=("${arrfiles[@]}" "${f##*/}"); done < $TMPCOMPLETE
        while IFS= read -r f; do arrfiles=("${arrfiles[@]}" "${f##*/}"); done < $RECENTAPP  # save overhead by reading off $RECENTAPP for the names
        echo $BRAND >> $RECENTAPP
		if [ "$autooutput" == "false" ]; then
		    x=${#arrfiles[@]}
		    y=0
		    echo
		    for i in "${arrfiles[@]}" ; do
		        p=$(( y + 1 ))
		        printf "%2d %-40s\t\t" "$p" "${i}"
		        (( y++ ))
		        if  [ $(( y % 2 )) -eq 0 ]; then
		            echo -en "\n"
		        else
		            if (( y == x )); then
		                echo -en "\n"
		            fi
		        fi
		        if (( y > 70 )); then
		            break
		        fi
		    done
		    echo "Root folder" "${rlt##*/}"
		    echo  "Press enter for default filename"
		    read  -p 'Filename or Selection: ' usrslc
		    if [ "$usrslc" != "" ]; then
		        if [ "$usrslc" -ge 0 ]  2>/dev/null; then
		            echo selected "$usrslc"
		            if [ "${#arrfiles[@]}" -ge "$usrslc" ]; then
		                filename="${arrfiles[$(( usrslc - 1 ))]}"
		            else
		                echo
		                echo "Using default filename."
		                filename="$appname"
		            fi
		        else
		            filename="$usrslc" #User
		        fi
		    else
		        filename="$appname" #Default
		    fi
		else
			filename="$appname"
		fi
		fn=$(printf '%b' "$filename") ; fn=$(basename "$fn") ; fn=$(sed -E 's/(.*)\.[^./]{3,4}$/\1/' <<< "$fn") ; fn="${fn// /_}" #fn=$( echo "$fn" | sed -e 's/\...$//' -e 's/\....$//' -e 's/ /_/g')
        if [ "$fn" != "$appname" ]; then mv "/tmp/${appname}.xzm" "/tmp/${fn}.xzm" ; mv "/tmp/${appname}_xdata" "/tmp/${fn}_xdata" ; fi
        chown $USR "/tmp/${fn}.xzm"
        chown $USR "/tmp/${fn}_xdata"
    fi
fi

echo $BRAND >> $SVFILES
cd /tmp || exit
MODULENAME=${chxzm:0:9}
chxzmnm=$MODULENAME"manifest.txt"
moduledir=$MODULENAME"_"$FLBRAND
FLTOUT="/tmp"$MODULENAME"ItemsFilteredout"
k=$( head -n1 $SVFILES | grep "MDY")

#Are there files for recentchanges, move old files, ect
if [ -z "$k" ]; then
	validrlt="true"
    r=$(find . -maxdepth 1 -type d -name '*rntfiles_MDY*' | wc -l) #Move
    if (( r == archivesrh )); then for folder in "/tmp"$MODULENAME"_MDY"* ;  do rm -r $folder ; break ; done ; fi
    mkdir "/tmp"$moduledir && chown $USR "/tmp"$moduledir
    test -e /tmp"$chxzm" && mv /tmp"$chxzm" "/tmp"$moduledir ; test -e "/tmp"$chxzmnm && mv "/tmp"$chxzmnm "/tmp"$moduledir; test -e "/tmp"$MODULENAME"Transferlog" && mv "/tmp"$MODULENAME"Transferlog" "/tmp"$moduledir
    mv $LCLMODULENAME"xSystemchanges"* "/tmp"$moduledir 2> /dev/null ; mv $LCLMODULENAME"xSystemDiffFromLastSearch"* "/tmp"$moduledir 2> /dev/null
    test -e  "/tmp"$MODULENAME"ItemsFilteredout" && rm  "/tmp"$MODULENAME"ItemsFilteredout"

    if [ "$SRCDIR" != "SRC" ]; then # make rntfiles.xzm from all filtered
	    mksquashfs $tmp$workdir "/tmp"$chxzm -comp $cmode
	    cp $SVFILES "/tmp"$chxzmnm
	    cp $UPDATE "/tmp"$MODULENAME"Transferlog"
        if [ "$validrlt" == "true" ]; then
            sort -o $RECENT $RECENT
            cat $TMPOPT | grep -Fvf $RECENT > $FLTOUT ; echo $BRAND >> $FLTOUT
            cat $TMPOPT | grep -Ff $RECENT | tee $TMPCOMPLETE > /dev/null
            sed -i '/^[[:space:]]*$/d' $TMPCOMPLETE
            endtm=$( gettime $TMPCOMPLETE "/tmp"$chxzmnm)
        fi
        chown $USR "/tmp"$chxzm ; chown $USR "/tmp"$chxzmnm ; chown $USR "/tmp"$MODULENAME"Transferlog" ; chown $USR $FLTOUT
        test -e "/tmp"$moduledir && chown $USR "/tmp"$moduledir
    fi
fi

#Diff file
if [ ! -f "/tmp"$moduledir$MODULENAME"xSystemchanges"$argone ]; then hsearch ; else OLDSORTED="/tmp"$moduledir$MODULENAME"xSystemchanges"$argone; nodiff="true" ; fi
difffile="/tmp${MODULENAME}xSystemDiffFromLastSearch${argone}"

if [ -s $SORTCOMPLETE ]; then
    if [ -n "$OLDSORTED" ] && [ -s $OLDSORTED ]; then
    	sed -i '/^[[:space:]]*$/d' $OLDSORTED
        comm -23 $OLDSORTED $TMPOPT > $difffile
        isdiff $difffile $TMPOPT $TMPCOMPLETE
    fi
	backend
	filterhits $TMPOPT $flth
	postop $SORTCOMPLETE $0
    cp $TMPOPT "/tmp"$MODULENAME"xSystemchanges"$argone
	chown $USR "/tmp"$MODULENAME"xSystemchanges"$argone
	test -e "$difffile" && chown $USR "$difffile"
fi

#Cleanup
if [ "$ANALYTICS" == "true" ] && [ "$STATPST" == "false" ]; then
    stmp $SORTCOMPLETE
    if [ ! -f /tmp/rc/full ]; then cyan "Search saved in /tmp"; fi
fi
test -d "$tmp" && rm -rf "${tmp:?}" 
test -d "$atmp" && rm -rf "${atmp:?}"
if [ "$ANALYTICSECT" == "true" ]; then
    el=$(awk "BEGIN {print $end - $start}")
    printf "Search took %.3f seconds.\n" "$el"
	if [ "$checkSUM" == "true" ]; then
		el=$(awk "BEGIN {print $cend - $cstart}")
		printf "Checksum took %.3f seconds.\n" "$el"
	fi
fi
if [ "$validrlt" == "true" ]; then
  	cyan "Your module has been created. in /tmp" ; echo
    if [ "$SRCDIR" == "SRC" ]; then
  	    cyan "${filename}".xzm ; echo
    else
        cyan " Total pull range: ""${endtm}"
        cyan "$chxzm  including a file manifest" ; echo
    fi
else
   	cyan "There were no files to grab." ; echo
fi
if [ "$THETIME" != "noarguser" ] && [ "$syschg" == "true" ]; then
	cyan "All system files in the last $THETIME seconds are included"
	cyan ""$MODULENAME"xSystemchanges"$argone ; echo
	
elif [ "$syschg" == "true" ]; then
	cyan "All system files in the last 5 minutes are included"
    cyan ""$MODULENAME"xSystemchanges"$argone ; echo
fi
logic "Refer to /rntfiles_MDY folder for the previous search"
display /tmp $MODULENAME"xSystemchanges"$argone
