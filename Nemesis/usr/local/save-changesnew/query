#!/bin/bash 
#   recentchanges query                recentchanges v3.0                                                                                08/11/2025
#   provide output of files to block in /usr/local/save-changesnew/filter for recentchanges and excld.ini for rsync save-changesnew
#   example if there are only 3 list the top 1. if there are many say 7 list the top 3. Always better to include than exclude with a filter
#
#	 When STATPST is on TMP data doesnt save. This is done for efficiency. So either ANALYTICS or STATPST. but not both. If youre on STATPST 
#	you dont want to save in /tmp. Plus the overhead of running two hybrid analysises is not good. TMP is good because it TMPFS and gone on reboot.
#	The general idea is use this data to tweak your filter and then turn them both off. For ease of use and making recentchanges autonomous in setting the filter
#
#   There can be the standard query but also 1) filter hits 2) list the top 3 regardless 3) most common file 4) generate platform exclusion list
#   
#   Make your own custom queries based on the data
#   retrieval of data  from  /tmp  or  logpst and statpst
. /usr/share/porteus/porteus-functions
get_colors
. /usr/local/save-changesnew/heuristics
#vars on line 204

# CHANGABLE 
# CHANGABLE booleans
outputTFILE="true"            # show the report in /tmp?

outputPSTFILE="true"       # .   .               /home/guest/Downloads
genPSTTFILE="true"           # Run heuristics on PST and include in the report?       
# End CHANGABLE

dr=/usr/local/save-changesnew
logpst=$dr/logs.gpg
statpst=$dr/stats.gpg
flth=$dr/flth.csv
rtmp=/tmp/rtmp$$
xdata=$rtmp/logs_decrypted.log
trc=/tmp/rc
timestamp=$(date +"MDY_%m-%d-%y-TIME_%R"|tr ':' '_')
report=/query_$timestamp
TOPT=$rtmp/tmpfile.log
output_file=$rtmp/output.log

mkdir $rtmp

if [ "$STATPST" == "true" ]; then
    if [ -s $logpst ]; then
        cyan "Pulling logs from persistent storage"
        if gpg -d -o $xdata $logpst; then #decrypt
            #cp $xdata /tmp/logdebug
			sed -i '/NOTA-FI-LE 77:77:77/d' $xdata  # eronous data we could eliminate it from the logpst but this could be useful statistics     anyway it messes up some awk commands.
            ### Log file queries
            #gpg -e -r $email -o /usr/local/save-changesnew/logs.gpg /tmp/logs_decrypted.log #encrypt

            #sed -E 's/^[^ ]+ [^ ]+ (.*)/\1/' $xdata | sed -E 's|(.*)/[^/]+$|\1|' | sort | uniq -c | sort -nr | head -n 3        top 3 
            
			cd /home/$2/Downloads || exit
			rm query_MDY* > /dev/null 2>&1

			{
            green "Logs archive"
			cyan "Top 3(1) directories(dir)"			
			dirs=$(awk '
			{
				# Match quoted file path in the line
				match($0, /"[^"]+"/, m)
				if (m[0] != "") {
					gsub(/"/, "", m[0])
					path = m[0]

					# Extract directory by removing final component
					if (path ~ /\//) {
						sub(/\/[^/]+$/, "", path)
					} else {
						path = "[no dir]"
					}

					dirs[path]++
				}
			}
			END {
				for (d in dirs) {
					printf "%d %s\n", dirs[d], d
				}
			}' "$xdata" | sort -nr | head -n 3)

			# Extract the count of the 3rd directory (if it exists)
			tc=$(echo "$dirs" | awk 'NR==3 {print $1}')

			if [[ -n "$tc" && "$tc" -gt 3 ]]; then
				echo "$dirs"
			else
				echo "$dirs" | head -n 1
			fi
            echo
            cyan "Most common extensions"
            echo
            ext $xdata
			green "Please wait..."
            cyan "Search statistics:"
			
			aat $xdata
            echo "Searches: $(grep -c '^[[:space:]]*$' $xdata)" # total searches
			hr $xdata
			asz $xdata
			echo
			} 2>&1 | tee $output_file     # write the report to the report and show on terminal
			echo
			echo
			[ "$genPSTTFILE" == "true" ] && { green "Generating heuristics..." ; { echo; echo "Heuristics"; echo; } >> $TOPT; } && /usr/local/save-changesnew/heuristics $xdata $TOPT && { echo; green "Heuristics complete"; } 
            #shred -u $xdata
            rm $xdata
			perl -pe 's/\e(\[[0-9;?]*[a-zA-Z]|[\(\)][AB])//g' -i "$output_file"   # remove ASCII text

            if [ -s $statpst ]; then ### Stat queries
                cyan "Pulling from stats archive"
                if gpg -d -o $xdata $statpst; then #decrypt
					#cp $xdata /tmp/statdebut
					{					
                    green "Stats gpg"
                    echo
					cyan "Most Modified"
					awk '
					{
						# Extract the action (before first comma)
						match($0, /^[^,]+/, a)
						action = a[0]
						gsub(/"/, "", action)
						gsub(/^ +| +$/, "", action)

						# Extract the datetime (the first quoted string after action)
						match($0, /"([^"]+)"/, dt)
						datetime = dt[1]

						# Remove the part up to datetime match to get the rest
						rest = substr($0, RSTART + RLENGTH)

						# Extract the filename (next quoted string)
						match(rest, /"([^"]+)"/, fp)
						filepath = fp[1]

						if (action == "Modified") {
							counts[filepath]++
							found = 1
						}
					}
					END {
						if (found) {
							for (file in counts)
								print counts[file], file
						} else {
							print "No entries found"
						}
					}
					' "$xdata" | sort -rn | head -5
				echo
				cyan "Top 5 deleted files"
				awk -v rtmp="$rtmp" '
				{
					# Extract action (before first comma)
					match($0, /^[^,]+/, a)
					action = a[0]
					gsub(/"/, "", action)
					gsub(/^ +| +$/, "", action)

					# Extract datetime (first quoted string)
					match($0, /"([^"]+)"/, dt)
					datetime = dt[1]

					# Get the rest after datetime match to extract filename (next quoted string)
					rest = substr($0, RSTART + RLENGTH)
					match(rest, /"([^"]+)"/, fp)
					filepath = fp[1]

					if (action == "Deleted") {
						counts[filepath]++
						# Store datetime if not set or if current datetime is newer
						if (!(filepath in latest_datetime) || datetime > latest_datetime[filepath]) {
							latest_datetime[filepath] = datetime
						}
						found = 1  # Set found to 1 if action is "Deleted"
					}
				}
				END {
					if (found == 1) {  # Only print if we found any "Deleted" actions
						for (file in counts) {
							print counts[file], latest_datetime[file], file
						}
					} else {
						# Print "No entries found" to the output file if no "Deleted" actions
						print "No entries found" > rtmp"/top_deleted_xdata.txt"
					}
				}
				' "$xdata" | sort -rn | head -5 > "$rtmp/top_deleted_xdata.txt"				
				echo
				cyan "Top 7 Most replaced"
				awk '
				{
					# Extract the action (before first comma)
					match($0, /^[^,]+/, a)
					action = a[0]
					gsub(/"/, "", action)
					gsub(/^ +| +$/, "", action)

					# Extract the datetime (the first quoted string after action)
					match($0, /"([^"]+)"/, dt)
					datetime = dt[1]

					# Remove the part up to datetime match to get the rest
					rest = substr($0, RSTART + RLENGTH)

					# Extract the filename (next quoted string)
					match(rest, /"([^"]+)"/, fp)
					filepath = fp[1]

					if (action == "Replaced") {
						counts[filepath]++
						found = 1
					}
				}
				END {
					if (found) {
						for (file in counts)
							print counts[file], file
					} else {
						print "No entries found"
					}
				}
				' "$xdata" | sort -rn | head -7
				echo

				cyan "Top overwritten files top 3"
				awk '
				{
					# Extract the action (before first comma)
					match($0, /^[^,]+/, a)
					action = a[0]
					gsub(/"/, "", action)
					gsub(/^ +| +$/, "", action)

					# Extract the datetime (the first quoted string after action)
					match($0, /"([^"]+)"/, dt)
					datetime = dt[1]

					# Remove the part up to datetime match to get the rest
					rest = substr($0, RSTART + RLENGTH)

					# Extract the filename (next quoted string)
					match(rest, /"([^"]+)"/, fp)
					filepath = fp[1]

					if (action == "Overwrt") {
						counts[filepath]++
						found = 1
					}
				}
				END {
					if (found) {
						for (file in counts)
							print counts[file], file
					} else {
						print "No entries found"
					}
				}
				' "$xdata" | sort -rn | head -3
				echo
				cyan "Top 5 Thats not actually a file"		
				awk '
				{
					# Extract action (before first comma)
					match($0, /^[^,]+/, m)
					action = m[0]
					gsub(/^ +| +$/, "", action)

					# Extract filename inside quotes (match last quoted string)
					match($0, /"([^"]+)"[^"]*$/, arr)
					filepath = arr[1]

					if (action == "Nosuchfile") {
						counts[filepath]++
						found=1
					}
				}
				END {
					if (found) {
						for (f in counts)
							print counts[f], f
					} else {
						print "No Nosuchfile entries found"
					}
				}
				' "$xdata" | sort -rn | head -5

					} 2>&1 | tee -a $output_file 

					echo >> $output_file

				echo
                    rm $xdata
                else
                    echo "Error decrypting ${statpst} stat file. Skipping"
                fi
			
				# Append any heuristics
				[ -s "$TOPT" ] && cat $TOPT >> $output_file && rm $TOPT # Search statistics
				perl -pe 's/\e(\[[0-9;?]*[a-zA-Z]|[\(\)][AB])//g' -i "$output_file"   # remove ASCII text
                ### End Stat queries
            fi
        else
            echo "Error decrypting ${logpst} log file. Skipping"
        fi
    fi
fi
# If there are searches in /tmp/rc prompt to display second set of awk commands
#if [ "$STATPST" == "true" ]; then
#    if [ -d $trc ]; then
#        read -t 10 -p "Show /tmp stats? (y/n): " ans
#        if [ $? -gt 128 ]; then
#          ans="n"
#        fi
#    fi
#fi
# Analysis on       /tmp searches
ofile=$rtmp/tmpinfo
#if [ -d $trc ] && [ "$STATPST" == "false" ] || [[ "$ans" =~ ^[Yy]$ ]]; then
if [ -d $trc ] && [ "$STATPST" == "false" ]; then # data to work from
    fs=$(find $trc -maxdepth 1 -type f | wc -l)
    if (( fs > 0 )); then
        x=0
        for file in $trc/*; do
            ((x++))
            cat "$file" >> $ofile
            if [[ $x -lt $fs ]]; then echo >> $ofile; fi
        done

		# Init
		sed -i '/NOTA-FI-LE 77:77:77/d' $ofile 
		cd /tmp || exit
		rm query_MDY* > /dev/null 2>&1

        #Heuristic session?
		(

        echo "Top 5 files created"
		awk '
		{
			match($0, /"([^"]+)"/, arr)
			if (arr[1] != "") print arr[1]
		}' "$ofile" | sort | uniq -c | sort -nr | head -n 5

        echo
		#read -r -p "any key continue..." 
		echo
        echo "Initiating recursive checks..."
		aat $ofile
		hr $ofile
		asz $ofile
		
		read -r -p "any key continue..." 

		echo
		#read -r -p "any key continue..." k

		#Average hour
		x=$( sed -n '/^[[:space:]]*$/p' $ofile | wc -l)
		if [ $x -eq 0 ]; then x=1; fi
		echo "Searches: ${x}"
		awk '
		{
			date = $1
			time = $2

			# Skip lines without valid time
			if (length(time) < 5) next

			hour = substr(time, 1, 2)
			minute = substr(time, 4, 2)

			# Validate hour and minute
			if (hour ~ /^[0-9]{2}$/ && minute ~ /^[0-9]{2}$/) {
				count[date, hour]++
				days[date] = 1
				minutes_arr[date, hour, minute]++
			}
		}

		END {
			day_count = length(days)
			if (day_count == 0) {
				print "No data to process."
				exit 1
			}

			# Sum counts per hour across all days
			for (key in count) {
				split(key, parts, SUBSEP)
				hour = parts[2]
				hour_totals[hour] += count[key]
			}

			max_avg = -1
			max_hour = -1

			# Find hour with highest average activity
			for (h = 0; h < 24; h++) {
				hh = sprintf("%02d", h)
				avg = (hour_totals[hh] ? hour_totals[hh] / day_count : 0)
				if (avg > max_avg) {
				    max_avg = avg
				    max_hour = h
				}
			}

			max_hour_str = sprintf("%02d", max_hour)

			# Calculate weighted average minute within peak hour
			sum_minutes = 0
			total_counts = 0
			for (key in minutes_arr) {
				split(key, parts, SUBSEP)
				d = parts[1]
				h = parts[2]
				m = parts[3] + 0
				if (h == max_hour_str) {
				    c = minutes_arr[key]
				    sum_minutes += m * c
				    total_counts += c
				}
			}

			avg_minute = (total_counts > 0) ? sum_minutes / total_counts : 0
			avg_min_int = int(avg_minute)

			# Decide top or bottom half
			half = (avg_minute < 30) ? "top of the hour" : "bottom of the hour"

			printf "Avg time of file activity: %02d:%02d (%.2f minutes)\n", max_hour, avg_min_int, avg_minute
			printf "(%s)\n", half
		}
		' $ofile
		
		echo
		echo "Detecting deleted files if overlap"
		#delsnap $ofile $output_file
				
		(cat "$ofile"; echo) | awk -v RS="" -v OFILE="$ofile" '
		function toNumTimestamp(date, time) {
    		gsub(/[-:]/, "", date)
    		gsub(/[:]/, "", time)
    		return date time
		}
		
		{
    		n = split($0, lines, "\n")
    		delete files
    		min_ts = ""
    		max_ts = ""
		
    		for (i = 1; i <= n; i++) {
        		split(lines[i], parts, /[ \t]+/)
        		ts_num = toNumTimestamp(parts[1], parts[2])
        		if (min_ts == "" || ts_num < min_ts) min_ts = ts_num
        		if (max_ts == "" || ts_num > max_ts) max_ts = ts_num
		
        		pos = match(lines[i], /"[^"]+"/)
        		if (pos > 0) {
            		filepath = substr(lines[i], RSTART, RLENGTH)
            		gsub(/\r/, "", filepath)
            		gsub(/"/, "", filepath)
        		} else {
            		filepath = ""
        		}
		
        		if (filepath != "") {
            		files[filepath] = 1
        		}
    		}
		
    		snapshot_num = NR
    		min_times[snapshot_num] = min_ts
    		max_times[snapshot_num] = max_ts
		
    		for (k in snapshots) {
        		split(k, arr, SUBSEP)
        		if (arr[1] == snapshot_num) {
            		delete snapshots[k]
        		}
    		}
		
    		for (f in files) {
        		key = snapshot_num SUBSEP f
        		snapshots[key] = 1
    		}
		
    		if (snapshot_num > 1) {
        		if (min_ts <= max_times[snapshot_num-1] && min_times[snapshot_num-1] <= max_ts) {
            		print "Snapshots " snapshot_num-1 " and " snapshot_num " overlap in time."
            		print "Deleted files between snapshots " snapshot_num-1 " and " snapshot_num ":"
		
            		deleted_found = 0
            		for (k in snapshots) {
                		split(k, arr, SUBSEP)
                		if (arr[1] == snapshot_num-1) {
                    		file_prev = arr[2]
                    		key2 = snapshot_num SUBSEP file_prev
                    		if (!(key2 in snapshots)) {
                        		print "  " file_prev
                        		deleted_found = 1
                    		}
                		}
            		}
            		if (!deleted_found) print "  None"
            		print ""
        		} else {
            		print "Snapshots " snapshot_num-1 " and " snapshot_num " do NOT overlap in time. Skipping deletion check."
            		print ""
        		}
    		}
		
    		print "===END_OF_SNAPSHOT==="
    		# fflush()
		}
		'
		
		#read -r -p "any key continue..." 
        echo
		echo "Type" # Heuristic session?
		awk -v RS="" '
		function to_epoch(ts,    cmd, epoch) {
		  cmd = "date -d \"" ts "\" +%s"
		  cmd | getline epoch
		  close(cmd)
		  return epoch
		}

		{
		  n = split($0, lines, "\n")
		  delete times
		  first_ts = ""
		  last_ts = ""

		  for (i = 1; i <= n; i++) {
			split(lines[i], parts, " ")

			# Extract timestamp: first two fields
			timestamp = parts[1] " " parts[2]
			times[i] = to_epoch(timestamp)

			if (i == 1) first_ts = timestamp
			if (i == n) last_ts = timestamp

			match(lines[i], /"[^"]+"/, match_arr)
			filepath = match_arr[0]
			if (filepath != "")
			  files[filepath]++
		  }

		  # Calculate time gaps
		  gaps_sum = 0
		  gaps_count = 0
		  max_gap = 0

		  for (i = 2; i <= n; i++) {
			gap = times[i] - times[i-1]
			gaps_sum += gap
			gaps_count++
			if (gap > max_gap) max_gap = gap
		  }

		  avg_gap = (gaps_count > 0) ? gaps_sum / gaps_count : 0
		  threshold = 60

		  session_type = (max_gap > threshold) ? "Separate session" : "Burst session"
			left_str = session_type " (" max_gap "s max gap)"
			printf "Snapshot %d: %-35s\tfrom %s to %s\n", NR, left_str, first_ts, last_ts
		 	#print "Snapshot " NR ": " session_type " (" max_gap "s max gap)\tfrom " first_ts " to " last_ts

		  delete files
		}
		' "$ofile"

        echo
        cyan "Most common extensions"
        ext $ofile

        echo
		echo "Detecting replaced files by inode (awk generated)"
		awk -v RS="" -v max=7 '
		function process_snapshot(snapshot,   i, lines, path, inode, m, rest, ino_match) {
  		n = split(snapshot, lines, "\n")
  		for (i = 1; i <= n; i++) {
    		if (match(lines[i], /"([^"]+)"/, m)) {
      		path = m[1]
      		rest = substr(lines[i], RSTART + RLENGTH)
      		if (match(rest, /[0-9]+/, ino_match)) {
        		inode = ino_match[0]
      		} else {
        		inode = ""
      		}
		
      		if (path == "" || inode == "") continue
		
      		if (prev_inode[path] && prev_inode[path] != inode) {
        		changes[path]++
        		found = 1        # Mark that we found at least one change
      		}
      		prev_inode[path] = inode
    		}
  		}
		}
		
		{
  		snapshots[NR] = $0
		}
		
		END {
  		start = (NR > max) ? NR - max + 1 : 1
  		for (i = start; i <= NR; i++) {
    		process_snapshot(snapshots[i])
  		}
  		if (found) {
    		for (p in changes) print changes[p], p
  		} else {
    		print "No results"
  		}
		}
		' "$ofile" | sort -rn | head -7

        ) 2>&1 | tee "$output_file"
	
        rm $ofile     
    fi
fi
if [ -s $flth ]; then #filter hits
	(

    echo
    cyan "Accessing filter"
    green "Filter"
    cat $flth 
	) 2>&1 | tee -a $output_file

	#[ "$outputTFILE" = "false" ]  && [ "$STATPST" == "false" ] && rm $output_file 
	#[ "$outputPSTFILE" == "false" ] && [ "$STATPST" == "true" ] && rm $output_file
	if [ "$outputTFILE" = "true" ]  && [ "$STATPST" == "false" ] && [ -d $trc ]; then
		test -e $output_file && green "Report in /tmp"
		cp $output_file /tmp$report
	fi	
	if [ "$outputPSTFILE" == "true" ] && [ "$STATPST" == "true" ]  && [ "$genPSTTFILE" == "true" ] && [ -s $logpst ]; then
		green "Report in /Downloads along with heuristics"
		cp $output_file /home/$2/Downloads$report
	elif [ "$outputPSTFILE" == "true" ] && [ "$STATPST" == "true" ] && [ -s $logpst ]; then
		green "Report in /Downloads"
		cp $output_file /home/$2/Downloads$report
	fi
fi
rm -rf $rtmp
