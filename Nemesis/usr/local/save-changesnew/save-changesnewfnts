#!/bin/bash
# save-changesnew functions to move options further up the script             09/20/2025
dycmb() {
TFLD=""
for x in $FOLDERS; do [[ -e "$ch/$x" ]] && TFLD="$TFLD $x" ; done
FOLDERS="$TFLD"
TFLD=""
for x in $FOLDERS; do [[ " $IFOLDERS " != *" $x "* ]] && TFLD="$TFLD $x" ; done
if [[ -n "$TFLD" ]]; then FOLDERS="$TFLD" ;  IFOLDERS="$IFOLDERS $FOLDERS" ; fi
FOLDERS="$(for f in $FOLDERS $IFOLDERS; do echo "$f"; done | awk '!seen[$0]++')"
}
#Generate exclude directories changes-commit
exldir() {
> $1
grep ^!/ $CHNEXIT_CONF | fixdir > $EXCL
if [ -s "$EXCL" ]; then
	fixsqh < $EXCL > $EXCLUDED
	sed -i 's|^|/|' $EXCLUDED
	while IFS= read -r line; do [[ -z "$line" ]] && continue ; if [[ ! " $EXCLUDE " == *" $line "* ]]; then EXCLUDE="$EXCLUDE $line" ; fi ; done < $EXCLUDED
	unset IFS
fi
> $EXCLUDED
for fld in $EXCLUDE; do if [[ $fld != /* ]]; then fld="*${fld}*"; else fld="${fld#/}" ; fi ; printf "%s\n" $fld ; done >> $EXCLUDED
grep -Fvxf $trsyncexl $EXCLUDED > $UPDATE; test -s $UPDATE && cat $UPDATE >> $1 && rm $UPDATE
}
#generate log file
dlog() {
	if [ "$d2drive" == "true" ]; then
       for fld in $FOLDERS; do
            fp="$dirSRC/$fld"
            if [ -d "$fp" ]; then
                find "$fp" -type f -printf '%P\n' | sed "s|^|/$fld/|" >> "${target}${rlt}${MODULENM}.bak.log"
            fi
        done
        for fld in $EXCLUDE; do
            fp="$dirSRC/$fld"
			if [[ "${fp:0:1}" == "/" ]]; then
			  	e=$(sed 's/[\/&\\]/\\&/g' <<< "$fp")
				p="^"
			else
			  e="$fp" ; p=""
			fi
			sed -i "/$p$e/d" "${target}${rlt}${MODULENM}.bak.log"
		done
    else
        find "$dirSRC" -type f -printf '%P\n' >> "${target}${rlt}${MODULENM}.bak.log"
    fi
    echo >> "${target}${rlt}${MODULENM}.bak.log"
}
glog() {
local k
local p
if [ -f ${target}${rlt}${MODULENM}.bak.log ]; then
	b=$( sed -nE 's/.original count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log)
	c=$( sed -nE 's/.total count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log)
	k=$( sed -nE 's/.*original size\(source\)=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log)
fi
: "${b:-0}"
: "${c:-0}"
c=$(( c + b ))
: "${k:=Unkown}"
#if [ "$k" == "Unkown" ]; then
#    p=$( sed -nE 's/.*new size\(source\)=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log)
#fi
#: "${p:=Unkown}"
#if [ "$p" == "Unkown" ]; then
# do we go back and check the actual changes for size??
p=$osize
if [ "$1" == "true" ]; then > "${target}${rlt}${MODULENM}.bak.log" ; fi
dlog
echo "original size(source)=$k" >> "${target}${rlt}${MODULENM}.bak.log"
echo "new size(source)=$p" >> "${target}${rlt}${MODULENM}.bak.log"
if (( c != 0 )); then
    echo "original count=$c" >> "${target}${rlt}${MODULENM}.bak.log"
fi
echo  "END ORIGINAL FILES $(date +"%m-%d-%y_%R")" >> "${target}${rlt}${MODULENM}.bak.log"
nLOG="true"
}
autosave() { if [[ "$autobackup" == "true" ]] && { [[ "$bck" == "yes" ]] || [[ "$bck" == "y" ]] ; } ; then z=$( grep -Fm 1 "USR" $chc | awk -F'"' '{print $2}') ; [[ -z "$z" ]] && sed -i "s/USR=.*/USR=\"$USR\"/g" $chc ; zz=$( grep -Fm 1 "target" $chc | awk -F'"' '{print $2}') ; [[ -z "${zz}" ]] && sed -i "s|target=.*|target=\"$target\"|g" $chc ; [[ ! -x $chc ]] && chmod +x $chc ; else [[ -x $chc ]] && chmod -x $chc ; fi ; }
#r=$( basename "$0") ; val="$r \"$target\" \"$USR\""
#if ! grep -q "$r" $chc; then 
#	sed -i "4i $val" $chc
#else
#p=$( grep -Fn "$r" $chc | cut -d: -f1) ; lnc=$( grep "$r" $chc | awk -F'"' '{print $2}')
#if [ "$lnc" == "" ]; then sed -i "${p}c $val" $chc ; fi # only once
#fi
brnd() { BRAND=`date +"MDY_%m-%d-%y-TIME_%R"|tr ':' '_'` ; echo $BRAND >> $1 ; }
errmsg() { mount -o remount,udba=none / ; if [ "$1" != "false" ]; then rm -rf "$1" ; fi ; red "Error making the new module in ${instm}: ${2}" >&2 ; cyan "Everything preserved.  Check the script" ; exit 1 ; }
errblk() { [[ "$trlt" -ne 0 ]] && echo "$trlt" && errmsg "$mtmp" "updating .xzm" ; }

# Find out the files that have changed with dry run
createlog() {
rsync -an --out-format="%f" "$1/" "$2" --exclude '.wh.*' --exclude-from=$EXFILES > $3 # what changed
rsync -anv "$1/" "$2" --exclude '.wh.*' --exclude-from=$EXFILES > $4 # rsync log
}

# Labelling before making .xzm from $ch
labelmk() {
brnd $1
if [ "$linkedLOGPRF" == "full" ]; then
    { echo ; cat $1; } >> $LOGDIR/$LOGFILE
elif [ "$linkedLOGPRF" == "incr" ]; then
    cp $1 $LOGDIR/$LOGFILE    
fi
}


# Make a new .xzm take into account previous changes 
# so we have a small .xzm if still in session. for _uid_
newuid() {
shopt -s globstar
keep=$tmp/outfile # perishable
remove=$tmp/deletre # ..
cd $mtmp || exit
h=$(find $target$em -type f -name '*_uid_*.xzm' ! -name '*_uid_L*' -print0 | xargs -0 ls -t | head -n 1)
r=0
if [[ -f /dev/shm/xsc && -n "$h" && -f "$h" ]]; then
    tfile=$( cat /dev/shm/xsc)
    if [ -f $tfile ]; then # still there?
        for mods in $target$em"/"*_uid_*.xzm; do # ext prev changes
            [[ "$mods" == *_uid_L* ]] && continue
            if (( r == 0 )); then
                if [ "$mods" == "$tfile" ]; then
                    r=1 # everything after and including tfile
                fi
            fi
            if (( r )); then
                startmnt
                mount -o loop $mods $dest
                rsync -a "$dest/" "$tmp" --exclude '.wh.*'
                rlt=$?
                if [ "$rlt" -ne 0 ]; then clea ; echo "failed to extract in newuid(). if unable resolve remove /dev/shm/xsc" && exit 1 ; fi
                clea
            fi
        done
    else # use the last one
        tmpdirt=$(mktemp -d) && mount -o loop $h $tmpdirt
        rsync -a "$tmpdirt/" "$tmp" --exclude '.wh.*'
        umount $tmpdirt && rmdir $tmpdirt
    fi

    # total current files
    rsync -a "$ch/" "$mtmp" --exclude '.wh.*' --exclude-from=$EXFILES

    test -e $LOGDIR/$LOGFILE && rm $LOGDIR/$LOGFILE # dont exclude from changes from $mtmp
    find $mtmp -type f -printf '%P\n' > $tmp/contents 
    createlog $mtmp $tmp $UPDATE $oMF
    c="${mtmp#/}"  # --out-format="%f" consistent log depends on version of rsync **
    sed -i -e "\|$c/\.|d" -e "s|$c/||" -e '/^\./d' $UPDATE
    cp $UPDATE $keep

    #$tmp/contents # changes
    #$keep # what needs to be transfered
    #$remove  what should not be copied
    cat $tmp/contents | grep -Fvf $keep > $remove # remove list
    cat $remove >> $EXFILES

    labelmk $oMF # Copy log before .xzm

    base_cmd=(mksquashfs $ch "$target$em$rname" -comp $cmode -ef $EXFILES)
    if [ "$FEEDBACK" != "true" ]; then "${base_cmd[@]}" > /dev/null ; else "${base_cmd[@]}" ; fi

else
    echo "$target$em$rname" > /dev/shm/xsc
    if ! createxzm; then
        echo "Changes not saved either a file changed while saving or something went wrong."
    fi
fi 
cd $pst
}

createxzm() { 
createlog $ch $tmp $UPDATE $oMF
labelmk $oMF
cm=(mksquashfs $ch "$target$em$rname" -comp $cmode -ef $EXFILES)
cpt=$( "${cm[@]}" 2>&1 | grep "changed size while reading" )
if [[ -n "$cpt" ]]; then 
    echo "$cpt"
    test -e "$target$em$rname" && rm "$target$em$rname"
    return 1
fi 
} 

# mksquash doesnt recognize wildcards and exclusions together
# branch to either making a uid or uid_L
# try the fast way. If file changes copy to mtmp to freeze fs
newxzm() {
all=()
keep=()

mkdir $tmp
mkdir $mtmp

# Backup EXFILES
cp $EXFILES $QEXCL

# Process wildcards for mksquashfs
while IFS= read -r l; do [[ -z "$l" ]] && continue ; if [[ "$l" == \** ]]; then echo "$l" ; fi ; done < $EXFILES > $exclfiles # read patterns from $EXCLUDE ie *share/Trash* 
while IFS= read -r p; do [[ -z "$p" || "$p" =~ ^# ]] && continue ; find "$ch" -path "$ch"/$p \( -type f -o -type d \) -print | sed "s|^$ch/||" ; done < <(cat $trsyncexl $exclfiles ) >> $EXFILES  # search the wildcards for mksquashfs

# all base folders in changes
while IFS= read -r d; do all+=("$(basename "$d")") ; done < <(find "$ch" -maxdepth 1 -mindepth 1 ) # ! -name ".wh.*"  
unset IFS 
# generate all base folders to exclude ie anything not in $FOLDERS at base /changes
for d in "${all[@]}"; do fd="false" ; for f in $FOLDERS; do [[ "$d" == "$f" ]]  && fd="true" && break ; done ; [[ "$fd" == "false" && -d "$ch/$d" ]] && keep+=("$d") ; done 
printf "%s\n" "${keep[@]}" >> "$EXFILES"
test -e $exclfiles && rm $exclfiles

if [ "$1" == "uid" ]; then
    if [ "$d2dmdl" == "true" ]; then
        tmp=$(mktemp -d "$xtgt/tmp.XXXXXX")
    fi
    newuid

else #uid_L

    createxzm # try changes
    trlt=$?

    # move to /tmp
    if [ "$trlt" -ne 0 ]; then 
	    echo "Files changed while saving copying to tmp..."
        cp $QEXCL $EXFILES # reset exclusions for rsync
        procxzm $1 # copy log and exclude with rsync.
	    base_cmd=(mksquashfs $mtmp "$target$em$rname" -comp $cmode)
        if [ "$FEEDBACK" != "true" ]; then "${base_cmd[@]}" > /dev/null ; else "${base_cmd[@]}" ; fi
    fi
fi
if [ "$ANALYTICS" == "true" ]; then end=$(date +%s.%N) ; el=$(awk "BEGIN {print $end - $start}") ; fi
}

# Labeling of .xzm for files in /tmp below
label() {
mkdir -p "$mtmp$LOGDIR"
if [ "$linkedLOGPRF" == "full" ]; then
    { echo ; cat $UPDATE ; } >> $LOGDIR/$LOGFILE ; rm $UPDATE ; cp $LOGDIR/$LOGFILE $mtmp$LOGDIR/$LOGFILE
elif [ "$linkedLOGPRF" == "incr" ]; then
    test -e $ch$LOGDIR/$LOGFILE && rm $ch$LOGDIR/$LOGFILE ; cp $UPDATE $mtmp$LOGDIR/$LOGFILE && mv $UPDATE $LOGDIR/$LOGFILE    
fi
}
run_cmd() { if [ "$FEEDBACK" != "true" ]; then "$@" >>"$UPDATE" 2>/dev/null ; else "$@" | tee -a "$UPDATE" ; fi ; trlt=$?; } # see Merge ln 136
procxzm() {
adtcmd=(--exclude '.wh.*')
cd $ch || { mount -o remount,udba=none /; exit; }
if [[ -z "$1" ]]; then
    IFS="
    "
    for y in $(find $FOLDERS -name ".wh.*"); do
	    f="${y//.wh./}"
        test -e "$mtmp/$f" && rm -rf "${mtmp:?}/$f";
	    found="false"
	    for file in "$INAME"/*/"$f"; do [ -e "$file" ] && found="true" && break ; done
        [[ "$found" == "true" ]] || { echo "$y" | fixwh >> $EXCL; echo "$y" >> $EXCLUDED; test -e "$mtmp/$y" && rm -f "$mtmp/$y"; }  #  | fixsqh >> $QEXCL; echo "$y" 
    done

    test -s "$EXCL" && { find $FOLDERS -type d | egrep -vf $EXCL || find $FOLDERS -type d; } > $SFOLDERS
    for y in $(find $mtmp -name ".wh.*"); do
        f="$(echo "$y" | sed -e "s^$mtmp^^g" -e 's^\.wh\.^^g')"
        test -e "$f" && rm "$y";
    done
    unset IFS
    #find $mtmp -name ".wh.*" -exec rm -r {} \;  # ! -name ".wh..*"
fi  

base_cmd=(rsync -aHv "${adtcmd[@]}" --exclude-from=$trsyncexl) && [[ -s "$EXFILES" ]] && base_cmd+=(--exclude-from=$EXFILES)
run_cmd "${base_cmd[@]}" $FOLDERS "$mtmp/" ; errblk # merge

# Remove exclusions there could be new ones
if [[ -z "$1" ]]; then 
    cd $mtmp || exit 
    while IFS= read -r ex; do 
        [ -n "$ex" ] || continue
        ex="${ex%/}" 
        if [[ "$ex" == */* ]]; then 
            find "$mtmp" -mindepth 1 -path "$mtmp/$ex" -exec rm -rf -- {} + 
        else 
            find "$mtmp" -mindepth 1 -name "$ex" -exec rm -rf -- {} + 
        fi 
    done < <(cat "$trsyncexl" "$EXFILES") 
fi

brnd $UPDATE
label
}

# used to create one l module from another simple function that is called in different conditions in the script saves lines
createlmdl () {
local instm="$1"
    if [ "$instm" != "nolmdl" ]; then
        mkdir $mtmp
        for mods in "$target$em/"*_uid_L*.xzm; do [[ "$fname" == "" ]] && fname="$mods" ; if ! xzm2dir $mods $mtmp; then errmsg $mtmp "$fname" ; fi ; done
	    procxzm
    fi
    if [ "$ssbn" == "" ]; then
        if [ "$validrlt" == "false" ]; then cyan "mfile byte match failed generating new serial no." ; else cyan "no msr file. creating new one and new serial." ; fi
        ssbn=$(rand_alpha)${$}$(printf "%02d" $((RANDOM % 100)))
    fi
    if [ "$rlt" == "true" ]; then
        if [ "$validrlt" == "false" ]; then
            c=${fname%.xzm}".bak"
            mv $target$em"/"$fname $target$em"/"$c
        else
            green "Matched.. In link state"
            if [ "$keepLINKEDMRGED" == "false" ]; then
                rm $target$em"/"$fname
            else
                c=${fname%.xzm}".bak"
                mv $target$em"/"$fname $target$em"/"$c
            fi
        fi
    elif [ "$rlt" == "" ] && [ "$instm" != "nolmdl" ]; then
        c=${fname%.xzm}".bak"
        mv "$fname" $c
    fi
    SERIAL=`date +"%m-%d-%y_%R"|tr ':' '_'` ;  rname="${MODULENM}${SERIAL}_uid_L${ssbn}.xzm"
    if [ "$instm" != "nolmdl" ]; then
		cmd=(mksquashfs $mtmp "$target$em$rname" -comp $cmode -ef $EXFILES -ef $trsyncexl)
        [[ -s "$QEXCL" ]] && cmd+=(-ef "$QEXCL") ; "${cmd[@]}"
        if [ "$ANALYTICS" == "true" ]; then end=$(date +%s.%N) ; el=$(awk "BEGIN {print $end - $start}") ; fi
    else
        newxzm "_uid_L"
    fi
	if [ "$ROLLBCK" == "true" ]; then
		if [ -d "${target}${em}/archive/_uid_L" ]; then
			r=$(find "${target}${em}/archive/_uid_L" -maxdepth 1 -type f -name '*.bak' 2>/dev/null | wc -l)
			if [ "$r" -ge "$archLMT" ]; then
				for mods in ${target}${em}/archive/_uid_L/*_uid_L*.bak; do
					rm -f $mods
					test -f $mods.txt && rm $mods.txt
					break
				done
			fi
		else
			mkdir -p "${target}${em}/archive/_uid_L"
		fi
		cp "$target$em$rname" "${target}${em}/archive/_uid_L${rname}.bak"
		if [ "$ROLLSUMRY" == "true" ]; then
			find "$mtmp" -type f -printf '%P\n' >> "${target}${em}/archive/_uid_L${rname}.bak.txt"
			echo >> "${target}${em}/archive/_uid_L${rname}.bak.txt"
		    BRAND=`date +"MDY_%m-%d-%y-TIME_%R"|tr ':' '_'`
    		echo $BRAND >> "${target}${em}/archive/_uid_L${rname}.bak.txt"
		fi
	fi
    xsize=$( du -sb "$target$em$rname" | cut -f1)
    fname="${mdlnm}${SERIAL}_uid_L${ssbn}.xzm"
    if [ "$rlt" == "true" ]; then
        sed -i "s/bytes:.*/bytes:${xsize}/" $msr
        sed -i "s/file name:.*/file name:${fname}/" $msr
    else
        { echo "bytes:"$xsize ; echo "file name:${fname}" ; echo ; } > $msr
    fi
    cd $pst ; rm -rf ${mtmp:?}
}
renmmdl() {
local oMF=/tmp/flog.log ; local drt=$2
[[ -z "$drt" ]] && src=".bak" && dst=".xzm"
[[ -n "$drt" ]] && [[ "$drt" == "-r" ]] && src=".xzm" && dst=".bak" || { [[ -n "$drt" ]] && echo invalid flag && exit ; }
r=$(ls -1 | grep ".*${1}.*${src}" | grep -v "$dst" | wc -l)
if [ "$r" -gt 0 ]; then
    for mods in ${PWD}"/"*$1*$src; do [[ "$1" == "_uid_" ]] && [[ "$mods" == *"_uid_L"* ]] && continue ; fname=${mods%"$src"}$dst ; test -e $fname && { red Filename conflict $fname already exists. ; test -e $omf && rm $omf; exit 0; } ; echo $mods ; done >> $oMF
    while IFS= read -r ofile; do  [[ -z "$ofile" || "$ofile" == \#* ]] && continue ; fname=${ofile%"$src"}$dst ; mv "$ofile" "$fname" ; done < "$oMF"
    rm $oMF
else
    cyan "no ${src} $1"
fi
}
startmnt() {
dest="/mnt/loop-$(basename "$mods" .xzm)"
[[ -d $dest ]] && { echo "Error: $dest mount dir already exists. remove and try again." && exit; } || mkdir $dest
if mountpoint -q $dest; then echo "Error: $dest already mounted. Everything preserved."; exit 1; fi
if [ ! -f "$mods" ]; then echo "Error: In wrong directory. '$dest' not found."; exit 1; fi
}
clea() { umount $dest && rm -rf $dest; }
unpack() {
for mods in $PWD"/"*_uid_*.xzm; do
    (( x == 0 )) && { cd $1 || exit ; } ; (( x++ ))
    [[ "$mods" == *_uid_L* ]] && continue
    echo $mods >> $oMF
    startmnt
	mount -o loop $mods $dest
	find "${dest}/" -type f -name '.wh.*' -printf '%P\0' | while IFS= read -r -d '' file; do
        #found="false"
        k=$( echo "$file" | sed -e 's/^\.wh\.//')
		#p=$( echo "$file" | sed -E 's|(.*\/)\.wh\.|\1|') # keep path remove .wh.
        test -e "$k" && rm -rf "$k";

	    #for f in "$INAME"/*/"$k"; do [ -e "$file" ] && found="true" && break ; done
        #[[ "$found" = "true" ]] || { test -e "$file" && rm -f "$file"; }  #  | fixsqh >> $QEXCL; echo "$y" 
        #test -e "$INAME/"*"/$k" || test -e "$file" && rm -f "$file"  #  { echo "y" | fixsqh >> $EXCL; echo "$y" >> $EXFILES; test -e "$y" && rm -f "$y"; }            # echo "$y" | fixwh >> $EXCL; echo "$y" >> $EXCLUDED; 
    done
    unset IFS
    cp -afv $dest/* $1 2> >(tee /tmp/error.log >&2)
    if [ $? -ne 0 ]; then
        if grep -v '\.wh\.' /tmp/error.log > /dev/null; then
            red "Error processing one of the modules ${mods}"
            cyan "Everything preserved. Check the script and try again. check /tmp/error.log"
            clea ; rm $oMF ; rm -rf $1 ; exit 1
        else
            cyan "White out file detected and processed"  >&2
        fi
    fi
    clea
done
unset IFS

#find . -name ".wh.*" -exec rm -r {} \;
cd $pst
}
rand_alpha() { letters=( {A..Z} {a..z} ); echo -n "${letters[RANDOM % 52]}${letters[RANDOM % 52]}" ; }
loadermsg() { green "Updated bootloader in /syslinux/"; cyan "if you use a different loader use cheatcode extramod=${target}${em} include changes modules" ; }
fixdir() { sed -e 's_\._\\._g' -e 's_?_._g' -e 's_*_.*_g' -e 's@..@^@'; }
fixsqh() {  sed -e 's|^/||' -e 's/^\^//' ; }
fixwh() { sed -e '/^\^/!s@^@^@' -e 's_\._\\._g' -e 's_?_\\?_g' -e 's_+_\\+_g' -e 's_*_\\*_g' -e 's_\$_\\$_g' -e 's_\[_\\[_g' -e 's_(_\\(_g' -e 's_\&_\\&_g' -e 's_\(^.\)\^\(.*\)_\1\\^\2_'; } # Translating
unfixwh() { sed -e 's/\\//g' -e 's/\(^.\)\^\(.*\)/\1^\2/' ; }
fixcmp() { sed -e 's_|_\\|_g' -e 's_ _\\ _g' -e 's_\._\\\._g' -e 's_\]_\\]_g' -e 's_\[_\\[_g' -e 's_(_\\(_g' -e 's_)_\\)_g' ; } # -e 's_\/_\\\/_g' 
fixOT() { sed -e 's_?_\\?_g'  -e 's_\^_\\^_g' -e 's_+_\\+_g' -e 's_*_\\*_g' -e 's_\$_\\$_g'  -e 's_\&_\\&_g' ; }

#cat $EXCL | unfixwh | fixsqh > $exclfiles   
#test -s $exclfiles && grep -Fvxf $EXFILES $exclfiles > $UPDATE && rm $exclfiles; test -s $UPDATE && cat $UPDATE >> $EXFILES && rm $UPDATE
#base_cmd=(rsync -aHv --from0 --files-from=$SFILES "${adtcmd[@]}" --exclude-from=$trsyncexl) && { run_cmd "${base_cmd[@]}" $ch "$mtmp/" ; trlt=$? ; errblk ; }
# for x in $FOLDERS; do run_cmd "${base_cmd[@]}" "${ch}/${x}/" "$mtmp/${x}/" ; done
#supress stat on .wh. for user
#if [ "$1" == "_uid_L" ]; then cat $trsyncexl > $exclfiles ; else cat $trsyncexl | grep -v "*.wh..*" > $exclfiles  ; fi # include .wh. and .wh.. for _uid_
#  { echo "y" | fixsqh >> $EXCL; echo "$y" >> $EXFILES; test -e "$y" && rm -f "$y"; }
