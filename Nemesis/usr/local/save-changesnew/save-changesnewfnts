#!/bin/bash
# save-changesnew functions to move options further up the script             08/04/2025
#
#
# Function for creating a original format log with new master list and original size
# get new size and put in new log. Called twice once for resuming from a pause
# or exceeding log size in log delete preference. For Graphics changes mode
# General inc exl logfile structure d2d or no
dycmb() {
    # New version 5.0
    TFLD="$(for x in $( echo $FOLDERS); do test -e "$ch/$x" && echo "$x"; done)"  
    FOLDERS="$TFLD" ; TFLD=""
    [[ -n "$IFOLDERS" ]] && TFLD="$(for x in $(echo "$IFOLDERS" | tr ' ' '\n' | awk '!seen[$0]++'); do [[ ! " $FOLDERS " == *" $x "* ]] && test -e "$ch/$x" && echo "$x" ; done)" # Dynamically build with changes-exit conf
    [[ -n "$TFLD" ]] && { IFOLDERS="$TFLD" ; FOLDERS=$IFOLDERS; } # combine
}
#Generate exclude directories changes-commit
exldir() {
	read -ra arr <<< "$EXCLUDE" 
	> $1
	for item in "${arr[@]}"; do
		if [[ "${item:0:1}" == "/" ]]; then #if ! grep -Fxq "./$item" $exlfiles; then ;fi
		    echo ".${item}" >> $1 # So rsync can work with it
		else
		    echo $item >> $1 # Exclude by pattern anywhere in subdirs
		fi
	done          # Good done

	# Folders to exclude: argument for `egrep'           reparse conf
	grep ^!/ $CHNEXIT_CONF | fixdir > $EXCL

	# Process exclusions from changes exit conf
	if [ -s "$EXCL" ]; then    # Include into a exclusions
		cat $EXCL | fixexcl > $EXCLUDED  # Temporary holding var/lib     ^^ to no ^^ and converts regex back to std
		
		#sed -i 's|^[^/]|\//&|' $EXCLUDED #  If it doesnt start with  /   add     /
		sed -i 's|^|/|' $EXCLUDED # for rsync ./var/lib      
		EXCLUDE="$EXCLUDE $(tr '\n' ' ' < $EXCLUDED | sed 's/ *$//')"    # Duplicates dont matter as not using mksquashfs
		#UPDATE="$(for x in $EXCLUDED; do if [[ " $EXCLUDE " != *" $x "* ]];  # Dynamically build with changes-exit conf  EXCLUDE  var
		#[[ -n "$UPDATE" ]] && EXCLUDE="$EXCLUDE $UPDATE"     # combine
		sed -i 's|^/|./|' $EXCLUDED # for rsync ./var/lib
		#sed -i 's|^|.|' $EXCLUDED # for rsync ./var/lib
		grep -Fvxf $1 $EXCLUDED >> $UPDATE; test -s $UPDATE && cat $UPDATE >> $1 # only those that are unique to $EXCLUDED appended from changes-exit conf if [[ " $EXCLUDE " != *" $x "* ]]; then echo "$x"; fi
	fi 			
}
#dyn exclude d2d
dlog() {
	if [ "$d2drive" == "true" ]; then  # generate log file 
       for fld in $FOLDERS; do
            fp="$dirSRC/$fld"                    
            if [ -d "$fp" ]; then
                find "$fp" -type f -printf '%P\n' | sed "s|^|/$fld/|" >> "${target}${rlt}${MODULENM}.bak.log"
            fi
        done
        for fld in $EXCLUDE; do
            fp="$dirSRC/$fld"                    
			if [[ "${fp:0:1}" == "/" ]]; then
			  e=$(sed 's/[&/\]/\\&/g' <<< "$fp" )
				p="^"
			else
			  e="$fp" ; p=""
			fi
			sed "/$p$e/d" "${target}${rlt}${MODULENM}.bak.log"
		done #if [ -d "$full_path" ]; then find "$full_path" -type f -printf '%P\n' | sed "s|^|/$fld/|" >> "${target}${rlt}${MODULENM}.bak.log"  fi
    else
        find "$dirSRC" -type f -printf '%P\n' >> "${target}${rlt}${MODULENM}.bak.log"
    fi
    echo >> "${target}${rlt}${MODULENM}.bak.log"
}
glog() {
local k
local p

        ### grab the original byte count before its erased ###

        b=$( sed -nE 's/.original count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log) # the current saved bytes over time
        : "${b:-0}" #if c is not there set it to 0        c=$( sed -nE 's/.total count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log) # the current saved bytes over time
        c=$( sed -nE 's/.total count=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log) # the current saved bytes over time
        : "${c:-0}" #if c is not there set it to 0
        c=$(( c + b ))

        ###                                                                     ###

        #first get the original from the log file  ****
        k=$( sed -nE 's/.*original size\(source\)=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log)
        : "${k:=Unkown}"
        #if [ "$k" == "Unkown" ]; then
        #    p=$( sed -nE 's/.*new size\(source\)=([0-9.]+).*/\1/p' ${target}${rlt}${MODULENM}.bak.log)
        #fi
        #: "${p:=Unkown}"
        #if [ "$p" == "Unkown" ]; then
            # do we go back and check the actual changes for size??
            p=$osize # actual original size (could have changed from the original as we are resuming
        #fi 
        # we need to make one
        # generate log file        

		# If this is called from a log size limit exceedence we can clear it as we have the necessary byte count
		#if [ "$1" == "true" ]; then :> "${target}${rlt}${MODULENM}.bak.log"; fi
#        if [ "$d2drive" == "true" ]; then
#            
#            # we need to get only the the included folders from the new source drive
#            for fld in $FOLDERS; do
#                full_path="$dirSRC/$fld"                    
#                if [ -d "$full_path" ]; then
#                    find "$full_path" -type f -printf '%P\n' | sed "s|^|/$fld/|" >> "${target}${rlt}${MODULENM}.bak.log"
#                fi
#            done
#        else
#            find "$dirSRC" -type f -printf '%P\n' >> "${target}${rlt}${MODULENM}.bak.log"
#        fi
#        echo >> "${target}${rlt}${MODULENM}.bak.log"
		dlog # check d2d




        echo "original size(source)=$k" >> "${target}${rlt}${MODULENM}.bak.log"
        echo "new size(source)=$p" >> "${target}${rlt}${MODULENM}.bak.log"
        if (( c != 0 )); then
            echo "original count=$c" >> "${target}${rlt}${MODULENM}.bak.log" # insert the original byte count for analytic purposes only if we have it
        fi
        
        #if [ "$ANALYTICS" == "true" ]; then
             # filesize=$(stat -c %s "$filename")

            # osize=$(du -sb "${target}${rlt}${MODULENM}/" | cut -f1) #original size       <----       we dont know anything about it
            #csize=$(du -sb "${target}${rlt}${MODULENM}.bak/" | cut -f1) # backup size

            #tsize=$(( osize - csize )) <--- nope
         
            
            # see line 273 as we cant append anything else unless rsync runs so we set nOPT here and return to check
            # as user may change a setting while already having the backup        
        #fi

        echo  "END ORIGINAL FILES $(date +"%m-%d-%y_%R")" >> "${target}${rlt}${MODULENM}.bak.log"
    
        # at this point we are making a new backup because we are resuming and have no idea the original format
        # and we cant rebuilt the exact original format so we have to generate one based on the current state
        nLOG="true" 
}
# random serial generating function
rand_alpha() { letters=( {A..Z} {a..z} ); echo -n "${letters[RANDOM % 52]}${letters[RANDOM % 52]}" ; }
loadermsg() { green "Updated bootloader in /syslinux/"; cyan "if you use a different loader use cheatcode extramod=${target}${em} include changes modules" ; }
# Fix folder names and make `egrep' interpret wildcards
fixdir() { sed -e 's_\._\\._g' -e 's_?_._g' -e 's_*_.*_g' -e 's@..@^@'; }
# Fix EXCL to work with mksquashfs exclusion file
fixsqh() {  sed -e 's|^/||'; }
# Fix whiteout names so `egrep' doesn't interpret special characters as regex
#fixwh() { sed -e '/^\^/!s@^@^@' -e 's_\\_\\\\_g' -e 's_\._\\._g' -e 's_?_\\?_g' -e 's_+_\\+_g' -e 's_*_\\*_g' -e 's_\$_\\$_g' -e 's_\[_\\[_g'  -e 's_]_\\]_g' -e 's_(_\\(_g' -e 's_)_\\)_g' -e 's_{_\\{_g' -e 's_}_\\}_g' -e 's_|_\\|_g' -e 's_\&_\\&_g' -e 's_\(^.\)\^\(.*\)_\1\\^\2_'; } # escape \ infilenames  ] { } |
fixwh() { sed -e '/^\^/!s@^@^@' -e 's_\._\\._g' -e 's_?_\\?_g' -e 's_+_\\+_g' -e 's_*_\\*_g' -e 's_\$_\\$_g' -e 's_\[_\\[_g' -e 's_(_\\(_g' -e 's_\&_\\&_g' -e 's_\(^.\)\^\(.*\)_\1\\^\2_'; } # Translating
# Fix regarding ^^ doesnt break egrep but wont match a pattern  ^/thisdir/^myfile or ^/thisdir/my^file
#fixwh() { sed -e 's_\._\\._g' -e 's_?_\\?_g' -e 's_+_\\+_g' -e 's_*_\\*_g' -e 's_\$_\\$_g' -e 's_\[_\\[_g' -e 's_(_\\(_g'  -e 's_\&_\\&_g' -e 's@^@^@'; } Original
# Fix EXCL to work with rsync exclusion file
fixexcl() { sed -e 's/^\^//'; } # change note remove leading ^ if present
#fixexcl() {  sed -e 's|\^||g' -e 's| |\\ |g' -e 's|]|\\]|g' -e 's|)|\\)|g'; } Original
