#!/bin/bash
#   Developer buddy 3.0 core                                               08/28/2025
sbwr() {
webb=(
    'mozilla'
	'.mozilla'
    "$LCLMODULENAME"
# other
)
}
get_colors(){
txtyellow=${txtbld}$(tput setaf 3)
txtblue=${txtbld}$(tput setaf 4)
function yellow() { echo -e $txtyellow "$1" $rst; }
function blue(){ echo $txtblue "$1" $rst; }
}
postop() {
if [ "$POSTOP" == "true" ]; then
	while IFS= read -r x; do x="$(unescf "$x")" ; printf '%s\0' "$x"; done < $1 >> $xdata
    if [ -f $USRDIR/doctrine.tsv ]; then
        sed -i 's/^export POSTOP="true"/export POSTOP="false"/' $2
    else
        echo -e "Datetime\tFile\tSize(kb)\tType\tModified\tAccessed\tOwner" > $atmp/doctrine
        while IFS= read -r -d '' x; do
            f="$(cut -d' ' -f3- <<< "$x")"
            dt=$(cut -d' ' -f1-2 <<< "$x")
            if [ -e "$f" ] && [ -f "$f" ]; then
                onr=$( stat -c "%U" "$f")
                mtyp=$( file --brief --mime-type "$f")
                if [ "$mtyp" == "application/octet-stream" ]; then mtyp="Unknown"; fi
                if [ -L "$f" ]; then mtyp="Symlink"; fi
                sz=$( stat -c %s "$f")
                md=$( stat -c '%Y' "$f") ; x=$(date -d "@$md" +'%Y-%m-%d %H:%M:%S')
                ae=$( stat -c '%X' "$f") ; y=$(date -d "@$ae" +'%Y-%m-%d %H:%M:%S')
                echo -e "$dt\t$f\t$(( sz / 1024 ))\t$mtyp\t$x\t$y\t$onr" >> $atmp/doctrine
            fi
        done < $xdata
        unset IFS
        head -1 $atmp/doctrine > $USRDIR/doctrine.tsv
        tail -n +2 $atmp/doctrine | sort -t$'\t' -k7,7 -k3,3n >> $USRDIR/doctrine.tsv
        green "File doctrine.tsv created in $USRDIR"
    fi
fi
}
stmp() {
sf=$MODULENAME"_"$FLBRAND
if (( tmpSRHS > 0 )); then
    test -d /tmp/rc || mkdir /tmp/rc
	r=$(find /tmp/rc -maxdepth 1 -type f -name '*rntfiles_MDY*' 2>/dev/null | wc -l)
    if [ "$r" -eq "$tmpSRHS" ]; then
        test -f /tmp/rc/full || { touch /tmp/rc/full ; cyan "searches builtup in /tmp/rc"; }
        for file in "/tmp/rc"$MODULENAME"_MDY"*
        do
            rm -f $file
            break
        done
    fi
	awk 'NF' $1 > $TMPCOMPLETE; mv $TMPCOMPLETE $1
    cp $1 "/tmp/rc"$sf
fi
}
filterhits() {
local lt=$atmp/patterns.txt
local fl=/usr/local/save-changesnew/filter
test -f $2 || echo "Entry,Hits" >> $2
sed -n '/^[[:space:]]*#/!s|sed -i '\''/\(.*\)/d'\''.*|\1|p' "$fl" > $lt
while IFS= read -r pattern; do
    k=$( echo "$pattern" | sed -e 's/\\//g' -e "s|'\"\${2}\"'|$USR|g")
    x=$( grep -Fc -- "$k" $1)
    if grep -Fq "sed -i '/$pattern/d" $2; then
        if (( x > 0 )); then
            y=$( grep -F "sed -i '/$pattern/d" $2 | cut -d',' -f2)
            b=$(( y + x ))
            lno=$(grep -Fn "sed -i '/$pattern/d" "$2" | cut -d: -f1)
            sed -i "${lno}s/,[0-9]\+\$/,$b/" $2
        fi
    else
        line=$(grep -F "sed -i '/$pattern/d" "$fl" | grep -v '^[[:space:]]*#')
        if [ "$line" != "" ]; then
            echo "\"$line\",$x" >> $2
        fi
    fi
done < $lt
unset IFS
rm $lt
}
generatekey() {
        read -sp "Enter passphrase for new GPG key: " p
        echo
cat > /tmp/keyparams.conf <<EOF
%echo Generating a GPG key
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
Name-Real: John Doe
Name-Email: $email
Expire-Date: 0
Passphrase: $p
%commit
%echo done
EOF
    gpg --batch --pinentry-mode loopback  --passphrase "$p" --generate-key /tmp/keyparams.conf
    shred -u /tmp/keyparams.conf
    echo "GPG key generated for ${email}."
}
storeenc() {
local c
    if [ "$STATPST" == "true" ]; then
		if ! gpg --list-keys | grep -q $email; then
			generatekey
		fi
        if grep -m 1 -q '^Modified,' $1; then msg=" stats"; else msg=" log"; fi
        if [ -s "$2" ]; then
			if [ "$3" != "dcr" ]; then
				if ! decrypt $xdata $2; then
		            echo "Failed to decrypt  $2$msg"
		            echo "decrypt $2$msg failed"
		            return 1
		        fi
				source=$xdata
			else
				source=$xdata2
			fi
            if [ "$msg" == " stats" ]; then
				declare -A ref_map
				while IFS= read -r line || [ -n "$line" ]; do
					key=${line#*,*,*,}
					[[ -n "$key" ]] && ref_map["$key"]="$line"
				done < $source
                while IFS="" read -r p || [ -n "$p" ]; do
                    ft=$(echo "$p" | cut -d',' -f1)
					dt=$(echo "$p" | cut -d',' -f2 | tr -d '"')
					if [ "$ft" == "Nosuchfile" ]; then #  | cut -d',' -f3- | sed 's/^ *//;s/ *$//') orig		
						filepath=$(echo "$p" | cut -d',' -f4)
						entry="Nosuchfile,$dt,,${filepath}"    # Action,dt,,file path
						if [[ ! -v ref_map["$filepath"] ]]; then
			                echo "$entry" >> $source
						else
							found="${ref_map["$filepath"]}"
							old_dt=$(echo "$found" | cut -d',' -f2 | tr -d '"')
							if [[ "$dt" > "$old_dt" ]]; then
								echo "$entry" >> $source
							fi
						fi
					else
						ct=$(echo "$p" | cut -d',' -f3 | tr -d '"')
						filepath=${p#*,*,*,}
						entry="$ft,\"${dt}\",${filepath}"
						if [[ ! -v ref_map["$filepath"] ]]; then
			                echo "$entry" >> $source
						else
						 	found="${ref_map["$filepath"]}"
							old_dt=$(echo "$found" | cut -d',' -f2 | tr -d '"')
							old_ct=$(echo "$found" | cut -d',' -f3 | tr -d '"')
							if [[ "$dt" > "$old_dt" ]] || [[ "$ct" > "$old_ct" ]]; then
								echo "$entry" >> $source
							fi
						fi
					fi
                done < $1
		    else # its a log
		        c=$( grep -c '^$' $source)
		        if  (( c == logCT )); then
		            sed -i '1,/^$/d' $source
		        fi
				while IFS= read -r p || [[ -n "$p" ]]; do
					cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p")
					y=$cFILE
					current_ln="${p//\"$y\"/}" ; current_ln="$( echo "$current_ln" | xargs  -d '\n')"
					read -r f1 f2 f3 f4 <<< "$current_ln"
					dt="$f1 $f2"
					ct="$f3 $f4"
					r=$( grep -F "$dt \"$y\" $ct" $source)
					[[ -z "$r" ]] &&  echo "$p" >> $source
				done < $1
				unset IFS
		        echo >> $source # end of log
		    fi
            cmmd=(gpg --yes -e -r $email -o $2 $source)
			if [ "$nc" == "true" ]; then cmmd=(gpg --yes --compress-level 0 -e -r $email -o $2 $source); fi
			if ! "${cmmd[@]}"; then
				echo "Encryption failed for file: $source  . $2$msg "
				return 1
			fi
            rm $source
            if [ "$msg" == " log" ]; then echo $c; fi
        else
            echo >> $1
            if ! gpg --yes -e -r $email -o $2 "$1"; then
                echo "Encryption failed for file: $1"
                return 1
            fi
            echo "The${msg} was created."
        fi
    fi
}
decrypt(){	if ! gpg --yes -d -o $1 $2; then return 1; fi; }
iscopy() {
while IFS= read -r p || [[ -n "$p" ]]; do
    cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p")
	y=$cFILE
	current_ln="${p//\"$y\"/}"
	current_ln="$( echo "$current_ln" | xargs  -d '\n')"
	read -r _ _ f3 f4 _ _ _ f8 _ <<< "$current_ln"
	cs="$f8"
	ct="$f3 $f4"
	copy_record=$(grep -F -v "\"$y\"" $1 | awk -F'"' '{print $1 $3}' | tail -n 1)
	if [[ -n "$copy_record" ]]; then
		original_ln="$( echo "$copy_record" | xargs -d '\n')"
		read -r _ _ of3 of4 _ <<< "$original_ln"
		oct="$of3 $of4"
		if date -d "$ct" "+$fmt" >/dev/null 2>&1 && date -d "$oct" "+$fmt" >/dev/null 2>&1; then
			echo "Copy $dt $ct $y" >> $rout
			echo "Copy $dt $y" >> $tfile
		fi
	fi
done < $TMPCOMPLETE
}
hanly(){
	local csm=""
	declare -a collisions=()
	>$tfile 			; y=8
	if [ "$mMODE" == "mc" ]; then
		cores=$( nproc 2>/dev/null || echo 1)
		max_jobs=$cores
		if (( max_jobs > 16 )); then max_jobs=16; fi
		x=$(wc -l < "$SORTCOMPLETE")
		if (( x > 100 )); then y=20; fi
		split -l $y --numeric-suffixes=1 --suffix-length=4 "$SORTCOMPLETE" "$atmp/sortchunk_"
		find "$atmp" -type f -name 'sortchunk_*' -print0 | sort -z | xargs -0 -P"$max_jobs" -I{} /usr/local/save-changesnew/haloop $atmp "{}" $2 $checkSUM $cdiag $TMPCOMPLETE
		if compgen -G "$atmp"/haloop1_*_tmp.log > /dev/null; then cat "$atmp"/haloop1_*_tmp.log >> $rout; fi
		if compgen -G "$atmp"/haloop2_*_tmp.log > /dev/null; then cat "$atmp"/haloop2_*_tmp.log >> $tfile; fi
	else
		# mapfile -t ref_lines < "$2"
		declare -A ref_map                    
        # #  tmp="${p#\"}" ; key="${tmp%%\"*}"   # cFILE= # $(perl -nE 'say $1 if /"((?:[^"\\]|\\.)*)"/' <<< "$p")
		while read -r p; do key=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p") ; current_ln="${p//\"$key\"/}" ; current_ln="$(echo "$current_ln" | xargs  -d '\n')" ; ref_map["$key"]="$current_ln" ; done < $2
		hablk "A"
	fi
	
	test -s $TMPCOMPLETE && iscopy $2
	rm $2
    processha "$@"
}
collision() {
local f=7 
local label="$1"
local chksum="$2"
local filesize="$3"
local type=$4
local arr
if [ "$checkSUM" == "false" ]; then fld=3 ; fi
while IFS= read -r line; do
	os=""
	cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$line")
	rest=$(awk -F'"' '{print $3}' <<< "$line")
	read -r _ _ _ _ _ record_c os <<< "$rest"
    if [[ "$cFILE" != "$label" && "$record_c" != "None" && "$os" != "None" ]]; then
        if [[ "$chksum" == "$record_c" && "$filesize" != "$os" ]]; then 
			if [ "$os" -ge 0 ] 2>/dev/null; then
				collisions+=("COLLISION: $label vs $cFILE | Checksum: ${chksum} && ${record_c} | Sizes: $filesize != $os") ; csm="true"
			fi
		fi
    fi
done < <(grep -F "$chksum" "$ofile")
}
stealth() {
local file="$1"				;	local label="$2"		
local cksum="$3"			;   local current_size="$4"
local original_size="$5"	;   local lcl="$6"		
local delta						;	local abs_delta 					
if [ -f "$file" ] && [ -n "$current_size" ] && [ "$current_size" != "None" ] && [ -n "$original_size" ]; then
	if [ "$label" != "/usr/local/save-changesnew/flth.csv" ]; then
		delta=$(( current_size - original_size ))
		abs_delta=${delta#-}
		if [ "$original_size" == "$current_size" ] && [ "$lcl" != "eql" ]; then
			echo "Warning file ${label} same filesize different checksum. Contents changed." >> /tmp/cerr ; csm="true"
		elif [ "$abs_delta" -le 12  ] && [ "$abs_delta" -ne 0 ]; then
			msg="Checksum indicates a change in ${label}. Size changed slightly — possible stealth edit."
			if [ "$cdiag" == "true" ]; then
				 echo "$msg ($original_size → $current_size)." >> /tmp/scr
			else
				 echo "$msg" >> /tmp/scr 
			fi
		fi
	fi
	if [ "$cdiag" == "true" ]  && [ "$lcl" != "eql" ]; then collision "$label" $cksum $current_size $7 ; fi
fi
}
is_valid_date() { date -d "$1" >/dev/null 2>&1 ; c=$?; return $c ; }
hablk() {
>$TMPCOMPLETE
while IFS= read -r p || [[ -n "$p" ]]; do
    df="false"
	found_line=""
    #cFILE=$(perl -nE 'say $1 if /"((?:[^"\\]|\\.)*)"/' <<< "$p") orig
    cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p")
	y=$cFILE
	current_ln="${p//\"$y\"/}"
	current_ln="$( echo "$current_ln" | xargs  -d '\n')"
	read -r f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 _ <<< "$current_ln"
	in="$f5"
	if [ -n "$in" ] && [ "$in" -ge 0 ] 2>/dev/null; then 	# for line in "${ref_lines[@]}"; do if [[ "$line" == *"$y"* ]]; then found_line="$line" ; fi ; done regular array old multicore
		if [ "$1" == "A" ]; then found_line="${ref_map[$y]}" ; else found_line=$( grep -F "$y" "$ofile" | tail -n 1) ; fi  # 
		if [ -n "$found_line" ]; then
			original_ln="$found_line"
			if [ "$1" != "A" ]; then original_ln="${found_line//\"$y\"/}" ; original_ln="$( echo "$original_ln" | xargs -d '\n')" ; fi
			read -r of1 of2 of3 of4 of5 of6 of7 of8 of9 of10 of11 of12 of13 _ <<< "$original_ln"
			cFILE="$( unescf "$cFILE")"
			oin="$of5"
			if [ -n "$oin" ] && [ "$oin" -ge 0 ] 2>/dev/null; then
				dt="$f1 $f2" ; omt="$of1 $of2"
				if [ "$dt" == "$omt" ]; then
					if [ "$checkSUM" == "true" ]; then
						oct="$of3 $of4" ; oat="$of6 $o7" ; ocs="$of8" ; os="$of9"
						ct="$f3 $f4" ; cat="$f6 $7" ; cs="$f8" ; csze="$f9" 
						is_valid_date "$cat" && is_valid_date "$oat" && [[ "$cs" != "None" ]] && [[ "$ocs" != "None" ]] || continue
						if [ -f "$cFILE" ]; then                     		
							a_checksum=$(md5sum "$cFILE" 2> /dev/null | awk '{print $1}')
                            read a_mod fs a_ct au ag apmr < <(stat --format="%Y %s %Z %U %g %A" "$cFILE" 2>/dev/null)
							afrm=$(date -d "@$a_mod" +"$fmt" 2>/dev/null)
							if [ -n "$afrm" ] && [ -n "$a_checksum" ]; then
								if [ "$a_checksum" != "$cs" ]; then
									if [ "$afrm" == "$dt" ]; then
										m="Suspect $dt"
										echo "$m $y" >> $tfile
										echo "$m $ct $y" >> $rout
                                        echo "Suspect file: $y changed without a new modified time." >> /tmp/cerr
                                        df="true" ; csm="true"
									else
										if [ "$cdiag" == "true" ]; then 
	                                        m="File changed during the search."
											echo "$m $y at ${afrm}. Size was $os, now $fs." >> /tmp/scr
	                                    else
											echo "$m $y. File likely changed. system cache item." >> /tmp/scr
	                                    fi
	                                    stealth "$cFILE" "$y" $cs $fs $csze "regular" $1
	                                    df="true"
									fi
								fi
                                if [ "$df" == "false" ]; then
									if (( oin == in )); then
										old_meta="$of11 $of12 $of13" #owner grp perm
	                               		# cur_meta="$f11 $f12 $f13"
										cur_meta="$au $ag $apmr" # ln 448   free
										if [ "$old_meta" != "$cur_meta" ]; then
											m="Metadata $dt"
                                        	echo "$m $y" >> $tfile
											echo "$m $ct $y" >> $rout
										fi
									fi
									df="true"
								fi
							fi
						fi
					fi            
				else
					df="true"
					if [ "$checkSUM" == "true" ]; then
						if (( oin != in )); then
							if [ "$ocs" == "$cs" ]; then
								m="Overwrite $dt"
								echo "$m $y" >> $tfile
								echo "$m $ct $y" >> $rout
								stealth "$cFILE" "$y" $cs $csze $os "eql" $1
							else
								m="Replaced $dt"
								echo "$m $y" >> $tfile
								echo "$m $ct $y" >> $rout
								stealth "$cFILE" "$y" $cs $csze $os "regular" $1
							fi
						else
							if [ "$ocs" != "$cs" ]; then
								m="Modified $dt"
								echo "$m $y" >> $tfile
								echo "$m $ct $y" >> $rout
								stealth "$cFILE" "$y" $cs $csze $os "regular" $1
							else
								m="Touched $dt"
								echo "$m $y" >> $tfile
								echo "$m $ct $y" >> $rout
							fi
						fi
					else
						if (( oin != in )); then
							m="Replaced $dt"
							echo "$m $y" >> $tfile
							echo "$m $dt $y" >> $rout
						else
							m="Modified $dt"
							echo "$m $y" >> $tfile
							echo "$m $dt $y" >> $rout
						fi
					fi
				fi
				if [[ "$df" == "false" ]]; then
					echo "$p" >> $TMPCOMPLETE
				fi
			fi
		else
			echo "$p" >> $TMPCOMPLETE  # is copy?
		fi
	fi
done < $SORTCOMPLETE
if [ "$csm" == "true" ]; then 
	if (( ${#collisions[@]} > 0 )); then for entry in "${collisions[@]}"; do echo "$entry"  >> /tmp/cerr ; done ; fi
fi
}
filteroutput() {
local filtername="$2"
local critical="$3"
local pricolor="$4"
local seccolor="$5"
local col="COLLISION"
local type="$6"
local flg="false"
sbwr
while IFS= read -r file; do 
	ck=""
	if [[ "$file" == "$filtername"* ]]; then
        if [ "$supbrwr" == "true" ]; then
		    for item in "${webb[@]}"; do if [[ "$file" =~ $item ]]; then ck="true" ; break ; fi ; done
        fi
	 	[[ -z "$ck" && "$supress" == "false" && "$flg" == "false" ]] && $pricolor "$file $6"
	else
		[[ "$critical" != "no" ]] && if [[ "$file" == "$critical"* ]] || [[ "$file" == "$col"* ]]; then $seccolor "$file $6 Critical" ; flg="true" ; fi
		[[ "$critical" == "no" ]] && $seccolor "$file $6"
	fi
done < $1
}
processha() {
local invr="$3" ; [[ -z "$invr" ]] && invr="$1"
if [ -s $rout ]; then
    if [ -s $tfile ]; then
        { echo ; echo "Hybrid analysis" ; echo ; } >> "$difffile"
		sort -o $tfile $tfile
		if [ -s $ABSENT ]; then sort -o $ABSENT $ABSENT; comm -23 $tfile $ABSENT > $TMPCOMPLETE ; else sort -k2,2 -k3,3 -o $TMPCOMPLETE $tfile ; fi
		if [ "$flsrh" == "true" ] || [ "$invr" == "filtered" ]; then
			if ! { [ "$flsrh" == "true" ] && [ "$invr" == "filtered" ]; } ; then /usr/local/save-changesnew/filter $TMPCOMPLETE $USR ; fi
		fi
		if [ "$flsrh" == "true" ]; then
			cDATE=$( head -n1 $TMPOPT | awk '{print $1 " " $2}')
			awk -v tme="$cDATE" '$0 >= tme' "$TMPCOMPLETE" > $TMPOUTPUT
			cp $TMPOUTPUT $TMPCOMPLETE
		fi

		#awk '{printf "%-10s\t %-19s %-60s\n", $1, $2" "$3, $4}' $TMPCOMPLETE >> "$difffile"
		awk '{printf "%-9s\t%-19s %s\n", $1, $2" "$3, substr($0, index($0,$4))}' "$TMPCOMPLETE" >> "$difffile"
		get_colors
   		if [ -s "/tmp/cerr" ]; then 
            if [ "$supbrwr" == "true" ]; then
                sbwr
                grep "Suspect\|COLLISION" /tmp/cerr > $TMPCOMPLETE
                for item in "${webb[@]}"; do sed -i "\|$item|d" /tmp/cerr ; done
                [[ -s $TMPCOMPLETE ]] && cat $TMPCOMPLETE >> /tmp/cerr
                sort -u -o /tmp/cerr /tmp/cerr 
            fi
			filteroutput "/tmp/cerr" "Warning" "Suspect" "yellow" "red" "elevated"
			if [[ -z "$csum" ]]; then csum="true" ; fi
		fi
		if [ -n "$cores" ] && [ "$csum" == "" ]; then echo "Detected $cores CPU cores."; fi
    fi
fi
}
cblk() {
local y="$(escf "$x")"
local sl=""
if [ -e "$x" ] && [ -f "$x" ]; then
	stat_output=$(stat -c "%Y %X %Z %i %U %g %A" "$x")
	read -r mtime atime itime i onr gr pmr<<< "$stat_output"
	ct=$(date -d "@$itime" +"%Y-%m-%d %H:%M:%S")
	at=$(date -d "@$atime" +"%Y-%m-%d %H:%M:%S")
	if [ -n "$ct" ]; then
		if (( itime > mtime )); then
			if [ "$checkSUM" == "true" ]; then
				[[ -L "$x" ]] && sl="y"
		 		wnr=${onr:-None} ; grp=${gr:-None} ; pmn=${pmr:-None} ; sl=${sl:-None}
				cam="y"
				csum=$(md5sum "$x" 2> /dev/null) ; csum=${csum%% *} ; csum=${csum:-None} 
				
				fs=$(stat --format=%s "$x" 2> /dev/null) ; fs=${fs:-None}
				adtcmd="$csum $fs $sl $wnr $grp $pmn $cam"
			else
				adtcmd=""
			fi

			if [ -n "$ct" ] && [ -n "$at" ]; then
				ct="${ct:-None None}"
				at="${at:-None None}"
				output="$ct \"$y\" $ct $i $at $adtcmd"
				if [ -z "$1" ]; then
					printf '%s\n' "$output" >> "$tout"
				else
					xfile+=("$output")
				fi
			fi
		fi
	fi
else
	if [ -z "$1" ]; then
		printf 'NOTA-FI-LE 77:77:77 "%s"\n' "$y" >> "$tout"
		mt=$(date -d "@$mtime" +"%Y-%m-%d %H:%M:%S")
		printf "%s,%s,,%s\n" "Nosuchfile" "$mt" "$y" >> "$COMPLETE"
	else
		nsf+=("Nosuchfile,$mt,,$y")
	fi
fi
}
sblk() {
local y="$(escf "$x")"
local sl=""
if [ -e "$x" ] && [ -f "$x" ]; then
   	stat_out=$(stat -c "%Y %X %i %U %g %A %Z " "$x")
	read -r f atime i onr gr pmr itime <<<"$stat_out"
	mt=$(date -d "@$f" +"%Y-%m-%d %H:%M:%S")
	ct=$(date -d "@$itime" +"%Y-%m-%d %H:%M:%S")
	ats=$(date -d "@$atime" +"%Y-%m-%d %H:%M:%S")
	if [ -n "$mt" ]; then
		if [ "$checkSUM" == "true" ]; then
			[[ -L "$x" ]] && sl="y"
			wnr=${onr:-None} ; grp=${gr:-None} ; pmn=${pmr:-None}  ; sl=${sl:-None}
			cam="None"
			csum=$(md5sum "$x" 2> /dev/null) ; csum=${csum%% *} ; csum=${csum:-None}
			fs=$(stat --format=%s "$x" 2> /dev/null) ; fs=${fs:-None} 
			adtcmd="$csum $fs $sl $wnr $grp $pmn $cam"
	    else
	        adtcmd=""
	    fi
		ct=${ct:-None None}
		ats=${ats:-None None}
		output="$mt \"$y\" $ct $i $ats $adtcmd"
		if [ -z "$1" ]; then
			printf '%s\n' "$output" >> "$SORTCOMPLETE"
		elif [ "$1" == "arry" ]; then
			ffile+=("$output")
		fi
	fi
else
	if [ -z "$1" ]; then
		printf 'NOTA-FI-LE 77:77:77 "%s"\n' "$y" >> $SORTCOMPLETE
		printf "%s,%s,,%s\n" "Nosuchfile" "$mt" "$y" >> $COMPLETE
	else
		nsf+=("Nosuchfile,$mt,,$y")
	fi
fi
}
searcharr() { if [ "$2" == "ctime" ]; then while IFS= read -r -d '' x; do  cblk "arry" "$2"; done < $1 ; else while IFS= read -r -d '' x; do sblk "arry"; done < $1 ; fi ; }
suffix() {
    suffixes=(
        "xSystemDiffFromLastSearch"
        "xFltDiffFromLastSearch"
        "xFltchanges"
        "xFltTmp"
        "xSystemchanges"
        "xSystemTmp"
        "xNewerThan"
        "xDiffFromLast"
    )
}
inclusions() {
local c=$SORTCOMPLETE
#sed -i '/\/tmp/\/rnt/d' $2
sed -i '/\/usr\/local\/save-changesnew\/flth\.csv/d' $c
sed -i '/\/home\/'"${USR}"'\/\Downloads\/rnt/d' $c
for var in logpst statpst pydbpst; do gp="${!var}" ; sed -i "\|$gp|d" $c ; done
}
clearlogs() {
suffix
for suffix in "${suffixes[@]}"; do rm -f "${MODULENAME/#\//}$suffix"* 2>/dev/null ; done
}
hsearch() {
r=$(find . -type f -path "*${MODULENAME}_MDY*/*" | wc -l)
if (( r >= 1 )); then
	for folder in $(ls -d /tmp"${MODULENAME}"_MDY* | sort -r); do # most recent folder
		for file in $folder$MODULENAME"xSystemchanges${argone}"*; do
		    test -f $file && { OLDSORTED=$file ; nodiff="true"; break; }
		done
		[[ -n "$OLDSORTED" ]] && break
	done
fi
}

escf() {
local o="$1"
o="${o//\\/\\\\}" ; o="${o//$'\n'/\\n}"; o="${o//\"/\\\"}" ; o="${o//$/\\\$}"
printf '%s' "$o"
}
unescf() {
local k="$1"
k="${k//\\n/$'\n'}" ; k="${k//\\\"/\"}" ; k="${k//\\\$/\$}" ; k="${k//\\\\/\\}" 
printf '%s' "$k"
}
backend() {
ofile=$atmp/tmpinfo ; tfile=$atmp/tmpd
if [ -d /tmp/rc ] && [ "$ANALYTICS" == "true" ] && [ "$STATPST" == "false" ]; then
    for file in /tmp/rc/*; do
        cat $file >> $ofile  2> /dev/null
    done
    if [ -s $ofile ]; then
        sort -u -o $ofile $ofile
		hanly $SORTCOMPLETE $ofile $5
		ret=$?
		if [ "$ret" -gt 0 ]; then
			echo "failure in ANALYTICS hanly subprocess"
		fi
    fi
fi
if [ "$STATPST" == "true" ]; then
	if [ "$ANALYTICS" == "false" ]; then
		if [ "$backend" == "default" ]; then
			if [ -s $logpst ]; then
				if decrypt $xdata2 $logpst; then
					awk 'NF' $xdata2 > $ofile
					 if [ -s $ofile ]; then
						sort -u -o $ofile $ofile
						hanly $SORTCOMPLETE $ofile $5
						ret=$?
						if [ "$ret" -ne 0 ]; then
							echo "failure in STATPST hanyl subprocess"
						fi
					fi
					pstc="true"
				else
					echo "Failed to decrypt log file in hanly for STATPST. log file ${logpst}"
				fi
			else
				pstc="true"
			fi
			if [ "$pstc" == "true" ]; then
				imsg="$(storeenc $SORTCOMPLETE $logpst "dcr")"
				ret=$?
				if [ "$ret" -ne 0 ]; then
					echo "$imsg"
				else
					if [ "$imsg" -ge 0 ] 2>/dev/null; then
						if (( imsg % 10 == 0 )); then  cyan "$imsg searches in gpg log"; fi
					elif [ "$imsg" != "" ]; then
						green "Persistent search log file created."
					fi
				fi
				if [ -s $rout ]; then
					sort -u -o $rout $rout
					sed -i -E '/^Deleted/ s/^([^ ]+) ([^ ]+ [^ ]+) (.+)$/\1,"\2","\2",\3/' "$rout" # input action date time file name -->  action,"date time", "date time", file name
					sed -i -E '/^Deleted/! s/^([^ ]+) ([^ ]+ [^ ]+) ([^ ]+ [^ ]+) (.+)$/\1,"\2","\3",\4/' $rout  # input Action,"date time","date time", file name spaces   
					#sed -i -E 's/^([^ ]+) ([^ ]+ [^ ]+) (.+)$/\1,"\2",\3/' $rout         # last
					#sed -i -E 's/^([^ ]+) ([^ ]+ [^ ]+) ([^ ]+ [^ ]+) (.+)$/\1,"\2","\3",\4/' "$rout"         #orig
					if [ -s $COMPLETE ]; then cat $COMPLETE >> $rout; fi
					if [ "$pstc" == "true" ]; then
						imsg="$(storeenc $rout $statpst)"
						ret=$?
						if [ "$ret" -ne 0 ]; then
							echo "$imsg"
						else
							if [ "$imsg" != "" ]; then green "Persistent stats file created."; imsg=""; fi
						fi
					fi
				fi
			fi
		else
	        if ! gpg --list-keys | grep -q $email; then generatekey ; fi	
			python3 /usr/local/save-changesnew/pstsrg.py $SORTCOMPLETE $pydbpst $rout $tfile $checkSUM $cdiag $email $mMODE $ANALYTICSECT $proteusSHIELD $nc
			ret=$?
			if [ "$ret" -ne 0 ]; then
				if [ "$ret" -eq 2 ] || [ "$ret" -eq 3 ]; then
					echo "Problem with GPG refer to instructions on setting up pinentry ect. Database preserved."
				elif [ "$ret" -eq 4 ]; then
					echo "Problem with database in psysrg.py"
				else
					echo "Pstsrg.py failed. exitcode ${ret}"
				fi
			fi
			processha $argf
		fi
	fi
fi
[[ -s "$difffile" ]] && [[ -n "$( tail -n 1 "$difffile")" ]] && [[ "$ANALYTICSECT" == "true" ]] && [[ "$backend" == "false" ]] && green "Hybrid analysis on"
if [[ "$csum" != "true" && -s $slog && "$supress" == "true" ]]; then
	{ echo; echo "cdiag"; echo ; cat $slog; } >> "$difffile"
elif [[ "$csum" != "true" && -s $slog && "$supress" == "false" ]]; then
	filteroutput $slog "Checksum" "no" "blue" "yellow" "Scr"
	{ echo; echo "cdiag"; echo ; cat $slog; } >> "$difffile" 
elif [[ "$csum" == "true" ]]; then
	{ echo; echo "cdiag alert"; echo ; cat /tmp/cerr ; } >> "$difffile"
	rm /tmp/cerr
fi
test -f $slog && rm $slog ; test -f $rout && rm $rout
}
ulink() {
#local fld=10
sbwr
green "Updating hardlinks"
#if [ "$checkSUM" == "false" ]; then fld=3 ; fi
while IFS= read -r p || [[ -n "$p" ]]; do 
    ck="false"
	#cFILE=$(perl -nE 'say $1 if /"((?:[^"\\]|\\.)*)"/' <<< "$p")
    cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p")
	y=$cFILE
	#inode=$(echo "$p" | rev | cut -d ' ' -f"$fld" | rev) 
	cln="${p//\"$y\"/}"
	read -r _ _ _ _ of5 _ <<< "$cln"
	inode="$of5"
    if [ "$supbrwr" == "true" ]; then
        for item in "${webb[@]}"; do if [[ "$y" =~ "$item" ]]; then [ -n "$item" ] && echo "None" && ck="true"; break ; fi ; done
    fi
	if [ "$inode" == "None" ] && [ "$ck" == "false" ]; then 
        echo "None" 
    elif [ "$ck" == "false" ]; then
         echo $inode
    fi
done < $1 > $TMPOPT
mapfile -t inodes_array < "$TMPOPT" ; declare -A inode_map
while read -r inode; do inode_map["$inode"]=$((inode_map["$inode"] + 1)) ; done < <(find /bin /etc /home /lib /lib64 /opt /root /sbin /usr /var -xdev -printf '%i\n' 2>/dev/null)
for inode in "${inodes_array[@]}"; do
    if [ "$inode" = "None" ]; then
        echo "None"
    else
        count=${inode_map["$inode"]}
        if [ -z "$count" ] || [ "$count" -eq 0 ] || [ "$count" -eq 1 ]; then
            echo "None"
        else
            echo "$count"
        fi
    fi
done > $TMPOPT
paste -d' ' $1 $TMPOPT > $2 ; mv $2 $SORTCOMPLETE
}
ctimeloop() {
if [ "$checkSUM" == "true" ]; then cyan "Running checksum."; fi
if [ "$ANALYTICSECT" == "true" ]; then end=$(date +%s.%N) ; if [ "$checkSUM" == "true" ]; then cstart=$(date +%s.%N) ; fi ; fi
while IFS= read -r -d '' f; do f="$( escf "$f")" ; echo "$f" ; done < $1 >> $2
while IFS= read -r -d '' f; do f="$( escf "$f")" ; echo "$f" ; done < $toutnul >> $tout
if [ "$FEEDBACK" == "true" ]; then cat $tout; cat $2; fi
if [ -s $tout ]; then grep -Fxv -f $2 $tout > $TMPCOMPLETE; >$tout; fi
>$tout
if [ -s $TMPCOMPLETE ]; then
	while IFS= read -r x; do x="$( unescf "$x")" ; printf '%s\0' "$x"; done < $TMPCOMPLETE > $xdata
	if [ "$mMODE" == "normal" ]; then
		xargs -0 /usr/local/save-changesnew/searchfiles $atmp $tout $COMPLETE $checkSUM < $xdata
	elif [ "$mMODE" == "mem" ]; then
		declare -a xfile ; declare -a ffile ; declare -a nsf
		searcharr $xdata "ctime"
	elif [ "$mMODE" == "mc" ]; then
		x=$(tr -cd '\0' < $xdata | wc -c) ; y=8
		if (( x > 100 )); then y=16 ; fi
		xargs -0 -n"$y" -P4 /usr/local/save-changesnew/searchfiles "$atmp" "$checkSUM" < $xdata
		if compgen -G "$atmp"/searchfiles1_*_tmp.log > /dev/null; then cat "$atmp"/searchfiles1_*_tmp.log > $tout; fi
		if compgen -G "$atmp"/searchfiles2_*_tmp.log > /dev/null; then cat "$atmp"/searchfiles2_*_tmp.log > $COMPLETE; fi
	else
		echo incorrect mMODE && exit
	fi
	rm $xdata
fi
}
intst() {
if [ "$ANALYTICSECT" == "true" ]; then start=$(date +%s.%N); fi
if [ "$STATPST" == "true" ]; then
    if [ -f $logpst ]; then
        sz=$( stat -c %s "$logpst")
        if [ $(( sz / 1048576 )) -gt $logSIZE ]; then
            if [ "$logPRF" == "del" ]; then
               : > $logpst
            elif [ "$logPRF" == "stop" ]; then
                cyan "persist log saving stopped on size limit"
            fi
            STATPST="false"
            if [ "$logPRF" == "rfh" ]; then
                rm $logpst
                STATPST="true"
            fi
		elif [ $(( sz / 1048576 )) -ge $compLVL ]; then
			nc="true"
        elif [ $sz -eq 0 ]; then
            cyan "$logpst is 0 bytes. to resume persistent logging delete file"
            STATPST="false"
        fi
    fi
fi
}
