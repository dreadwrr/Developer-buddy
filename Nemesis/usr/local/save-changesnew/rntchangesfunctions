#!/bin/bash
#   Developer buddy 3.0 core                                               9/12/2025
# Filter terminal and hardlinks
sbwr() {
webb=(
    'mozilla'
	'.mozilla'
	'chromium-ungoogled'
    "$LCLMODULENAME"
# other
)
}
get_colors(){
txtyellow=${txtbld}$(tput setaf 3)
txtblue=${txtbld}$(tput setaf 4)
function yellow() { echo -e $txtyellow "$1" $rst; }
function blue(){ echo $txtblue "$1" $rst; }
}
postop() {
if [ "$POSTOP" == "true" ]; then
	while IFS= read -r x; do x="$(unescf "$x")" ; printf '%s\0' "$x"; done < $1 >> $xdata
    if [ -f $USRDIR/doctrine.tsv ]; then
        sed -i 's/^export POSTOP="true"/export POSTOP="false"/' $2
    else
        echo -e "Datetime\tFile\tSize(kb)\tType\tModified\tAccessed\tOwner" > $atmp/doctrine
        while IFS= read -r -d '' x; do
            f="$(cut -d' ' -f3- <<< "$x")"
            dt=$(cut -d' ' -f1-2 <<< "$x")
            if [ -e "$f" ] && [ -f "$f" ]; then
                onr=$( stat -c "%U" "$f")
                mtyp=$( file --brief --mime-type "$f")
                if [ "$mtyp" == "application/octet-stream" ]; then mtyp="Unknown"; fi
                if [ -L "$f" ]; then mtyp="Symlink"; fi
                sz=$( stat -c %s "$f")
                md=$( stat -c '%Y' "$f") ; x=$(date -d "@$md" +'%Y-%m-%d %H:%M:%S')
                ae=$( stat -c '%X' "$f") ; y=$(date -d "@$ae" +'%Y-%m-%d %H:%M:%S')
                echo -e "$dt\t$f\t$(( sz / 1024 ))\t$mtyp\t$x\t$y\t$onr" >> $atmp/doctrine
            fi
        done < $xdata
        unset IFS
        head -1 $atmp/doctrine > $USRDIR/doctrine.tsv
        tail -n +2 $atmp/doctrine | sort -t$'\t' -k7,7 -k3,3n >> $USRDIR/doctrine.tsv
        green "File doctrine.tsv created in $USRDIR"
    fi
fi
}
stmp() {
sf=$MODULENAME"_"$FLBRAND
if (( tmpSRHS > 0 )); then
    test -d /tmp/rc || mkdir /tmp/rc
	r=$(find /tmp/rc -maxdepth 1 -type f -name '*rntfiles_MDY*' 2>/dev/null | wc -l)
    if [ "$r" -eq "$tmpSRHS" ]; then
        test -f /tmp/rc/full || { touch /tmp/rc/full ; cyan "searches builtup in /tmp/rc"; }
        for file in "/tmp/rc"$MODULENAME"_MDY"*
        do
            rm -f $file
            break
        done
    fi
	awk 'NF' $1 > $TMPCOMPLETE; mv $TMPCOMPLETE $1
    cp $1 "/tmp/rc"$sf
fi
}
filterhits() {
local lt=$atmp/patterns.txt
local fl=/usr/local/save-changesnew/filter
test -f $2 || echo "Entry,Hits" >> $2
sed -n '/^[[:space:]]*#/!s|sed -i '\''/\(.*\)/d'\''.*|\1|p' "$fl" > $lt
while IFS= read -r pattern; do
    k=$( echo "$pattern" | sed -e 's/\\//g' -e "s|'\"\${2}\"'|$USR|g")
    x=$( grep -Fc -- "$k" $1)
    if grep -Fq "sed -i '/$pattern/d" $2; then
        if (( x > 0 )); then
            y=$( grep -F "sed -i '/$pattern/d" $2 | cut -d',' -f2)
            b=$(( y + x ))
            lno=$(grep -Fn "sed -i '/$pattern/d" "$2" | cut -d: -f1)
            sed -i "${lno}s/,[0-9]\+\$/,$b/" $2
        fi
    else
        line=$(grep -F "sed -i '/$pattern/d" "$fl" | grep -v '^[[:space:]]*#')
        if [ "$line" != "" ]; then
            echo "\"$line\",$x" >> $2
        fi
    fi
done < $lt
unset IFS
rm $lt
}
generatekey() {
        read -sp "Enter passphrase for new GPG key: " p
        echo
cat > /tmp/keyparams.conf <<EOF
%echo Generating a GPG key
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
Name-Real: John Doe
Name-Email: $email
Expire-Date: 0
Passphrase: $p
%commit
%echo done
EOF
    gpg --batch --pinentry-mode loopback  --passphrase "$p" --generate-key /tmp/keyparams.conf
    shred -u /tmp/keyparams.conf
    echo "GPG key generated for ${email}."
}
storeenc() {
local c
    if [ "$STATPST" == "true" ]; then
		if ! gpg --list-keys | grep -q $email; then
			generatekey
		fi
        if grep -m 1 -q '^Modified,' $1; then msg=" stats"; else msg=" log"; fi
        if [ -s "$2" ]; then
			if [ "$3" != "dcr" ]; then
				if ! decrypt $xdata $2; then
		            echo "Failed to decrypt  $2$msg"
		            echo "decrypt $2$msg failed"
		            return 1
		        fi
				source=$xdata
			else
				source=$xdata2
			fi
			if [ "$msg" == " stats" ]; then
				declare -A ref_map
				while IFS= read -r line || [ -n "$line" ]; do
					key=${line#*,*,*,}
					[[ -n "$key" ]] && ref_map["$key"]="$line"
				done < $source
		        while IFS="" read -r p || [ -n "$p" ]; do
		            ft=$(echo "$p" | cut -d',' -f1)
					dt=$(echo "$p" | cut -d',' -f2 | tr -d '"')
					if [ "$ft" == "Nosuchfile" ]; then #  sed 's/^ *//;s/ *$//')  remove leading trailing space
						echo "$p" >> $source
					else
						ct=$(echo "$p" | cut -d',' -f3 | tr -d '"')
						filepath=${p#*,*,*,} # format action,"date time","change time", file name 
						if [[ ! -v ref_map["$filepath"] ]]; then
				            echo "$p" >> $source
						else
						 	found="${ref_map["$filepath"]}"
							old_dt=$(echo "$found" | cut -d',' -f2 | tr -d '"')
							old_ct=$(echo "$found" | cut -d',' -f3 | tr -d '"')
							if [[ "$dt" > "$old_dt" ]] || [[ "$ct" > "$old_ct" ]]; then
								echo "$p" >> $source
							fi
						fi
					fi
		        done < $1
		    else # its a log
			    c=$( grep -c '^$' $source)
			    if  (( c == logCT )); then
			        sed -i '1,/^$/d' $source
			    fi
				while IFS= read -r p || [[ -n "$p" ]]; do
					cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p")
					y=$cFILE
					current_ln="${p//\"$y\"/}"
					read -r f1 f2 f3 f4 _ <<< "$current_ln"
					dt="$f1 $f2"
					ct="$f3 $f4"
					r=$( grep -F "$dt \"$y\" $ct" $source)
					[[ -z "$r" ]] &&  echo "$p" >> $source
				done < $1
				unset IFS
			    echo >> $source # end of log
		    fi
            cmmd=(gpg --yes -e -r $email -o $2 $source)
			if [ "$nc" == "true" ]; then cmmd=(gpg --yes --compress-level 0 -e -r $email -o $2 $source); fi
			if ! "${cmmd[@]}"; then
				echo "Encryption failed for file: $source  . $2$msg "
				return 1
			fi
            rm $source
            if [ "$msg" == " log" ]; then echo $c; fi
        else
            echo >> $1
            if ! gpg --yes -e -r $email -o $2 "$1"; then
                echo "Encryption failed for file: $1"
                return 1
            fi
            echo "The${msg} was created."
        fi
    fi
}
decrypt(){	if ! gpg --yes -d -o $1 $2; then return 1; fi; }
iscopy() {
while IFS= read -r p || [[ -n "$p" ]]; do
    cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p")
	y=$cFILE
	current_ln="${p//\"$y\"/}"
	read -r f1 f2 f3 f4 _ _ _ f8 _ <<< "$current_ln"
	dt="$f1 $f2" ; cs="$f8"
	ct="$f3 $f4"
	copy_record=$(grep -F -v "\"$y\"" $1 | tail -n 1)
	if [[ -n "$copy_record" ]]; then
		oct=$( awk '{ print $(NF-10), $(NF-9) }' <<< "$copy_record")
		if date -d "$ct" "+$fmt" >/dev/null 2>&1 && date -d "$oct" "+$fmt" >/dev/null 2>&1; then
			echo "Copy $dt $ct $y" | tee -a $rout >> $tfile
		fi
	fi
done < $TMPCOMPLETE
}
collision() {
local f=7 
local label="$1"
local chksum="$2"
local filesize="$3"
local type=$4
local arr
if [ "$checkSUM" == "false" ]; then fld=3 ; fi
while IFS= read -r line; do
	os=""
	cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$line")
	read record_c os < <(awk '{ print $(NF-6), $(NF-5) }' <<< "$line")
    if [[ "$cFILE" != "$label" && "$record_c" != "None" && "$os" != "None" ]]; then
        if [[ "$chksum" == "$record_c" && "$filesize" != "$os" ]]; then 
			if [ "$os" -ge 0 ] 2>/dev/null; then
				collisions+=("COLLISION: $label vs $cFILE | Checksum: ${chksum} && ${record_c} | Sizes: $filesize != $os") ; csm="true"
			fi
		fi
    fi
done < <(grep -F "$chksum" "$ofile")
}

is_valid_date() { date -d "$1" >/dev/null 2>&1 ; c=$?; return $c ; }
newmeta() {
current_own="$1"
current_grp="$2"
current_perm="$3"
prev_own="$4"
prev_grp="$5"
prev_perm="$6"
old_meta="$prev_own $prev_grp $prev_perm"
cur_meta="$current_own $current_grp $current_perm" #cur_meta="$au $ag $apmr" # ln 448   free
if [[ "$old_meta" == "$cur_meta" ]]; then
	return 1
fi
}
stealth() {
local file="$1"
local label="$2"		
local cksum="$3"
local current_size="$4"
local original_size="$5"	
local delta
local abs_delta 					
if [ -f "$file" ] && [ -n "$current_size" ] && [ "$current_size" != "None" ] && [ -n "$original_size" ]; then
	if [ "$label" != "/usr/local/save-changesnew/flth.csv" ]; then
		delta=$(( current_size - original_size ))
		abs_delta=${delta#-}
		if [ "$original_size" == "$current_size" ]; then
			echo "Warning file ${label} same filesize different checksum. Contents changed." >> $cerr
		elif [ "$abs_delta" -le 12  ] && [ "$abs_delta" -ne 0 ]; then
			msg="Checksum indicates a change in ${label}. Size changed slightly — possible stealth edit."
			if [ "$cdiag" == "true" ]; then
				 echo "$msg ($original_size → $current_size)." >> $slog
			else
				 echo "$msg" >> $scr
			fi
		fi
	fi
	if [ "$cdiag" == "true" ]; then collision "$label" $cksum $current_size $7 ; fi
fi
}
hablk() {
>$TMPCOMPLETE
while IFS= read -r p || [[ -n "$p" ]]; do
	found_line=""
	#cFILE=$(perl -nE 'say $1 if /"((?:[^"\\]|\\.)*)"/' <<< "$p") orig
    cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p") 
	y=$cFILE
	current_ln="${p//\"$y\"/}"
	read -r f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 _ <<< "$current_ln"
	in="$f5"
	if [ -n "$in" ] && [ "$in" -ge 0 ] 2>/dev/null; then 	
		if [ "$1" == "A" ]; then found_line="${ref_map[$y]}" ; else found_line=$( grep -F "$y" "$ofile" | tail -n 1) ; fi # for line in "${ref_lines[@]}"; do if [[ "$line" == *"$y"* ]]; then found_line="$line" ; fi ; done regular array old multicore
		if [ -n "$found_line" ]; then
			original_ln="$found_line"
			if [ "$1" != "A" ]; then original_ln="${found_line//\"$y\"/}" ; fi
			read -r of1 of2 of3 of4 of5 of6 of7 of8 of9 of10 of11 of12 of13 _ <<< "$original_ln"
			cFILE="$( unescf "$cFILE")"
			oat="$of6 $of7" ; cat="$f6 $f7" 
			is_valid_date "$oat" && is_valid_date "$cat" || continue 
			if [ "$checkSUM" == "true" ]; then ocs="$of8" ; cs="$f8" ; os="$of9" ; csze="$f9" ; [[ "$cs" != "None" ]] || continue ; fi
			oin="$of5"
			if [ -n "$oin" ] && [ "$oin" -ge 0 ] 2>/dev/null; then
				dt="$f1 $f2" ; omt="$of1 $of2" ; ct="$f3 $f4"
				if [ "$dt" == "$omt" ]; then
					if [ "$checkSUM" == "true" ]; then
						if [ -f "$cFILE" ]; then                     		
                            read a_mod fs a_ct au ag apmr < <(stat --format="%Y %s %Z %U %g %A" "$cFILE" 2>/dev/null)
							afrm=$(date -d "@$a_mod" +"$fmt" 2>/dev/null)
							if [ -n "$afrm" ]; then
								if [ "$afrm" == "$dt" ]; then
									a_checksum=$(md5sum "$cFILE" 2> /dev/null | awk '{print $1}')
									if  [ -n "$a_checksum" ] && [ "$a_checksum" != "$cs" ]; then
										echo "Suspect $dt $ct $y" >> $rout
                                        echo "Suspect file: $y changed without a new modified time." >> $cerr
                                        csm="true"
									fi
								else
									if [ "$cdiag" == "true" ]; then 
                                        m="File changed during the search."
										echo "$m $y at ${afrm}. Size was $os, now $fs." >> $slog
                                    else
										echo "$m $y. File likely changed. system cache item." >> $slog
                                    fi
                                    stealth "$cFILE" "$y" $cs $fs $csze
								fi
							fi
						fi
						if [[ "$cs" == "$ocs" ]]; then
							if (( oin == in )); then
								if newmeta $f11 $f12 $f13 $of11 $of12 $of13; then
									echo "Metadata $dt $ct $y" >> $rout
								fi
							else
								echo "Copy $dt $ct $y" >> $rout
							fi
						fi
					fi        
				else
					if [ "$checkSUM" == "true" ]; then
						if (( oin != in )); then
							if [ "$ocs" == "$cs" ]; then
								echo "Overwrite $dt $ct $y" >> $rout
							else
								echo "Replaced $dt $ct $y" >> $rout
								stealth "$cFILE" "$y" $cs $csze $os
							fi
						else
							if [ "$ocs" != "$cs" ]; then
								echo "Modified $dt $ct $y" >> $rout
								stealth "$cFILE" "$y" $cs $csze $os
							else
								if newmeta $f11 $f12 $f13 $of11 $of12 $of13; then
									echo "Metadata $dt $ct $y" >> $rout
								else
									echo "Touched $dt $ct $y" >> $rout
								fi
							fi
						fi
					else
						if (( oin != in )); then
							echo "Replaced $dt $ct $y" >> $rout
						else
							echo "Modified $dt $ct $y" >> $rout
						fi
					fi
				fi
			fi
		else
			echo "$p" >> $2  # is copy?
		fi
	fi
done < $SORTCOMPLETE
if [ "$csm" == "true" ]; then 
	if (( ${#collisions[@]} > 0 )); then for entry in "${collisions[@]}"; do echo "$entry"  >> $cerr ; done ; fi
fi
}
hanly(){
	local csm=""
	declare -a collisions=()
	>$tfile 			; y=8
	if [ "$mMODE" == "mc" ]; then
		cores=$( nproc 2>/dev/null || echo 1)
		max_jobs=$cores
		if (( max_jobs > 16 )); then max_jobs=16; fi
		x=$(wc -l < "$SORTCOMPLETE")
		if (( x > 100 )); then y=20; fi
		split -l $y --numeric-suffixes=1 --suffix-length=4 "$SORTCOMPLETE" "$atmp/sortchunk_"
		find "$atmp" -type f -name 'sortchunk_*' -print0 | sort -z | xargs -0 -P"$max_jobs" -I{} /usr/local/save-changesnew/haloop $atmp "{}" $2 $checkSUM $cdiag
		isoutput haloop1* haloop2* haloop3* haloop4* $rout $slog $cerr $TMPCOMPLETE
	else
		# mapfile -t ref_lines < "$2" old array
		 # tmp="${p#\"}" ; key="${tmp%%\"*}"   # key=$(perl -nE 'say $1 if /"((?:[^"\\]|\\.)*)"/' <<< "$p")
		declare -A ref_map                    
		while read -r p; do key=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p") ; current_ln="${p//\"$key\"/}" ; ref_map["$key"]="$current_ln" ; done < $2
		hablk "A" $TMPCOMPLETE
	fi
	
	test -s $TMPCOMPLETE && iscopy $2
	rm $2
    processha "$@"
}
filteroutput() {
local filtername="$2"
local critical="$3"
local pricolor="$4"
local seccolor="$5"
local col="COLLISION"
local type="$6"
local flg="false"
sbwr
while IFS= read -r file; do 
	ck=""
	if [[ "$file" == "$filtername"* ]]; then
        if [ "$supbrwr" == "true" ]; then
		    for item in "${webb[@]}"; do if [[ "$file" =~ $item ]]; then ck="true" ; break ; fi ; done
        fi
	 	[[ -z "$ck" && "$supress" == "false" && "$flg" == "false" ]] && $pricolor "$file $6"
	else
		[[ "$critical" != "no" ]] && if [[ "$file" == "$critical"* ]] || [[ "$file" == "$col"* ]]; then $seccolor "$file $6 Critical" ; flg="true" ; fi
		[[ "$critical" == "no" ]] && $seccolor "$file $6"
	fi
done < $1
}
processha() {
local invr="$3" ; [[ -z "$invr" ]] && invr="$1"
if [ -s $rout ]; then
	sed -E 's/^(([^[:space:]]+[[:space:]]+){3})([^[:space:]]+[[:space:]]+){2}(.*)/\1\4/' "$rout" | grep -v "^Deleted" > "$tfile"
    { echo ; echo "Hybrid analysis" ; echo ; } >> "$difffile"
	sort -o $tfile $tfile
	if [ -s $ABSENT ]; then sort -o $ABSENT $ABSENT; comm -23 $tfile $ABSENT > $TMPCOMPLETE ; else sort -k2,2 -k3,3 -o $TMPCOMPLETE $tfile ; fi
	if [ "$flsrh" == "true" ] || [ "$invr" == "filtered" ]; then
		if ! { [ "$flsrh" == "true" ] && [ "$invr" == "filtered" ]; } ; then /usr/local/save-changesnew/filter $TMPCOMPLETE $USR ; fi
	fi
	if [ "$flsrh" == "true" ]; then
		cDATE=$( head -n1 $TMPOPT | awk '{print $1 " " $2}')
		awk -v tme="$cDATE" '$0 >= tme' "$TMPCOMPLETE" > $TMPOUTPUT
		cp $TMPOUTPUT $TMPCOMPLETE
	fi
	awk '{printf "%-9s\t%-19s %s\n", $1, $2" "$3, substr($0, index($0,$4))}' "$TMPCOMPLETE" >> "$difffile"
	get_colors
	if [ -s "/tmp/cerr" ]; then 
        if [ "$supbrwr" == "true" ]; then
            sbwr
            grep "Suspect\|COLLISION" /tmp/cerr > $TMPCOMPLETE
            for item in "${webb[@]}"; do sed -i "\|$item|d" /tmp/cerr ; done
            [[ -s $TMPCOMPLETE ]] && cat $TMPCOMPLETE >> /tmp/cerr
            sort -u -o /tmp/cerr /tmp/cerr 
        fi
		filteroutput "/tmp/cerr" "Warning" "Suspect" "yellow" "red" "elevated"
		if [[ -z "$csum" ]]; then csum="true" ; fi
	fi
	if [ -n "$cores" ] && [ "$csm" == "" ]; then echo "Detected $cores CPU cores."; fi
fi
}
suffix() {
    suffixes=(
        "xSystemDiffFromLastSearch"
        "xFltDiffFromLastSearch"
        "xFltchanges"
        "xFltTmp"
        "xSystemchanges"
        "xSystemTmp"
        "xNewerThan"
        "xDiffFromLast"
    )
}
inclusions() {
local c=$SORTCOMPLETE
sed -i '/\/usr\/local\/save-changesnew\/flth\.csv/d' $c #sed -i '/\/tmp/\/rnt/d' $2
sed -i '/\/home\/'"${USR}"'\/\Downloads\/rnt/d' $c
for var in logpst statpst pydbpst; do gp="${!var}" ; sed -i "\|$gp|d" $c ; done
}
clearlogs() {
suffix
for suffix in "${suffixes[@]}"; do rm -f "${MODULENAME/#\//}$suffix"* 2>/dev/null ; done
}
logic() {
if [ "$syschg" == "false" ]; then  cyan "No sys files to report." ; fi
if [ "$samerlt" == "true" ] && [ "$syschg" == "true" ] && [ "$nodiff" == "true" ]; then cyan "The sys search was the same as before." ; fi
if [ "$diffrlt" == "false" ] && [ "$nodiff" == "true" ];then green " Nothing in the sys diff file. That is the results themselves are true" ; [[ -n "$1" ]] & cyan "$1" ; fi
}
display() {
local locale=$1
if [ "$dspEDITOR" != "false" ]; then
	[[ "$dspEDITOR" = "xed" ]] && test -e /usr/bin/xed && xed $locale"$2" 
	[[ "$dspEDITOR" = "xed" ]] && ! test -e /usr/bin/xed && echo $dspEDITOR not installed 
	[[ "$dspEDITOR" = "featherpad" ]] && test -e /usr/bin/featherpad && featherpad $locale"$2" 
  	[[ "$dspEDITOR" = "featherpad" ]] && ! test -e /usr/bin/featherpad && echo $dspEDITOR not installed
fi
}
isdiff() {
if [ -s "$1" ]; then
	diffrlt="true"
	CDATE=$( head -n1 $SORTCOMPLETE | awk '{print $1 " " $2}')
    if [ "$flsrh" == "false" ]; then awk -v tme="$CDATE" '$0 >= tme' "$difffile" > $2 ; else cat "${difffile}" > $2; fi
	echo >> "${difffile}"
	while IFS="" read -r p || [ -n "$p" ]; do cFILE=$( echo "$p" | cut -d " " -f3-) ; dt="$( echo "$p" | cut -d " " -f1,2)" ; grep -Fqs "$cFILE" $SORTCOMPLETE && echo "Modified" "$p" >> $ABSENT || { echo "Deleted" "$p" >> $ABSENT ;  echo "Deleted" "$dt" "$p" >> $rout ; } ; done < $2
	test -f $ABSENT  && { echo Applicable to your search ; cat $ABSENT ; } >> "$1" || { echo "None of above is applicable to search. It is the previous search"; } >> "$1"
else
    samerlt="true" # test -e "$1" && rm "$1"
fi
}
# find old search for convenience
hsearch() {
r=$(find . -type f -path "*${MODULENAME}_MDY*/*" | wc -l)
if (( r >= 1 )); then
	for folder in $(ls -d /tmp"${MODULENAME}"_MDY* | sort -r); do # most recent folder
		for file in $folder$MODULENAME"xSystemchanges${argone}"*; do
		    test -f $file && { OLDSORTED=$file ; nodiff="true"; break; }
		done
		[[ -n "$OLDSORTED" ]] && break
	done
fi
}
escf() {
local o="$1"
o="${o//\\/\\\\}" ; o="${o//$'\n'/\\n}"; o="${o//\"/\\\"}" ; o="${o//$/\\\$}"
printf '%s' "$o"
}
unescf() {
local k="$1"
k="${k//\\n/$'\n'}" ; k="${k//\\\"/\"}" ; k="${k//\\\$/\$}" ; k="${k//\\\\/\\}" 
printf '%s' "$k"
}
backend() {
ofile=$atmp/tmpinfo ; tfile=$atmp/tmpd
if [ -d /tmp/rc ] && [ "$ANALYTICS" == "true" ] && [ "$STATPST" == "false" ]; then
    for file in /tmp/rc/*; do
        cat $file >> $ofile  2> /dev/null
    done
    if [ -s $ofile ]; then
        sort -u -o $ofile $ofile
		hanly $SORTCOMPLETE $ofile $5
		ret=$?
		if [ "$ret" -gt 0 ]; then
			echo "failure in ANALYTICS hanly subprocess"
		fi
    fi
fi
if [ "$STATPST" == "true" ]; then
	if [ "$ANALYTICS" == "false" ]; then
		if [ "$backend" == "default" ]; then
			if [ -s $logpst ]; then
				if decrypt $xdata2 $logpst; then
					awk 'NF' $xdata2 > $ofile
					 if [ -s $ofile ]; then
						sort -u -o $ofile $ofile
						hanly $SORTCOMPLETE $ofile $5
						ret=$?
						if [ "$ret" -ne 0 ]; then
							echo "failure in STATPST hanyl subprocess"
						fi
					fi
					pstc="true"
				else
					echo "Failed to decrypt log file in hanly for STATPST. log file ${logpst}"
				fi
			else
				pstc="true"
			fi
			if [ "$pstc" == "true" ]; then
				imsg="$(storeenc $SORTCOMPLETE $logpst "dcr")"
				ret=$?
				if [ "$ret" -ne 0 ]; then
					echo "$imsg"
				else
					if [ "$imsg" -ge 0 ] 2>/dev/null; then
						if (( imsg % 10 == 0 )); then  cyan "$imsg searches in gpg log"; fi
					elif [ "$imsg" != "" ]; then
						green "Persistent search log file created."
					fi
				fi
				if [ -s $rout ]; then
					sort -u -o $rout $rout
					sed -i -E '/^Deleted/ s/^([^ ]+) ([^ ]+ [^ ]+) (.+)$/\1,"\2","\2",\3/' "$rout" # input action date time file name -->  action,"date time", "date time", file name
					sed -i -E '/^Deleted/! s/^([^ ]+) ([^ ]+ [^ ]+) ([^ ]+ [^ ]+) (.+)$/\1,"\2","\3",\4/' $rout  # input Action,"date time","date time", file name spaces   
					if [ -s $COMPLETE ]; then cat $COMPLETE >> $rout; fi
					if [ "$pstc" == "true" ]; then
						imsg="$(storeenc $rout $statpst)"
						ret=$?
						if [ "$ret" -ne 0 ]; then
							echo "$imsg"
						else
							if [ "$imsg" != "" ]; then green "Persistent stats file created."; imsg=""; fi
						fi
					fi
				fi
			fi
		else
	        if ! gpg --list-keys | grep -q $email; then generatekey ; fi	
			python3 /usr/local/save-changesnew/pstsrg.py $SORTCOMPLETE $pydbpst $rout $tfile $checkSUM $cdiag $email $mMODE $ANALYTICSECT $proteusSHIELD $nc
			ret=$?
			if [ "$ret" -ne 0 ]; then
				if [ "$ret" -eq 2 ] || [ "$ret" -eq 3 ]; then
					echo "Problem with GPG refer to instructions on setting up pinentry ect. Database preserved."
				elif [ "$ret" -eq 4 ]; then
					echo "Problem with database in psysrg.py"
				else
					echo "Pstsrg.py failed. exitcode ${ret}"
				fi
			fi
			processha $argf
		fi
	fi
fi
[[ -s "$difffile" ]] && [[ -n "$( tail -n 1 "$difffile")" ]] && [[ "$ANALYTICSECT" == "true" ]] && [[ "$backend" == "default" ]] && green "Hybrid analysis on"
if [[ "$csum" != "true" && -s $slog && "$supress" == "true" ]]; then
	{ echo; echo "cdiag"; echo ; cat $slog; } >> "$difffile"
elif [[ "$csum" != "true" && -s $slog && "$supress" == "false" ]]; then
	filteroutput $slog "Checksum" "no" "blue" "yellow" "Scr"
	{ echo; echo "cdiag"; echo ; cat $slog; } >> "$difffile" 
elif [[ "$csum" == "true" ]]; then
	{ echo; echo "cdiag alert"; echo ; cat /tmp/cerr ; } >> "$difffile"
	rm /tmp/cerr
fi
test -f $slog && rm $slog ; test -f $rout && rm $rout
}
ulink() {
sbwr
green "Updating hardlinks"
while IFS= read -r p || [[ -n "$p" ]]; do 
    ck="false"
	#cFILE=$(perl -nE 'say $1 if /"((?:[^"\\]|\\.)*)"/' <<< "$p")
    cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p")
	y=$cFILE
	cln="${p//\"$y\"/}"
	read -r _ _ _ _ of5 _ <<< "$cln"
	inode="$of5"
    if [ "$supbrwr" == "true" ]; then
        for item in "${webb[@]}"; do if [[ "$y" =~ "$item" ]]; then [ -n "$item" ] && echo "None" && ck="true"; break ; fi ; done
    fi
	if [ "$inode" == "None" ] && [ "$ck" == "false" ]; then 
        echo "None" 
    elif [ "$ck" == "false" ]; then
         echo $inode
    fi
done < $1 > $TMPOPT
mapfile -t inodes_array < "$TMPOPT" ; declare -A inode_map
while read -r inode; do inode_map["$inode"]=$((inode_map["$inode"] + 1)) ; done < <(find /bin /etc /home /lib /lib64 /opt /root /sbin /usr /var -xdev -printf '%i\n' 2>/dev/null)
for inode in "${inodes_array[@]}"; do
    if [ "$inode" = "None" ]; then
        echo "None"
    else
        count=${inode_map["$inode"]}
        if [ -z "$count" ] || [ "$count" -eq 0 ] || [ "$count" -eq 1 ]; then
            echo "None"
        else
            echo "$count"
        fi
    fi
done > $TMPOPT
paste -d' ' $1 $TMPOPT > $2 ; mv $2 $SORTCOMPLETE
}
intst() {
if [ "$ANALYTICSECT" == "true" ]; then start=$(date +%s.%N); fi 
if [ "$STATPST" == "true" ]; then
    if [ -f $logpst ]; then
        sz=$( stat -c %s "$logpst")
        if [ $(( sz / 1048576 )) -gt $logSIZE ]; then
            if [ "$logPRF" == "del" ]; then
               : > $logpst
            elif [ "$logPRF" == "stop" ]; then
                cyan "persist log saving stopped on size limit"
            fi
            STATPST="false"
            if [ "$logPRF" == "rfh" ]; then
                rm $logpst
                STATPST="true"
            fi
		elif [ $(( sz / 1048576 )) -ge $compLVL ]; then
			nc="true"
        elif [ $sz -eq 0 ]; then
            cyan "$logpst is 0 bytes. to resume persistent logging delete file"
            STATPST="false"
        fi
    fi
fi
}
isoutput() {
local y=$#
if (( y >= 7 )); then
	c=4
elif (( y == 4)); then
	c=2
elif (( y == 2 )); then
	c=1
else
	echo either 2 4 or 8 args
fi
for ((i = 1; i <= c; i++)); do
    files=($atmp/${!i})
    x=$((i + c))
    if [[ ${#files[@]} -gt 0 ]] && [[ " ${files[@]} " != *"${!i}"* ]]; then
        output="${!x}"
        cat "${files[@]}" >> $output
    fi
done
}
sblk() {
local sl=""
local y="$x"
x="$( unescf "$x")" 
local csum
if [ -e "$x" ] && [ -f "$x" ]; then
   	stat_out=$(stat -c "%Y %X %i %U %g %A %Z " "$x")
	read -r mtime atime i onr gr pmr itime <<<"$stat_out"
	mt=$(date -d "@$mtime" +"%Y-%m-%d %H:%M:%S")
	ct=$(date -d "@$itime" +"%Y-%m-%d %H:%M:%S")
	ats=$(date -d "@$atime" +"%Y-%m-%d %H:%M:%S")
	if [ -n "$mt" ]; then
        if [[ "$1" = "ctime" && "$itime" -gt "$mtime" ]] || [[ "$1" = "main" ]]; then
			if [ "$checkSUM" == "true" ]; then
				csum=$(md5sum "$x" 2> /dev/null) ; csum=${csum%% *} ; csum=${csum:-None}
				fs=$(stat --format=%s "$x" 2> /dev/null) ; fs=${fs:-None} 
				[[ -L "$x" ]] && sl="y"
				wnr=${onr:-None} ; grp=${gr:-None} ; pmn=${pmr:-None}  ; sl=${sl:-None}
				adtcmd="$csum $fs $sl $wnr $grp $pmn $cam"
			else
			    adtcmd=""
			fi
			[[ "$1" = "ctime" ]] && cam="y" && mt=$ct || cam="None"
			ct=${ct:-None None}
			ats=${ats:-None None}
			output="$mt \"$y\" $ct $i $ats $adtcmd"
			printf '%s\n' "$output" >> $2
		fi
	fi
else
	printf "%s,,,%s\n" "Nosuchfile" "$y" >> $3
fi
}
search() {
if [[ "$mMODE" = "default" ]]; then
	xargs -0 -n 50 /usr/local/save-changesnew/mainloop $atmp $2 $3 $4 $5 $6 < $1
elif [[ "$mMODE" = "mc" ]]; then
	x=$(tr -cd '\0' < $1 | wc -c) ; y=8
	if (( x > 100 )); then y=16 ; fi
	xargs -0 -n"$y" -P4 /usr/local/save-changesnew/mainloop $atmp $2 $3 $4 $5 $6 < $1
fi
}
ctimeloop() {
[[ "$checkSUM" = "true" ]] && [[ "$ANALYTICS" = "true" || "$STATPST" = "true" ]] && cyan "Running checksum." || checkSUM="false"
if [ "$ANALYTICSECT" = "true" ]; then end=$(date +%s.%N) ; if [ "$checkSUM" == "true" ]; then cstart=$(date +%s.%N) ; fi ; fi
while IFS= read -r -d '' f; do f="$( escf "$f")" ; echo "$f" ; done < $1 >> $2
while IFS= read -r -d '' f; do f="$( escf "$f")" ; echo "$f" ; done < $toutnul >> $tout
if [ "$FEEDBACK" == "true" ]; then cat $tout; cat $2; fi
if [ -s $tout ]; then grep -Fxv -f $2 $tout > $TMPCOMPLETE; >$tout; fi
>$tout
if [ -s $TMPCOMPLETE ]; then
	while IFS= read -r x; do x="$( unescf "$x")" ; printf '%s\0' "$x"; done < $TMPCOMPLETE > $xdata
	search $xdata $tout $COMPLETE $checkSUM "ctime" batch2 # new output files
	isoutput mainloop3* mainloop4* $tout $COMPLETE
fi
}
