#!/bin/bash
#   Developer buddy 3.0 core                                               9/15/2025

# Filter terminal and hardlinks
sbwr() {
webb=(
    'mozilla'
	'.mozilla'
    'chromium-ungoogled'
	#'google-chrome'
    "$LCLMODULENAME"
# other
)
}

get_colors(){
txtyellow=${txtbld}$(tput setaf 3)
txtblue=${txtbld}$(tput setaf 4)
function yellow() { echo -e $txtyellow "$1" $rst; }
function blue(){ echo $txtblue "$1" $rst; }
}
postop() {
if [ "$POSTOP" == "true" ]; then
	while IFS= read -r x; do x="$(unescf "$x")" ; printf '%s\0' "$x"; done < $1 > $atmpxdata
    if [ -f $USRDIR/doctrine.tsv ]; then
        sed -i 's/^export POSTOP="true"/export POSTOP="false"/' $2
    else
        echo -e "Datetime\tFile\tSize(kb)\tType\tModified\tAccessed\tOwner" > $atmp/doctrine
        while IFS= read -r -d '' x; do
            f="$(cut -d' ' -f3- <<< "$x")"
            dt=$(cut -d' ' -f1-2 <<< "$x")
            if [ -e "$f" ] && [ -f "$f" ]; then
                onr=$( stat -c "%U" "$f")
                mtyp=$( file --brief --mime-type "$f")
                if [ "$mtyp" == "application/octet-stream" ]; then mtyp="Unknown"; fi
                if [ -L "$f" ]; then mtyp="Symlink"; fi
                sz=$( stat -c %s "$f")
                md=$( stat -c '%Y' "$f") ; x=$(date -d "@$md" +'%Y-%m-%d %H:%M:%S')
                ae=$( stat -c '%X' "$f") ; y=$(date -d "@$ae" +'%Y-%m-%d %H:%M:%S')
                echo -e "$dt\t$f\t$(( sz / 1024 ))\t$mtyp\t$x\t$y\t$onr" >> $atmp/doctrine
            fi
        done < $atmpxdata
        unset IFS
        head -1 $atmp/doctrine > $USRDIR/doctrine.tsv
        tail -n +2 $atmp/doctrine | sort -t$'\t' -k7,7 -k3,3n >> $USRDIR/doctrine.tsv
        green "File doctrine.tsv created in $USRDIR"
        #column -t -s $'\t' $USRDIR/doctrine.tsv      this command prints a nice tab seperated log
    fi
fi
}
stmp() {
sf=$MODULENAME"_"$FLBRAND
if (( tmpSRHS > 0 )); then #store it in tmp
    test -d /tmp/rc || mkdir /tmp/rc
	r=$(find /tmp/rc -maxdepth 1 -type f -name '*rntfiles_MDY*' 2>/dev/null | wc -l)
    if [ "$r" -eq "$tmpSRHS" ]; then #Clear last file
        test -f /tmp/rc/full || { touch /tmp/rc/full ; cyan "searches builtup in /tmp/rc"; }
        for file in "/tmp/rc"$MODULENAME"_MDY"*
        do
            rm -f $file
            break
        done
    fi
	awk 'NF' $1 > $TMPCOMPLETE; mv $TMPCOMPLETE $1
    cp $1 "/tmp/rc"$sf
fi
}
filterhits() {
local lt=$atmp/patterns.txt
local fl=/usr/local/save-changesnew/filter
test -f $2 || echo "Entry,Hits" >> $2
sed -n '/^[[:space:]]*#/!s|sed -i '\''/\(.*\)/d'\''.*|\1|p' "$fl" > $lt
while IFS= read -r pattern; do
    k=$( echo "$pattern" | sed -e 's/\\//g' -e "s|'\"\${2}\"'|$USR|g") #convert for grep
    x=$( grep -Fc -- "$k" $1) # search matches from logs
    if grep -Fq "sed -i '/$pattern/d" $2; then
        if (( x > 0 )); then
            y=$( grep -F "sed -i '/$pattern/d" $2 | cut -d',' -f2)
            b=$(( y + x ))
            lno=$(grep -Fn "sed -i '/$pattern/d" "$2" | cut -d: -f1)
            sed -i "${lno}s/,[0-9]\+\$/,$b/" $2
        fi
    else
        line=$(grep -F "sed -i '/$pattern/d" "$fl" | grep -v '^[[:space:]]*#')
        if [ "$line" != "" ]; then
            echo "\"$line\",$x" >> $2
        fi
    fi
done < $lt
unset IFS
rm $lt
}
generatekey() {
	# 5.1 porteus   GPG 2.x+ generate key but if 5.01 has GPG2 do it too
	if which gpg2 > /dev/null 2>&1 || gpg --version | grep -q "(GnuPG) 2"; then #gpg --full-generate-key
		read -sp "Enter passphrase for new GPG key: " p
cat > /tmp/keyparams.conf <<EOF
%echo Generating a GPG key
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
Name-Real: John e
Name-Email: $email
Expire-Date: 0
Passphrase: $p
%commit
%echo done
EOF
		if which gpg2 > /dev/null 2>&1; then
			gpg2 --batch --pinentry-mode loopback --passphrase "$p" --generate-key /tmp/keyparams.conf
		else
			gpg --batch --pinentry-mode loopback --passphrase "$p" --generate-key /tmp/keyparams.conf
		fi
		shred -u /tmp/keyparams.conf
		echo "GPG key generated for ${email}."
	else
		if grep -iq "Porteus 5.01" /etc/os-release; then
			if which expect > /dev/null 2>&1; then # is expect installed?
				echo "expect needs to be installed. And run the keygen file for 5.01. Remember to remove passphrase after from file."
			else
				echo "Please run the keygen file for 5.01. Then erase the passphrase you entered in the file from the file."
			fi
		fi
		return 1
	fi
}
storeenc() {
shopt -s expand_aliases
local c
if [ "$STATPST" == "true" ]; then
	if which gpg2 > /dev/null 2>&1; then
		if ! gpg2 --list-keys | grep -q $email; then
			generatekey
		fi
	else
		if ! gpg --list-keys | grep -q $email; then
			generatekey
		fi
	fi
	if grep -m 1 -q '^Modified,' $1; then  msg=" stats"; else msg=" log"; fi

	if [ -s "$2" ]; then

		ag="true"
		if [ "$3" != "dcr" ]; then
			xdata=$TMPDIR$xdata
			if ! decrypt $xdata $2; then
				if [ "$ag" == "false" ]; then
					echo "Agent not installed for gpg 1.4 skipping... ${msg}"
				else
					echo "Failed to decrypt ${2}${msg}"
				fi
				return 1
			fi
			source=$xdata
		else
			source=$xdata2
		fi

		if [ "$msg" == " stats" ]; then
			declare -A ref_map
			while IFS= read -r line || [ -n "$line" ]; do
				key=${line#*,*,*,}
				[[ -n "$key" ]] && ref_map["$key"]="$line"
			done < $source
         while IFS="" read -r p || [ -n "$p" ]; do
			ft=$(echo "$p" | cut -d',' -f1)
			dt=$(echo "$p" | cut -d',' -f2 | tr -d '"')
			if [ "$ft" == "Nosuchfile" ]; then #  sed 's/^ *//;s/ *$//')  remove leading trailing space
				echo "$p" >> $source
			else
				ct=$(echo "$p" | cut -d',' -f3 | tr -d '"')
				filepath=${p#*,*,*,} # format action,"date time","change time", file name 
				if [[ ! -v ref_map["$filepath"] ]]; then
	                echo "$p" >> $source
				else
				 	found="${ref_map["$filepath"]}"
					old_dt=$(echo "$found" | cut -d',' -f2 | tr -d '"')
					old_ct=$(echo "$found" | cut -d',' -f3 | tr -d '"')
					if [[ "$dt" > "$old_dt" ]] || [[ "$ct" > "$old_ct" ]]; then
						echo "$p" >> $source
					fi
				fi
			fi
         done < $1
			unset IFS

		else # its a log
		    c=$( grep -c '^$' $source)
		    if  (( c == logCT )); then
		        sed -i '1,/^$/d' $source
		    fi
			while IFS= read -r p || [[ -n "$p" ]]; do
				cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p")
				y=$cFILE
				current_ln="${p//\"$y\"/}"
				read -r f1 f2 f3 f4 _  <<< "$current_ln"
				dt="$f1 $f2"
				ct="$f3 $f4"
				r=$( grep -F "$dt \"$y\" $ct" $source)
				[[ -z "$r" ]] &&  echo "$p" >> $source
			done < $1
			unset IFS
		    echo >> $source # end of log
		fi

		t=(--encrypt -r $email -o $2 $source)
		if which gpg2 > /dev/null 2>&1; then 
			cmmd=(gpg2 --yes) # 5.01 with 2.0
		else
			cmmd=(gpg --yes) # 5.1 with gpg2 or 5.01 with gpg 1.4.23 and gpg agent 2.1.11
		fi
		[[ "$nc" == "true" ]] && cmmd+=(--compress-level 0)
		cmmd+=("${t[@]}")
		if ! "${cmmd[@]}"; then
			echo "Encryption failed for file: $source  . $2$msg "
			return 1
		fi
		rm $source #shred -u $source
		if [ "$msg" == " log" ]; then echo $c; fi

	else # no file create file
		echo >> $1
		if which gpg2 > /dev/null 2>&1; then # 5.01 with 2.0
			if ! gpg2 --yes -e -r $email -o $2 "$1"; then #encrypt
				 echo "Encryption failed for file: $1"
				 return 1
			fi
		else # 5.1 or 5.01 with 1.4.23
			if ! gpg --yes -e -r $email -o $2 "$1"; then #encrypt
				 echo "Encryption failed for file: $1"
				 return 1
			fi
		fi
		echo "The${msg} was created."
	fi
fi
}
decrypt() {
if grep -iq "Porteus 5.01" /etc/os-release && ! which gpg2 > /dev/null 2>&1; then # GnuPG 1.4.23
    if which gpg-agent > /dev/null 2>&1; then
	    export GPG_TTY=$(tty)            # If you cant get it to work try commenting these two out and the other two in recentchanges might fix it
        export GPG_AGENT_INFO=/root/.gnupg/S.gpg-agent:0:1
	    if ! gpg --yes -d -o $1 $2; then
		    return 1
	    fi
    else
        ag="false"
        return 1
    fi
else # all version with  GPG 2.0
	if which gpg2 > /dev/null 2>&1; then # porteus 5.01 with v2
		if ! gpg2 --yes -d -o $1 $2; then
    		return 1
		fi
	else # porteus 5.1 with v2
		if ! gpg --yes -d -o $1 $2; then
    		return 1
		fi
	fi
fi
}
iscopy() {
while IFS= read -r p || [[ -n "$p" ]]; do
    cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p")
	y=$cFILE
	current_ln="${p//\"$y\"/}"
	read -r f1 f2 f3 f4 _ _ _ f8 _ <<< "$current_ln"
	dt="$f1 $f2" ; cs="$f8"
	ct="$f3 $f4"
	copy_record=$(grep -F -v "\"$y\"" $1 | tail -n 1)
	if [[ -n "$copy_record" ]]; then
		tmp="${copy_record#*\"}"
		y="${tmp%\"*}"
		original="${copy_record//\"$y\"/}"
		read -r of1 of2 of3 of4 _  <<< "$original"
		oct="$f3 $f4"
		#oct=$( awk '{ print $(NF-10), $(NF-9) }' <<< "$copy_record")
		if date -d "$ct" "+$fmt" >/dev/null 2>&1 && date -d "$oct" "+$fmt" >/dev/null 2>&1; then
			echo "Copy $dt $ct $y" >> $rout
		fi
	fi
done < $TMPCOMPLETE
}
collision() {
local label="$1"
local chksum="$2"
local filesize="$3"
local type=$4
local arr
while IFS= read -r line; do
	os=""
	cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$line")
	y=$cFILE
	current_ln="${line//\"$y\"/}"
	read -r _ _ _ _ _ _ _ record_c os _ <<< "$current_ln"
	#read record_c os < <(awk '{ print $(NF-6), $(NF-5) }' <<< "$line")
    if [[ "$cFILE" != "$label" && "$record_c" != "None" && "$os" != "None" ]]; then
        if [[ "$chksum" == "$record_c" && "$filesize" != "$os" ]]; then 
			if [ "$os" -ge 0 ] 2>/dev/null; then
				collisions+=("COLLISION: $label vs $cFILE | Checksum: ${chksum} && ${record_c} | Sizes: $filesize != $os") ; csm="true"
			fi
		fi
    fi
done < <(grep -F "$chksum" "$ofile")
}

is_valid_date() { date -d "$1" >/dev/null 2>&1 ; c=$?; return $c ; }
newmeta() {
current_own="$1"
current_grp="$2"
current_perm="$3"
prev_own="$4"
prev_grp="$5"
prev_perm="$6"
old_meta="$prev_own $prev_grp $prev_perm"
cur_meta="$current_own $current_grp $current_perm" #cur_meta="$au $ag $apmr" # ln 448   free
if [[ "$old_meta" == "$cur_meta" ]]; then
	return 1
fi
}
stealth() {
local file="$1"
local label="$2"		
local cksum="$3"
local current_size="$4"
local original_size="$5"	
local delta
local abs_delta 					
if [ -f "$file" ] && [ -n "$current_size" ] && [ "$current_size" != "None" ] && [ -n "$original_size" ]; then
	if [ "$label" != "/usr/local/save-changesnew/flth.csv" ]; then
		delta=$(( current_size - original_size ))
		abs_delta=${delta#-}
		if [ "$original_size" == "$current_size" ]; then
			echo "Warning file ${label} same filesize different checksum. Contents changed." >> $cerr
		elif [ "$abs_delta" -le 12  ] && [ "$abs_delta" -ne 0 ]; then
			msg="Checksum indicates a change in ${label}. Size changed slightly — possible stealth edit."
			if [ "$cdiag" == "true" ]; then
				 echo "$msg ($original_size → $current_size)." >> $slog
			else
				 echo "$msg" >> $scr
			fi
		fi
	fi
	if [ "$cdiag" == "true" ]; then collision "$label" $cksum $current_size $7 ; fi
fi
}
#cFILE=$(perl -nE 'say $1 if /"((?:[^"\\]|\\.)*)"/' <<< "$p") orig
#cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p") 
#y=$cFILE
#current_ln="${p//\"$y\"/}"
#cFILE="$( unescf "$cFILE")"
hablk() {
>$TMPCOMPLETE
while IFS= read -r p || [[ -n "$p" ]]; do
	found_line=""
	df="false"
	tmp="${p#*\"}"
	y="${tmp%\"*}"
	current_ln="${p//\"$y\"/}"
	read -r f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 _ <<< "$current_ln"
	in="$f5"
	if [ -n "$in" ] && [ "$in" -ge 0 ] 2>/dev/null; then 	
		if [ "$1" == "A" ]; then found_line="${ref_map[$y]}" ; else found_line=$( grep -F "$y" "$ofile" | tail -n 1) ; fi # for line in "${ref_lines[@]}"; do if [[ "$line" == *"$y"* ]]; then found_line="$line" ; fi ; done regular array old multicore
		if [ -n "$found_line" ]; then
			original_ln="$found_line"
			if [ "$1" != "A" ]; then original_ln="${found_line//\"$y\"/}" ; fi
			read -r of1 of2 of3 of4 of5 of6 of7 of8 of9 of10 of11 of12 of13 _ <<< "$original_ln"
			cFILE="$( unescf "$cFILE")"
			oat="$of6 $of7" ; cat="$f6 $f7" 
			is_valid_date "$oat" && is_valid_date "$cat" || continue 
			if [ "$checkSUM" == "true" ]; then ocs="$of8" ; cs="$f8" ; os="$of9" ; csze="$f9" ; [[ "$cs" != "None" ]] || continue ; fi
			oin="$of5"
			if [ -n "$oin" ] && [ "$oin" -ge 0 ] 2>/dev/null; then
				dt="$f1 $f2" ; omt="$of1 $of2" ; ct="$f3 $f4"
				if [ "$dt" == "$omt" ]; then
					if [ "$checkSUM" == "true" ]; then
						if [ -f "$cFILE" ]; then
							if [[ "$cs" != "$ocs" ]]; then
								echo "Suspect $dt $ct $y" >> $rout
				                echo "Suspect file: $y changed without a new modified time." >> $cerr
				                csm="true"
							else
								if (( oin == in )); then
									if newmeta $f11 $f12 $f13 $of11 $of12 $of13; then
										df="true"
										echo "Metadata $dt $ct $y" >> $rout
										echo "Permissions of file: $y changed $f11 $f12 $f13 → $of11 $of12 $of13" >> $slog
									fi
								else
									df="true"
									echo "Copy $dt $ct $y" >> $rout
								fi
							fi
							if [ "$df" == "false" ]; then
		                        read a_mod fs a_ct au ag apmr < <(stat --format="%Y %s %Z %U %g %A" "$cFILE" 2>/dev/null)
								afrm=$(date -d "@$a_mod" +"$fmt" 2>/dev/null)
								if [ -n "$afrm" ] && [ "$afrm" != "$dt" ]; then
									a_checksum=$(md5sum "$cFILE" 2> /dev/null | awk '{print $1}')
									if [ -n "$a_checksum" ]; then
										 stealth "$cFILE" "$y" $a_checksum $fs $csze
									fi
									if [ "$cdiag" == "true" ]; then 
		                                m="File changed during the search."
										echo "$m $y at ${afrm}. Size was $os, now $fs." >> $slog
		                            else
										echo "$m $y. File likely changed. system cache item." >> $slog
		                            fi
								fi
							fi
						fi
					fi        
				else
					if [ "$checkSUM" == "true" ]; then
						if (( oin != in )); then
							if [ "$ocs" == "$cs" ]; then
								echo "Overwrite $dt $ct $y" >> $rout
							else
								echo "Replaced $dt $ct $y" >> $rout
								stealth "$cFILE" "$y" $cs $csze $os
							fi
						else
							if [ "$ocs" != "$cs" ]; then
								echo "Modified $dt $ct $y" >> $rout
								stealth "$cFILE" "$y" $cs $csze $os
							else
								if newmeta $f11 $f12 $f13 $of11 $of12 $of13; then
									echo "Metadata $dt $ct $y" >> $rout
									echo "Permissions of file: $y changed $f11 $f12 $f13 → $of11 $of12 $of13" >> $slog
								else
									echo "Touched $dt $ct $y" >> $rout
								fi
							fi
						fi
					else
						if (( oin != in )); then
							echo "Replaced $dt $ct $y" >> $rout
						else
							echo "Modified $dt $ct $y" >> $rout
						fi
					fi
				fi
			fi
		else
			echo "$p" >> $2  # is copy?
		fi
	fi
done < $SORTCOMPLETE
if [ "$csm" == "true" ]; then 
	if (( ${#collisions[@]} > 0 )); then for entry in "${collisions[@]}"; do echo "$entry"  >> $cerr ; done ; fi
fi
}
hanly(){
	local csm=""
	local y=8
    declare -a collisions=()
	if [ "$mMODE" == "mc" ]; then
		x=$(wc -l < "$SORTCOMPLETE")
		y=$(( (x + max_jobs - 1) / max_jobs )) 
		split -l $y --numeric-suffixes=1 --suffix-length=4 "$SORTCOMPLETE" "$atmp/sortchunk_"
		find "$atmp" -type f -name 'sortchunk_*' -print0 | sort -z | xargs -0 -P"$max_jobs" -I{} /usr/local/save-changesnew/haloop $atmp "{}" $2 $checkSUM $cdiag
		isoutput haloop1* haloop2* haloop3* haloop4* $rout $slog $cerr $TMPCOMPLETE
	else
		cores=""
        # mapfile -t ref_lines < "$2" old array
        # tmp="${p#\"}" ; key="${tmp%%\"*}"   # key=$(perl -nE 'say $1 if /"((?:[^"\\]|\\.)*)"/' <<< "$p")
		declare -A ref_map                    
		while read -r p; do key=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p") ; current_ln="${p//\"$key\"/}" ; ref_map["$key"]="$current_ln" ; done < $2
		hablk "A" $TMPCOMPLETE
	fi
	
	test -s $TMPCOMPLETE && iscopy $2
	rm $2
    processha "$@"
}
filteroutput() {
local filtername="$2"
local critical="$3"
local pricolor="$4"
local seccolor="$5"
local col="COLLISION"
local type="$6"
local flg="false"
sbwr
while IFS= read -r file; do 
	ck=""
	if [[ "$file" == "$filtername"* ]]; then
        if [ "$supbrwr" == "true" ]; then
		    for item in "${webb[@]}"; do if [[ "$file" =~ $item ]]; then ck="true" ; break ; fi ; done
        fi
	 	[[ -z "$ck" && "$supress" == "false" && "$flg" == "false" ]] && $pricolor "$file $6"
	else
		[[ "$critical" != "no" ]] && if [[ "$file" == "$critical"* ]] || [[ "$file" == "$col"* ]]; then $seccolor "$file $6 Critical" ; flg="true" ; fi
		[[ "$critical" == "no" ]] && $seccolor "$file $6"
	fi
done < $1
}
processha() {
local invr="$3" ; [[ -z "$invr" ]] && invr="$1"
if [ -s $rout ]; then
	sed -E 's/^(([^[:space:]]+[[:space:]]+){3})([^[:space:]]+[[:space:]]+){2}(.*)/\1\4/' "$rout" | grep -v "^Deleted" > $tfile
    { echo ; echo "Hybrid analysis" ; echo ; } >> "$difffile"
	sort -o $tfile $tfile
	if [ -s $ABSENT ]; then sort -o $ABSENT $ABSENT; comm -23 $tfile $ABSENT > $TMPCOMPLETE ; else sort -k2,2 -k3,3 -o $TMPCOMPLETE $tfile ; fi

	if [ "$flsrh" == "true" ] || [ "$invr" == "filtered" ]; then
		if ! { [ "$flsrh" == "true" ] && [ "$invr" == "filtered" ]; } ; then /usr/local/save-changesnew/filter $TMPCOMPLETE $USR ; fi
	fi
	if [ "$flsrh" == "true" ]; then
		cDATE=$( head -n1 $TMPOPT | awk '{print $1 " " $2}')
		awk -v tme="$cDATE" '$0 >= tme' "$TMPCOMPLETE" > $TMPOUTPUT
		cp $TMPOUTPUT $TMPCOMPLETE
	fi
	awk '{printf "%-9s\t%-19s %s\n", $1, $2" "$3, substr($0, index($0,$4))}' "$TMPCOMPLETE" >> "$difffile"
	get_colors
	if [ -s "/tmp/cerr" ]; then 
        if [ "$supbrwr" == "true" ]; then
            sbwr
            grep "Suspect\|COLLISION" /tmp/cerr > $TMPCOMPLETE
            for item in "${webb[@]}"; do sed -i "\|$item|d" /tmp/cerr ; done
            [[ -s $TMPCOMPLETE ]] && cat $TMPCOMPLETE >> /tmp/cerr
            sort -u -o /tmp/cerr /tmp/cerr 
        fi
		filteroutput "/tmp/cerr" "Warning" "Suspect" "yellow" "red" "elevated"
		if [[ -z "$csum" ]]; then csum="true" ; fi
	fi
	if [ -n "$cores" ] && [ "$csm" == "" ]; then echo "Detected $cores CPU cores."; fi
fi
}
suffix() {
    suffixes=(
        "xSystemDiffFromLastSearch"
        "xFltDiffFromLastSearch"
        "xFltchanges"
        "xFltTmp"
        "xSystemchanges"
        "xSystemTmp"
        "xNewerThan"
        "xDiffFromLast"
    )
}
inclusions() {
local c=$SORTCOMPLETE
sed -i '/\/usr\/local\/save-changesnew\/flth\.csv/d' $c #sed -i '/\/tmp/\/rnt/d' $2
sed -i '/\/home\/'"${USR}"'\/\Downloads\/rnt/d' $c
for var in logpst statpst pydbpst; do gp="${!var}" ; sed -i "\|$gp|d" $c ; done
}
clearlogs() {
suffix
for suffix in "${suffixes[@]}"; do rm -f "${MODULENAME/#\//}$suffix"* 2>/dev/null ; done
}
logic() {
if [ "$syschg" == "false" ]; then  cyan "No sys files to report." ; fi
if [ "$samerlt" == "true" ] && [ "$syschg" == "true" ] && [ "$nodiff" == "true" ]; then cyan "The sys search was the same as before." ; fi
if [ "$diffrlt" == "false" ] && [ "$nodiff" == "true" ];then green " Nothing in the sys diff file. That is the results themselves are true" ; [[ -n "$1" ]] & cyan "$1" ; fi
}
display() {
local locale=$1
if [ "$dspEDITOR" != "false" ]; then
	[[ "$dspEDITOR" = "xed" ]] && test -e /usr/bin/xed && xed $locale"$2" 
	[[ "$dspEDITOR" = "xed" ]] && ! test -e /usr/bin/xed && echo $dspEDITOR not installed 
	[[ "$dspEDITOR" = "featherpad" ]] && test -e /usr/bin/featherpad && featherpad $locale"$2" 
  	[[ "$dspEDITOR" = "featherpad" ]] && ! test -e /usr/bin/featherpad && echo $dspEDITOR not installed
fi
}
isdiff() {
if [ -s "$1" ]; then
	diffrlt="true"
	CDATE=$( head -n1 $SORTCOMPLETE | awk '{print $1 " " $2}')
    if [ "$flsrh" == "false" ]; then awk -v tme="$CDATE" '$0 >= tme' "$difffile" > $2 ; else cat "${difffile}" > $2; fi
	echo >> "${difffile}"
	while IFS="" read -r p || [ -n "$p" ]; do cFILE=$( echo "$p" | cut -d " " -f3-) ; dt="$( echo "$p" | cut -d " " -f1,2)" ; grep -Fqs "$cFILE" $SORTCOMPLETE && echo "Modified" "$p" >> $ABSENT || { echo "Deleted" "$p" >> $ABSENT ;  echo "Deleted" "$dt" "$p" >> $rout ; } ; done < $2
	test -f $ABSENT  && { echo Applicable to your search ; cat $ABSENT ; } >> "$1" || { echo "None of above is applicable to search. It is the previous search"; } >> "$1"
else
    samerlt="true" # test -e "$1" && rm "$1"
fi
}
# find old search for convenience
hsearch() {
r=$(find . -type f -path "*${MODULENAME}_MDY*/*" | wc -l)
if (( r >= 1 )); then
	for folder in $(ls -d /tmp"${MODULENAME}"_MDY* | sort -r); do # most recent folder
		for file in $folder$MODULENAME"xSystemchanges${argone}"*; do
		    test -f $file && { OLDSORTED=$file ; nodiff="true"; break; }
		done
		[[ -n "$OLDSORTED" ]] && break
	done
fi
}
escf() {
local o="$1"
o="${o//\\/\\\\}" ; o="${o//$'\n'/\\n}"; o="${o//\"/\\\"}" ; o="${o//$/\\\$}"
printf '%s' "$o"
}
unescf() {
local k="$1"
k="${k//\\n/$'\n'}" ; k="${k//\\\"/\"}" ; k="${k//\\\$/\$}" ; k="${k//\\\\/\\}" 
printf '%s' "$k"
}
pyerrblk() {
if [ "$ret" -ne 0 ]; then
	if [ "$ret" -eq 2 ] || [ "$ret" -eq 3 ]; then
		echo "Problem with GPG refer to instructions on setting up pinentry ect. Database preserved."
	elif [ "$ret" -eq 4 ]; then
		echo "Problem with database in psysrg.py"
	elif [ "$ret" -eq 7 ]; then
		echo "mem failed in pstsrg.py"
	elif [ "$ret" -eq 87 ]; then
		echo "failed to parse from mMODE=\"mem\""
	else
		echo "Pstsrg.py failed. exitcode ${ret}"
	fi
fi
}
backend() { 
ofile=/tmpinfo ; tfile=$atmp/tmpd
 TMPDIR=$(mktemp -d $xopt/tmpda.XXXXXX) 
if [ -d /tmp/rc ] && [ "$ANALYTICS" == "true" ] && [ "$STATPST" == "false" ]; then
    for file in /tmp/rc/*; do
        cat $file >> $atmp$ofile 2> /dev/null
    done
    if [ -s $ofile ]; then
        sort -u -o $atmp$ofile $atmp$ofile
		hanly $SORTCOMPLETE $atmp$ofile $1
		ret=$?
		if [ "$ret" -gt 0 ]; then
			echo "failure in ANALYTICS hanly subprocess"
		fi
    fi
fi
if [ "$STATPST" == "true" ]; then
	if [ "$ANALYTICS" == "false" ]; then
		if [ "$backend" == "default" ]; then
			if [ -s $logpst ]; then

             # decypt once perform ha and save
             chmod 600 $TMPDIR
             xdata2=$TMPDIR$xdata2
             ofile=$TMPDIR$ofile

				if decrypt $xdata2 $logpst; then
					awk 'NF' $xdata2 > $ofile
					 if [ -s $ofile ]; then
						sort -u -o $ofile $ofile
						hanly $SORTCOMPLETE $ofile $5
						ret=$?
						if [ "$ret" -ne 0 ]; then
							echo "failure in STATPST hanyl subprocess"
						fi
					fi
					pstc="true"
				else
					echo "Failed to decrypt log file in hanly for STATPST. log file ${logpst}"
				fi
			else
				pstc="true"
			fi
			if [[ "$pstc" = "true" ]]; then
				imsg="$(storeenc $SORTCOMPLETE $logpst "dcr")"
				ret=$?
				if [ "$ret" -ne 0 ]; then
					echo "$imsg"
				else
					if [ "$imsg" -ge 0 ] 2>/dev/null; then
						if (( imsg % 10 == 0 )); then  cyan "$imsg searches in gpg log"; fi
					elif [ "$imsg" != "" ]; then
						green "Persistent search log file created."
					fi
				fi
				if [ -s $rout ]; then
					sort -u -o $rout $rout
					sed -i -E '/^Deleted/ s/^([^ ]+) ([^ ]+ [^ ]+) (.+)$/\1,"\2","\2",\3/' "$rout" # input action date time file name -->  action,"date time", "date time", file name
					sed -i -E '/^Deleted/! s/^([^ ]+) ([^ ]+ [^ ]+) ([^ ]+ [^ ]+) (.+)$/\1,"\2","\3",\4/' $rout  # input Action,"date time","date time", file name spaces   
					if [ -s $COMPLETE ]; then cat $COMPLETE >> $rout; fi
					if [ "$pstc" == "true" ]; then
						imsg="$(storeenc $rout $statpst)" # decrypt store encrypt
						ret=$?
						if [ "$ret" -ne 0 ]; then
							echo "$imsg"
						else
							if [ "$imsg" != "" ]; then green "Persistent stats file created."; imsg=""; fi
						fi
					fi
				fi
			fi
		else
			if ! gpg --list-keys | grep -q $email; then generatekey ; fi	
			python3 /usr/local/save-changesnew/pstsrg.py $SORTCOMPLETE $pydbpst $rout $tfile $checkSUM $cdiag $email $mMODE $ANALYTICSECT $proteusSHIELD $nc $updatehlinks
			ret=$?
			pyerrblk
			processha $argf
		fi
	fi
fi
[[ -s "$difffile" ]] && [[ -n "$( tail -n 1 "$difffile")" ]] && [[ "$ANALYTICSECT" == "true" ]] && [[ "$backend" == "default" ]] && green "Hybrid analysis on"
if [[ "$csum" != "true" && -s $slog && "$supress" == "true" ]]; then
	{ echo; echo "cdiag"; echo ; cat $slog; } >> "$difffile"
elif [[ "$csum" != "true" && -s $slog && "$supress" == "false" ]]; then
	filteroutput $slog "Checksum" "no" "blue" "yellow" "Scr"
	{ echo; echo "cdiag"; echo ; cat $slog; } >> "$difffile" 
elif [[ "$csum" == "true" ]]; then
	{ echo; echo "cdiag alert"; echo ; cat /tmp/cerr ; } >> "$difffile"
	rm /tmp/cerr
fi
test -e $TMPDIR && rm -rf "${TMPDIR:?}"
test -f $slog && rm $slog ; test -f $rout && rm $rout
}
strup() { /usr/local/save-changesnew/start_inotify $log_file $CACHE_F "$checkSUM" "ctime" 3600 ; }

intst() {
if [ "$ANALYTICSECT" == "true" ]; then start=$(date +%s.%N); fi 

#Init
if [[ "$mMODE" == "mc" ]]; then
	cores=$( nproc 2>/dev/null || echo 1)
	max_jobs=$(( cores > 16 ? 16 : cores ))
fi	
if [ "$xRC" == "true" ]; then
	if pgrep -af 'inotify' > /dev/null; then
		if [ -n "$log_file" ]; then
			cp $log_file $tout
			if pkill -f inotifywait; then
				rm $log_file		
				strup
			else
				rm $tout
				> $log_file
			fi
		fi		
	else
		strup	
	fi
fi
if [ "$STATPST" == "true" ]; then
    if [ -f $logpst ]; then
        sz=$( stat -c %s "$logpst")
        if [ $(( sz / 1048576 )) -gt $logSIZE ]; then
            if [ "$logPRF" == "del" ]; then
               : > $logpst
            elif [ "$logPRF" == "stop" ]; then
                cyan "persist log saving stopped on size limit"
            fi
            STATPST="false"
            if [ "$logPRF" == "rfh" ]; then
                rm $logpst
                STATPST="true"
            fi
		elif [ $(( sz / 1048576 )) -ge $compLVL ]; then
			nc="true"
        elif [ $sz -eq 0 ]; then
            cyan "$logpst is 0 bytes. to resume persistent logging delete file"
            STATPST="false"
        fi
    fi
fi
}
isoutput() {
local y=$#
if (( y >= 7 )); then
	c=4
elif (( y == 4)); then
	c=2
elif (( y == 2 )); then
	c=1
else
	echo either 2 4 or 8 args
fi
for ((i = 1; i <= c; i++)); do
    files=($atmp/${!i})
    x=$((i + c))
    if [[ ${#files[@]} -gt 0 ]] && [[ " ${files[@]} " != *"${!i}"* ]]; then
        output="${!x}"
        cat "${files[@]}" >> $output
    fi
done
}
ulink() {
sbwr
green "Updating hardlinks"
#if [ "$checkSUM" == "false" ]; then fld=3 ; fi
while IFS= read -r p || [[ -n "$p" ]]; do 
    ck="false"
	#cFILE=$(perl -nE 'say $1 if /"((?:[^"\\]|\\.)*)"/' <<< "$p")
    cFILE=$(sed -E 's/.*"((\\.|[^"])*)".*/\1/' <<< "$p")
	y=$cFILE
	cln="${p//\"$y\"/}"
	read -r _ _ _ _ of5 _ <<< "$cln"
	inode="$of5"
    if [ "$supbrwr" == "true" ]; then
        for item in "${webb[@]}"; do if [[ "$y" =~ "$item" ]]; then [ -n "$item" ] && echo "None" && ck="true"; break ; fi ; done
    fi
	if [ "$inode" == "None" ] && [ "$ck" == "false" ]; then 
        echo "None" 
    elif [ "$ck" == "false" ]; then
         echo $inode
    fi
done < $1 > $TMPOPT
mapfile -t inodes_array < "$TMPOPT" ; declare -A inode_map
while read -r inode; do inode_map["$inode"]=$((inode_map["$inode"] + 1)) ; done < <(find /bin /etc /home /lib /lib64 /opt /root /sbin /usr /var -xdev -printf '%i\n' 2>/dev/null)
for inode in "${inodes_array[@]}"; do
    if [ "$inode" = "None" ]; then
        echo "None"
    else
        count=${inode_map["$inode"]}
        if [ -z "$count" ] || [ "$count" -eq 0 ] || [ "$count" -eq 1 ]; then
            echo "None"
        else
            echo "$count"
        fi
    fi
done > $TMPOPT
paste -d' ' $1 $TMPOPT > $2 ; mv $2 $SORTCOMPLETE
}
upt_cache() {
    local inode=$1
    local size=$2
    local mtime=$3
    local checksum=$4
    local path=$5
    echo "$inode|$size|$mtime $checksum $path" >> "$CACHE_F"
}
get_cached() {
    local inode=$1
    local size=$2
    local mtime=$3
    local key="$inode|$size|$mtime"
    grep -m1 "^$key " "$CACHE_F" | awk '{print $2}'
}
# Used for sysprofile as you dont want to cache the checksum
rblk() {
local sl=""
local cFILE
local csum
local y
while IFS= read -r -d '' p ; do
	read -r mtime atime itime i fs onr grp pmr path <<< "$p"
	cFILE="$path"
	y="$( escf "$cFILE")" 
	mt=$(date -d "@${mtime%%.*}" +"%Y-%m-%d %H:%M:%S")
	ct=$(date -d "@${itime%%.*}" +"%Y-%m-%d %H:%M:%S")
	if [ -e "$cFILE" ] && [ -f "$cFILE" ]; then
		if [ -n "$mt" ]; then
        	if { [[ "$4" = "ctime" ]] && (( ${itime%%.*} > ${mtime%%.*} )); } || [[ "$4" = "main" ]]; then
				if [ "$checkSUM" == "true" ]; then
					[[ "$1" = "ctime" ]] && cam="y" && mt=$ct || cam="None"
					csum=$(md5sum "$cFILE" 2> /dev/null)
					csum=${csum%% *}
					csum=${csum:-None}
					fs=${fs:-None} 
					[[ -L "$cFILE" ]] && sl="y" ; sl=${sl:-None}
					wnr=${onr:-None} ; grp=${grp:-None} ; pmn=${pmr:-None}
					adtcmd="$csum $fs $sl $wnr $grp $pmn $cam"
				else
			    	adtcmd=""
				fi
    			ats=$(date -d "@${atime%%.*}" +"%Y-%m-%d %H:%M:%S")			
				ct=${ct:-None None}
				ats=${ats:-None None}
				output="$mt \"$y\" $ct $i $ats $adtcmd"
				printf '%s\n' "$output" >> $2
			fi
		fi
	else
		printf "%s,,,%s\n" "Nosuchfile" "$y" >> $3
	fi
done < $1
}
# Mainloop do cache files over 1MB. Add unescaped filename at the end.
sblk() {
local sl=""
local cFILE
local csum
local y
local r
while IFS= read -r -d '' p ; do
	r=""
	sl=""
	csum=""
	read -r mtime atime itime i fs onr grp pmr path <<< "$p" || continue
	cFILE="$path"
	y="$( escf "$cFILE")" 
	mt=$(date -d "@${mtime%%.*}" +"%Y-%m-%d %H:%M:%S")
	ct=$(date -d "@${itime%%.*}" +"%Y-%m-%d %H:%M:%S")
	if [ -e "$cFILE" ] && [ -f "$cFILE" ]; then
		if [ -n "$mt" ]; then
        	if { [[ "$4" = "ctime" ]] && (( ${itime%%.*} > ${mtime%%.*} )); } || [[ "$4" = "main" ]]; then
				if [ "$checkSUM" == "true" ]; then
					[[ "$1" = "ctime" ]] && cam="y" && mt=$ct || cam="None"

					if (( fs > 1000000 )); then
						if [ -e "$CACHE_F" ]; then
							r=$(get_cached "$i" "$fs" "$mt")
							[ -n "$r" ] && csum="$r"
						fi
					fi
					if [ -z "$csum" ]; then
						csum=$(md5sum "$cFILE" 2>/dev/null)
						csum=${csum%% *}
						upt_cache "$i" "$fs" "$mt" "$csum" "$y"
					fi

					csum=${csum:-None}
					fs=${fs:-None} 
					[[ -L "$cFILE" ]] && sl="y" ; sl=${sl:-None}
					wnr=${onr:-None} ; grp=${grp:-None} ; pmn=${pmr:-None}
					adtcmd="$csum $fs $sl $wnr $grp $pmn $cam"
				else
			    	adtcmd=""
				fi
    			ats=$(date -d "@${atime%%.*}" +"%Y-%m-%d %H:%M:%S")			
				ct=${ct:-None None}
				ats=${ats:-None None}
				if [[ "$cFILE" == *$'\n'* ]]; then cFILE="None" ; fi # add unescaped 
				output="$mt \"$y\" $ct $i $ats $adtcmd"
				printf '%s\n' "$output" >> $2
			fi
		fi
	else
		printf "%s,,,%s\n" "Nosuchfile" "$y" >> $3
	fi
done < $1
}

# load balance for if there is over 1000 files
search() {
desired_chunks=200   # Target number of chunks
min_chunk_size=10    # Minimum lines per chunk
x=$(tr -cd '\0' < "$1" | wc -c)
if [[ "$mMODE" = "default" ]]; then     
    y=$(( (x + desired_chunks - 1) / desired_chunks ))  # chunk size approx
    [ "$y" -lt "$min_chunk_size" ] && y=$min_chunk_size
    opts=()
else
	y=$(( (x + max_jobs - 1) / max_jobs ))
	opts=(-P"$max_jobs")
fi
split -l "$y" --numeric-suffixes=1 --suffix-length=4 "$1" "$atmp/${5}chunk_"
tail=(/usr/local/save-changesnew/mainloop "$atmp" "{}" "$2" "$3" "$4" "$5" "$6" "$CACHE_F")
find "$atmp" -type f -name "${5}chunk_*" -print0 | sort -z | xargs -0 "${opts[@]}" -I{} "${tail[@]}"

}
ctimeloop() {
# what is not in the main search
sort -z -o $2 $1                
sort -z -o $tout $toutnul
comm -z -23 $tout $2 > $TMPCOMPLETE

if [ -s $TMPCOMPLETE ]; then	
	search $TMPCOMPLETE $tout $COMPLETE $checkSUM "ctime" batch2
	isoutput mainloop3* mainloop4* $tout $COMPLETE
fi
}
