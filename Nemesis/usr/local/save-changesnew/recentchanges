#!/bin/bash
#	rntfiles.xzm or -SRC application.xzm to /tmp																						09/17/2025
[[ "$1" = "SRC" ]] && SRCDIR="$1"
[[ "$2" = "SRC" ]] && SRCDIR="$2"
USR="$3"
tmp="$4"
archivesrh=$5
cmode=$6
[[ -s $RECENT ]] || return 3
                                       
RECENT=$tmp/list_recentchanges_filtered.txt		;    TMPCOMPLETE=$tmp/tmp_complete.txt
RECENTAPP=$tmp/list_recentapp_filtered.txt		;   TMPOPT=$tmp/tmp_holding
RSYNCEXCL=$tmp/list_filesexclude.txt				;   tout=$tmp/toutput.tmp
SORTCOMPLETE=$tmp/list_complete_sorted.txt	;   UPDATE=$tmp/save.transferlog.tmp
SVFILES=$tmp/save.rncfilesmanifest.tmp			;   SVFOLDERS=$tmp/save.rncfoldersmanifest.tmp


chxzm=/rntfiles.xzm     
workdir=/myfiles   

xdata=/logs_stats.log
xdata2=/logs.log.log
atmp=/tmp/atmp$$
tfile=$atmp$xdata
tfile2=$atmp$xdata2
#work=work$$

BRAND=$(date +"MDY_%m-%d-%y-TIME_%R" | tr ':' '_')
FLBRAND=$(date +"MDY_%m-%d-%y-TIME_%R_%S" | tr ':' '_')
							
validrlt="false"

mkdir $tmp$workdir
mkdir $atmp


# Copy files
#> $tout
#while IFS= read -r x; do  ; printf '%s\0' "$x"; done < $RECENT >> $tout
while IFS= read -r x; do y="$( unescf "$x")" ; if cp -a --parents "$y" "$tmp$workdir" > /dev/null 2>> $tfile; then printf '%s %s\n' "$x" "success" >> $UPDATE; else echo "Failed to copy: $x" >&2; echo "ERROR: $x" >> $UPDATE; fi; done < $RECENT
unset IFS
if [ -s $tfile ]; then echo > $UPDATE ; cat $tfile $UPDATE; fi
test -e $tfile && rm $tfile
echo $BRAND >> $UPDATE
find $tmp$workdir -not -type d -print0 > $SVFILES
>$tout
while IFS= read -r -d '' x; do x="$( escf "$x")"; echo "$x" ; done < $SVFILES >> $tout
mv $tout $SVFILES
sed -i -e "s|$tmp$workdir||g" $SVFILES
cat $SVFILES | sed -e 's![^/]*$!!g' > $SVFOLDERS



# make .xzm from root folder
if [ "$SRCDIR" == "SRC" ]; then 
    arrfiles=()
    arrreject=()
    appname="Application"
    FLTOUT="/tmp/${appname}ItemsFilteredout"
    test -e "/tmp/${appname}.xzm" && rm "/tmp/${appname}.xzm"
    rm "/tmp/"*"_xdata" 2> /dev/null
    rlt=$( validprogram $SVFOLDERS)
 	if [ "$rlt" == "/" ]; then echo Fatal error. exiting. && exit 1 ; fi
    if [ "$rlt" != "" ]; then
        cat $SVFILES | grep "${rlt}" > $RECENTAPP ; cat $SVFILES | grep -v "${rlt}" > $RSYNCEXCL
		find $tmp$workdir -type d -empty -delete 
		while IFS= read -r p || [ -n "$p" ]; do  p="$( unescf "$p")" ; p="${p#/}" ; echo "$p" >> $tfile ; done < $RSYNCEXCL # This is for our SRC files after finding root
        test -s $tfile && mksquashfs $tmp$workdir "/tmp/${appname}.xzm" -comp $cmode -ef $tfile || { [[ ! -s "$tfile" ]] && mksquashfs $tmp$workdir "/tmp/${appname}.xzm" -comp $cmode ; }
        cp $RECENTAPP "/tmp/${appname}_xdata" ; echo $BRAND >> "/tmp/${appname}_xdata"
        sort -o $RECENTAPP $RECENTAPP
        cat $SORTCOMPLETE | grep -Ff $RECENTAPP | grep -v 'NOTA-FI-LE 77:77:77'  | tee $TMPCOMPLETE > /dev/null
        endtm=$( gettime "$TMPCOMPLETE" "/tmp/${appname}_xdata")
        printf "\n\n" >> "/tmp/${appname}_xdata"
        cat $TMPOPT  | grep -Fvf $RECENTAPP > $TMPCOMPLETE
	    cd $tmp$workdir || exit
	    srcpath="${rlt#?}"
		> $tfile
		r=$( find "${rlt}" -type f | wc -l)  # system
		s=$(grep -n 'MDY' "/tmp/${appname}_xdata" | head -n 1 | cut -d: -f1)arrreject
		if [[ -n "$s" ]]; then s=$(( s - 1 )) ; else s=0 ; fi
		x=0
		y=$( wc -l < $RECENTAPP) # copied
		while IFS= read -r -d '' f ; do echo "$f" >> $tfile ;  x=$(( x + 1 )) ; done < <(find "${srcpath}" \( -type f -o -type l \) -print0)  # Our system files is what we should be comparing		
		{ echo Root:"${rlt}" ; echo "File count: "$x "of ${y}" ; echo "System count: "$r ; echo ; echo ; } >> "/tmp/${appname}_xdata"   
		if (( x < y )); then  #Default
			sort -o $tfile $tfile
			sort $RECENT > $tfile2
			comm -23 $tfile $tfile2 > $tout
			{ echo ; echo "Transfer: File transfer failed. " ; echo ; echo "Following file(s) were not transfered:" ; cat $tout ;} >> "/tmp/${appname}_xdata"
		elif (( x == y)); then
			{ echo "Transfer: File transfer verified " ; echo ; } >> "/tmp/${appname}_xdata"
		else
			{ echo "SRC mode failed. use recentchanges to package application." ; } >> "/tmp/${appname}_xdata"
		fi
		if (( r > s )); then echo "Status: Possibly missed base directory. Confirm files or use recentchanges for rntfiles.xzm." >> "/tmp/${appname}_xdata" ; fi
        echo $BRAND >> $RECENTAPP
        if [ -s $TMPCOMPLETE ]; then { echo ; echo "Items filterout from filtered files."; echo ; cat $TMPCOMPLETE; }  >> "/tmp/${appname}_xdata" ; else echo "No items filtered out from filter."  >>"/tmp/${appname}_xdata" ; fi
        find "$tmp$workdir$rlt" -type f -print0 > $TMPCOMPLETE
        while IFS= read -r -d '' f; do  f="$( escf "$f")" ; arrfiles=("${arrfiles[@]}" "${f##*/}"); done < $TMPCOMPLETE
        x=${#arrfiles[@]}
        y=0
        echo ""
        for i in "${arrfiles[@]}" ; do
            p=$(( y + 1 ))
            printf "%2d %-40s\t\t" "$p" "${i}"
            (( y++ ))
            if  [ $(( y % 2 )) -eq 0 ]; then
                echo -en "\n"
            else
                if (( y == x )); then
                    echo -en "\n"
                fi
            fi
            if (( y > 70 )); then
                break
            fi
        done
        echo "Root folder" "${rlt##*/}"
        echo  "Press enter for default filename"
        read  -r -p 'Filename or Selection: ' usrslc
        if [ "$usrslc" != "" ]; then
            if [ "$usrslc" -ge 0 ]  2>/dev/null; then
                echo selected "$usrslc"
                if [ "${#arrfiles[@]}" -ge "$usrslc" ]; then
                    filename="${arrfiles[$(( usrslc - 1 ))]}"
                else
                    echo
                    echo "Using default filename."
                    filename="$appname"
                fi
            else
                filename="$usrslc" #User
            fi
        else
            filename="$appname" #Default
        fi
		fn=$(printf '%b' "$filename") ; fn=$( echo "$fn" | sed -e 's/\...$//' -e 's/\....$//' -e 's/ /_/g')
        if [ "$fn" != "${appname}" ]; then mv /tmp/"$appname".xzm /tmp/"$fn".xzm ; mv /tmp/"$appname"_xdata /tmp/"$fn"_xdata ; fi
        chown $USR /tmp/"$fn".xzm
        chown $USR /tmp/"$fn"_xdata
    fi
fi

echo $BRAND >> $SVFILES
cd /tmp || exit
MODULENAME=${chxzm:0:9}
LCLMODULENAME=${chxzm:1:8}
chxzmnm=$MODULENAME"manifest.txt"
moduledir=$MODULENAME"_"$FLBRAND
FLTOUT="/tmp"$MODULENAME"ItemsFilteredout"
k=$( head -n1 $SVFILES | grep "MDY")

#Are there files for recentchanges, move old files, ect
if [ -z "$k" ]; then
	validrlt="true"
    r=$(find . -maxdepth 1 -type d -name '*rntfiles_MDY*' | wc -l) #Move
    if (( r == archivesrh )); then for folder in "/tmp"$MODULENAME_MDY* ;  do rm -r $folder ; break ; done ; fi
    mkdir "/tmp"$moduledir && chown $USR "/tmp"$moduledir
    test -e /tmp"$chxzm" && mv /tmp"$chxzm" "/tmp"$moduledir ; test -e "/tmp"$chxzmnm && mv "/tmp"$chxzmnm "/tmp"$moduledir; test -e "/tmp"$MODULENAME"Transferlog" && mv "/tmp"$MODULENAME"Transferlog" "/tmp"$moduledir
    mv $LCLMODULENAME"xSystemchanges"* "/tmp"$moduledir 2> /dev/null ; mv $LCLMODULENAME"xSystemDiffFromLastSearch"* "/tmp"$moduledir 2> /dev/null
    test -e  "/tmp"$MODULENAME"ItemsFilteredout" && rm  "/tmp"$MODULENAME"ItemsFilteredout"

    if [ "$SRCDIR" != "SRC" ]; then # make rntfiles.xzm from all filtered
	    mksquashfs $tmp$workdir "/tmp"$chxzm -comp $cmode
	    cp $SVFILES "/tmp"$chxzmnm
	    cp $UPDATE  "/tmp"$MODULENAME"Transferlog"
        if [ "$validrlt" == "true" ]; then
            sort -o $RECENT $RECENT
            cat $TMPOPT | grep -Fvf $RECENT > $FLTOUT ; echo $BRAND >> $FLTOUT
            cat $TMPOPT | grep -Ff $RECENT | tee $TMPCOMPLETE > /dev/null
            sed -i '/^[[:space:]]*$/d' $TMPCOMPLETE
            endtm=$( gettime $TMPCOMPLETE "/tmp"$chxzmnm)
        fi
        chown $USR "/tmp"$chxzm ; chown $USR "/tmp"$chxzmnm ; chown $USR "/tmp"$MODULENAME"Transferlog" ; chown $USR $FLTOUT
        test -e "/tmp"$moduledir && chown $USR "/tmp"$moduledir
    fi
fi


#postop $TMPOPT $0

#Cleanup
rm -rf $tmp 
rm -rf $atmp

if [ "$validrlt" == "true" ]; then
    imsg="Your module has been created. in /tmp"
    echo
    if [ "$SRCDIR" == "SRC" ]; then
        imsg="${imsg} ${filename}.xzm"
    else
		imsg=$(cat <<EOF
$imsg
Total pull range: ${endtm} $chxzm including a file manifest
EOF
)
    fi
    printf "%b\n" "$imsg"
else
    return 7
fi
